// COPYRIGHT 2009, 2010, 2011, 2012, 2013, 2014, 2015 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

//#define DEBUGSCR

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;

using FreeTrainSimulator.Common;

using Orts.Formats.Msts.Models;
using Orts.Simulation.RollingStocks;

namespace Orts.ActivityRunner.Viewer3D.Sound
{
    /////////////////////////////////////////////////////////
    // SOUND STREAM
    /////////////////////////////////////////////////////////

    /// <summary>
    /// Owned by a <see cref="SoundSource"/>,
    /// can play only one sound at a time,
    /// the sound played is controlled by the various triggers
    /// </summary>
#pragma warning disable CA1711 // Identifiers should not have incorrect suffix
    public class SoundStream : IDisposable
#pragma warning restore CA1711 // Identifiers should not have incorrect suffix
    {
        /// <summary>
        /// Each stream can contain only one initial trigger, which should be audible
        /// in case the SoundSource is in scope, and no other variable trigger is active
        /// </summary>
        private readonly InitialSoundTrigger initialTrigger;

        /// <summary>
        /// Owner SoundSource
        /// </summary>
        public SoundSource SoundSource { get; }
        /// <summary>
        /// Stream's volume can be controlled independently of the SoundSource's
        /// </summary>
        public float Volume { get; set; }
        /// <summary>
        /// List of triggers controlling this stream
        /// </summary>
        public ImmutableArray<SoundTrigger> Triggers { get; } = ImmutableArray<SoundTrigger>.Empty;
        /// <summary>
        /// OpenAL compatible representation of SoundStream.
        /// By OpenAL terminilogy our SoundStream is called as "SoundSource"
        /// </summary>
        public ALSoundSource ALSoundSource { get; }
        /// <summary>
        /// A stream as is represented in sms file
        /// </summary>
        protected SmsStream MSTSStream { get; }
        /// <summary>
        /// If soundstream needs active management by sound process, or can be left to OpenAL
        /// </summary>
        public bool NeedsFrequentUpdate { get; private set; }
        /// <summary>
        /// If stream contains a release trigger with jump, looping cannot be handled fully by OpenAL.
        /// Sound process needs to watch carefully for jump command
        /// </summary>
        public bool IsReleasedWithJump { get; private set; }
        /// <summary>
        /// Store trigger used last time for being able to check if trigger got repeated
        /// </summary>
        public SoundTrigger LastTriggered { get; set; } = new SoundTrigger();
        /// <summary>
        /// True if the same trigger was used repeatedly.
        /// Needs for avoiding to queue same sound multiple times
        /// in case the player keeps hitting the keyboard
        /// </summary>
        public bool RepeatedTrigger { get; set; }
        /// <summary>
        /// List of owned variable triggers. Used at determining if initial trigger is to be audible
        /// </summary>
        public ImmutableArray<VariableSoundTrigger> VariableTriggers { get; } = ImmutableArray<VariableSoundTrigger>.Empty;

        private bool disposedValue;

        public SoundStream(SmsStream mstsStream, SoundEventSource eventSource, SoundSource soundSource)
        {
            ArgumentNullException.ThrowIfNull(mstsStream, nameof(mstsStream));
            ArgumentNullException.ThrowIfNull(soundSource, nameof(soundSource));

            SoundSource = soundSource;
            MSTSStream = mstsStream;
            Volume = MSTSStream.Volume;
            float rolloffFactor = SoundSource.RolloffFactor;

            // Insert lower RollOff for horns
            if (mstsStream.Triggers != null)
            {
                foreach (Trigger trigger in mstsStream.Triggers)
                    if (trigger is DiscreteTrigger && soundSource.Car != null && (trigger as DiscreteTrigger).TriggerId == 8)
                    {
                        rolloffFactor = SoundSource.HornRolloffFactor;
                        break;
                    }
            }

            ALSoundSource = new ALSoundSource(soundSource.EnvironmentSound, rolloffFactor);

            if (mstsStream.Triggers != null)
                foreach (Trigger trigger in mstsStream.Triggers)
                {
                    if (trigger.SoundCommand == null) // ignore improperly formed SMS files
                    {
                        Triggers = Triggers.Add(new SoundTrigger()); // null trigger
                    }
                    else if (trigger is DistanceTravelledTrigger distanceTrigger && soundSource.Car != null)
                    {
                        Triggers = Triggers.Add(new DistanceTravelledSoundTrigger(this, distanceTrigger));
                    }
                    else if (trigger is InitialTrigger initialTrigger)
                    {
                        this.initialTrigger = new InitialSoundTrigger(this, initialTrigger);
                        Triggers = Triggers.Add(this.initialTrigger);
                    }
                    else if (trigger is RandomTrigger randomTrigger)
                    {
                        Triggers = Triggers.Add(new RandomSoundTrigger(this, randomTrigger));
                    }
                    else if (trigger is VariableTrigger variableTrigger && (soundSource.Car != null || soundSource.EnvironmentSound))
                    {
                        Triggers = Triggers.Add(new VariableSoundTrigger(this, variableTrigger));
                    }
                    else if (trigger is DiscreteTrigger discreteTrigger)
                    {
                        DiscreteSoundTrigger ortsTrigger = new DiscreteSoundTrigger(this, eventSource, discreteTrigger);
                        Triggers = Triggers.Add(ortsTrigger);  // list them here so we can enable and disable
                        if (SoundSource.Car != null)
                            SoundSource.Car.OnCarSound += ortsTrigger.OnCarSoundEvent; // tell the simulator to call us when the event occurs
                    }
                    // unapplicable trigger type
                    else
                    {
                        Triggers = Triggers.Add(new SoundTrigger()); // null trigger
                        if (SoundSource.SMSFileName != "ingame.sms")
                            Trace.TraceWarning("Trigger type of trigger number {2} in stream number {1} in file {0} is not existent or not applicable",
SoundSource.SMSFileName, SoundSource.SoundStreams.Length, Triggers.Length - 1);
                    }
                    IsReleasedWithJump |= Triggers.Last().SoundCommand is ORTSReleaseLoopReleaseWithJump;
                }  // for each mstsStream.Trigger

            VariableTriggers = Triggers.OfType<VariableSoundTrigger>().ToImmutableArray();
        }

        public SoundStream(string wavFileName, SoundSource soundSource)
        {
            ArgumentNullException.ThrowIfNull(soundSource, nameof(soundSource));

            SoundSource = soundSource;
            Volume = 1.0f;

            ALSoundSource = new ALSoundSource(soundSource.EnvironmentSound, soundSource.RolloffFactor);

            initialTrigger = new InitialSoundTrigger(this, wavFileName);
            Triggers = Triggers.Add(initialTrigger);
        }

        /// <summary>
        /// Create a sound stream with an arbitrary set of triggers.
        /// </summary>
        /// <param name="soundSource">The parent sound source.</param>
        /// <param name="triggerGenerator">A generator function to create the triggers.</param>
        public SoundStream(SoundSource soundSource, Func<SoundStream, IEnumerable<SoundTrigger>> triggerGenerator)
        {
            ArgumentNullException.ThrowIfNull(soundSource, nameof(soundSource));
            ArgumentNullException.ThrowIfNull(triggerGenerator, nameof(triggerGenerator));

            SoundSource = soundSource;
            Volume = 1.0f;

            ALSoundSource = new ALSoundSource(soundSource.EnvironmentSound, soundSource.RolloffFactor);
            Triggers = Triggers.AddRange(triggerGenerator(this));
        }

        /// <summary>
        /// Update OpenAL sound source position, then calls the main <see cref="Update()"/> function
        /// Position is relative to camera tile's center
        /// </summary>
        /// <param name="position"></param>
        public void Update(float[] position)
        {
            OpenAL.Sourcefv(ALSoundSource.SoundSourceID, OpenAL.AL_POSITION, position);
            Update();
        }

        /// <summary>
        /// Try triggers, update frequency and volume according to curves, call queue management
        /// </summary>
        public void Update()
        {
            if (ALSoundSource == null)
            {
                return;
            }

            foreach (SoundTrigger trigger in Triggers)
                trigger.CheckTrigger();

            if (initialTrigger != null)
            {
                // If no triggers active, Initialize the Initial
                if (!ALSoundSource.IsPlaying)
                {
                    if (VariableTriggers.Length > 0 || Triggers.Length == 1)
                    {
                        int activeTriggers = VariableTriggers.Where(t => t.BelowThreshold).Cast<SoundTrigger>().Count();

                        if (activeTriggers == VariableTriggers.Length && initialTrigger.SoundCommand is ORTSSoundPlayCommand
                            && !(initialTrigger.SoundCommand is ORTSPlayOneShot && initialTrigger.Signaled))
                        {
                            initialTrigger.Initialize();
                        }
                    }
                }
                // If triggers are active, reset the Initial
                else
                {
                    int activeTriggers = Triggers.Where(t => t.Signaled && (t.SoundCommand is ORTSStartLoop || t.SoundCommand is ORTSStartLoopRelease)).Count();
                    if (activeTriggers > 1 && initialTrigger.Signaled)
                        initialTrigger.Signaled = false;
                }
            }

            SetFreqAndVolume();

            ALSoundSource.Update();
            NeedsFrequentUpdate |= ALSoundSource.NeedsFrequentUpdate;
        }

        /// <summary>
        /// Calculate frequency and volume according to curves defined in sms file
        /// </summary>
        private void SetFreqAndVolume()
        {
            if (ALSoundSource == null)
                return;

            if (MSTSStream != null && MSTSStream.FrequencyCurve != null)
            {
                if (SoundSource.Car != null || Program.Viewer.Camera.AttachedCar != null)
                {
                    float x = 0;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Mode, SoundSource.Car);
                    else if (Program.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Mode, (MSTSWagon)Program.Viewer.Camera.AttachedCar);
                    float y = Interpolate(x, MSTSStream.FrequencyCurve);
                    if (SoundSource.MstsMonoTreatment && ALSoundSource.MstsMonoTreatment)
                        y *= 2;

                    ALSoundSource.PlaybackSpeed = y / ALSoundSource.SampleRate;
                    NeedsFrequentUpdate = x != 0;
                }
            }

            float volume = SoundSource.Volume * Volume;

            if (MSTSStream != null && MSTSStream.VolumeCurves.Count > 0)
                for (int i = 0; i < MSTSStream.VolumeCurves.Count; i++)
                {
                    float x;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Mode, SoundSource.Car);
                    else if (Program.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Mode, (MSTSWagon)Program.Viewer.Camera.AttachedCar);
                    else
                        x = SoundSource.DistanceSquared;

                    volume *= Interpolate(x, MSTSStream.VolumeCurves[i]);
                }

            if (SoundSource.ExternalSource && Program.Viewer.Camera.Style != CameraStyle.External && !SoundSource.Unattenuated)
            {
                if (Program.Viewer.Camera.AttachedCar == null || ((MSTSWagon)Program.Viewer.Camera.AttachedCar).ExternalSoundPassThruPercent == -1)
                    volume *= Program.Viewer.UserSettings.ExternalSoundPassThruPercent * 0.01f;
                else
                    volume *= ((MSTSWagon)Program.Viewer.Camera.AttachedCar).ExternalSoundPassThruPercent * 0.01f;
            }

            ALSoundSource.Volume = volume;
        }

        /// <summary>
        /// There must be at least two points in the curve
        /// // TODO do we need to implement support for Granularity()
        /// </summary>
        /// <param name="x"></param>
        /// <param name="Curve"></param>
        /// <returns></returns>
        private static float Interpolate(float x, Curve Curve)
        {
            if (Curve.CurvePoints.Length < 2)
                return Curve.CurvePoints[0].Y;

            CurvePoint[] curvePoints = Curve.CurvePoints;

            if (x < curvePoints[0].X)
                return curvePoints[0].Y;
            if (x > curvePoints[^1].X)
                return curvePoints[^1].Y;

            int i = 1;
            while (i < curvePoints.Length - 1
                && curvePoints[i].X < x)
                ++i;
            // i points to the point equal to or above x, or to the last point in the table

            x -= curvePoints[i - 1].X;
            float rx = x / (curvePoints[i].X - curvePoints[i - 1].X);

            float dy = curvePoints[i].Y - curvePoints[i - 1].Y;

            float y = curvePoints[i - 1].Y + rx * dy;

            return y;
        }

        /// <summary>
        /// Read a variable from the attached TrainCar data
        /// </summary>
        /// <param name="control"></param>
        /// <param name="car"></param>
        /// <returns></returns>
        private float ReadValue(Curve.ControlMode control, MSTSWagon car)
        {
            return control switch
            {
                Curve.ControlMode.Distance => SoundSource.DistanceSquared,
                Curve.ControlMode.Speed => car.AbsSpeedMpS,
                Curve.ControlMode.Variable1 => car.SoundValues.X,
                Curve.ControlMode.Variable2 => car.SoundValues.Y,
                Curve.ControlMode.Variable3 => car.SoundValues.Z,
                Curve.ControlMode.BrakeCylinder => car.BrakeSystem.GetCylPressurePSI(),
                Curve.ControlMode.CurveForce => (float)car.CurveForceFiltered,
                _ => 0,
            };
        }

        /// <summary>
        /// Stop OpenAL playing this stream, and flush buffers
        /// </summary>
        public void Stop()
        {
            ALSoundSource?.Stop();
        }

        /// <summary>
        /// Restore any previously playing sounds
        /// </summary>
        public void Activate()
        {
            if (ALSoundSource != null)
            {
                // Precalc volume to avoid glitches
                SetFreqAndVolume();
                ALSoundSource.Active = true;
            }
        }

        /// <summary>
        /// Deactivates a previously active sound
        /// </summary>
        public void Deactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Active = false;
                ALSoundSource.HardDeactivate();
            }
        }

        /// <summary>
        /// Allocates a new sound source ID in OpenAL, if one is not allocated yet.
        /// </summary>
        /// <param name="ignore3D">Whether the stream's world position should be ignored</param>
        public void HardActivate(bool ignore3D)
        {
            ALSoundSource?.HardActivate(ignore3D, SoundSource.TrainCar);
        }

        /// <summary>
        /// Frees up the allocated sound source ID, and tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        public void HardDeactivate()
        {
            ALSoundSource?.HardDeactivate();
            Sweep();
        }

        /// <summary>
        /// Tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        private void Sweep()
        {
            foreach (SoundTrigger trigger in Triggers)
            {
                if (trigger.SoundCommand is ORTSSoundPlayCommand soundPlayCommand)
                {
                    foreach (var name in soundPlayCommand.Files)
                        SoundItem.Sweep(name, SoundSource.ExternalSource, IsReleasedWithJump);
                }
            }
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    if (ALSoundSource != null)
                    {
                        ALSoundSource.HardDeactivate();
                        ALSoundSource.Dispose();
                    }
                    Sweep();
                }

                // TODO: free unmanaged resources (unmanaged objects) and override finalizer
                // TODO: set large fields to null
                disposedValue = true;
            }
        }

        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}

