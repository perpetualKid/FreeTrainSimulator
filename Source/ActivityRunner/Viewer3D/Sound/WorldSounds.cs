// COPYRIGHT 2009, 2010, 2011, 2012, 2013, 2014, 2015 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.IO;

using FreeTrainSimulator.Common.Position;

using Orts.Formats.Msts;
using Orts.Formats.Msts.Files;
using Orts.Formats.Msts.Models;
using Orts.Simulation;

namespace Orts.ActivityRunner.Viewer3D.Sound
{
    public class WorldSounds
    {
        private readonly ConcurrentDictionary<string, List<WorldSoundRegion>> soundRegions = new ConcurrentDictionary<string, List<WorldSoundRegion>>();
        private readonly Viewer viewer;

        public WorldSounds(Viewer viewer)
        {
            this.viewer = viewer;
        }

        //TODO 2025-04014 refactor for tile-based lookups
        public int GetTrackSoundType(Simulation.Physics.Train train, out float outPrevDist, out float outNextDist)
        {
            ArgumentNullException.ThrowIfNull(train, nameof(train));

            int retval = 0;
            Traveller traveller;
            Traveller tmp;
            outPrevDist = -1;
            outNextDist = -1;

            traveller = train.SpeedMpS >= 0 ? new Traveller(train.FrontTDBTraveller) : new Traveller(train.RearTDBTraveller, true);

            List<TrackItem> trItems = RuntimeData.Instance.TrackDB.TrackItems;

            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;

            float prevDist = float.MaxValue;
            float nextDist = float.MaxValue;
            float d;

            // Check every sound region's all track nodes
            foreach (List<WorldSoundRegion> lwsr in soundRegions.Values)
            {
                foreach (WorldSoundRegion wsr in lwsr)
                {
                    foreach (int trNode in wsr.TrackNodes)
                    {
                        if (trItems[trNode] is SoundRegionItem)
                        {
                            tmp = new Traveller(traveller);

                            // Try to find forward
                            d = tmp.DistanceTo(trItems[trNode].Location, 8192);

                            if (d != -1)
                            {
                                // This is nearer than previous one
                                if (d < nextDist)
                                {
                                    nextDist = d;
                                    nextItem = wsr;
                                }
                                // Or at exactly the same distance
                                else if (d == nextDist)
                                {
                                    if (traveller.Direction == tmp.Direction)
                                        tmp.ReverseDirection();

                                    // If faces toward us then it is applicable
                                    if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                    {
                                        nextDist = d;
                                        nextItem = wsr;
                                    }
                                }
                            }
                            else
                            {
                                // Not found forward, check backward
                                tmp = new Traveller(traveller, true);

                                d = tmp.DistanceTo(trItems[trNode].Location, 8192);
                                if (d != -1)
                                {
                                    // It is nearer than previous
                                    if (d < prevDist)
                                    {
                                        prevDist = d;
                                        prevItem = wsr;
                                    }
                                    else if (d == prevDist)
                                    {
                                        if (traveller.Direction != tmp.Direction)
                                            tmp.ReverseDirection();

                                        // Applicable if faces with us
                                        if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                        {
                                            prevDist = d;
                                            prevItem = wsr;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Have before and behind us
            if (prevItem != null && nextItem != null)
            {
                // Between same type, means we are in a sound region
                if (prevItem.TrackType == nextItem.TrackType)
                {
                    // return one of those, doesn't matter which.
                    retval = prevItem.TrackType;
                    outPrevDist = prevDist;
                    outNextDist = nextDist;
                }
                else if (nextDist < 10)
                {
                    // We are between different regions and the next is very near
                    // This case we won't change to default, unnecessary to that short period of time
                    // int.MaxValue means do not change the current region even if we left it
                    retval = int.MaxValue;
                }
                //  they are different types and far from each other
                //  So we are in a neutral zone, retval is 0, default track type
            }
            else if (prevItem != null)
            {
                // only one, take it!
                retval = prevItem.TrackType;
                outPrevDist = prevDist;
            }
            else if (nextItem != null)
            {
                // only one, take it!
                retval = nextItem.TrackType;
                outNextDist = nextDist;
            }
            //  - Missing items before or behind us, maintain last sound
            else
            {
                retval = int.MaxValue;
            }
            return retval;
        }

        public void AddByTile(in Tile tile)
        {
            string name = Path.Combine(Simulator.Instance.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(tile) + "s");
            WorldSoundFile wf = new WorldSoundFile(name, RuntimeData.Instance.TrackDB.TrackItems.Count);
            if (wf.TrackItemSound != null)
            {
                ImmutableArray<string> pathArray = ImmutableArray.Create(
                    Simulator.Instance.RouteFolder.SoundFolder, Simulator.Instance.RouteFolder.ContentFolder.SoundFolder);

                Collection<SoundSourceBase> ls = new Collection<SoundSourceBase>();
                foreach (var fss in wf.TrackItemSound.SoundSources)
                {
                    WorldLocation wl = new WorldLocation(tile, fss.Position);
                    var fullPath = FolderStructure.FindFileFromFolders(pathArray, fss.FileName);
                    if (fullPath != null)
                    {
                        SoundSource soundSource = new SoundSource(wl, SoundEventSource.None, fullPath, true);
                        ls.Add(soundSource);
                    }
                }
                viewer.SoundProcess.AddSoundSources(name, ls);

                soundRegions.TryAdd(name, wf.TrackItemSound.SoundRegions);
            }
        }

        public void RemoveByTile(in Tile tile)
        {
            string name = Path.Combine(viewer.Simulator.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(tile) + "s");
            viewer.SoundProcess.RemoveSoundSources(name);
            soundRegions.TryRemove(name, out _);
        }
    }
}

