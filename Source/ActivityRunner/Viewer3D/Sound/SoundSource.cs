// COPYRIGHT 2009, 2010, 2011, 2012, 2013, 2014, 2015 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;

using FreeTrainSimulator.Common;
using FreeTrainSimulator.Common.Position;

using Orts.ActivityRunner.Viewer3D.RollingStock;
using Orts.Formats.Msts;
using Orts.Formats.Msts.Files;
using Orts.Formats.Msts.Models;
using Orts.Simulation.RollingStocks;

namespace Orts.ActivityRunner.Viewer3D.Sound
{
    /// <summary>
    /// Represents an sms file
    /// </summary>
    public class SoundSource : SoundSourceBase
    {
        private SoundActivationCondition ActivationConditions;
        private SoundActivationCondition DeactivationConditions;

        /// <summary>
        /// Out-of-scope state in previous <see cref="Update"/> loop
        /// </summary>
        private bool previousOutOfDistance = true;
        /// <summary>
        /// Different rolloff factor is used for track sounds not to attenuate so fast. As a bargain they are not silenced at cutoff distance
        /// </summary>
        private readonly bool slowRolloff;

        private WorldLocation worldLocation;

        /// <summary>
        /// Current location of the sound source
        /// </summary>
        public ref readonly WorldLocation WorldLocation => ref worldLocation;

        /// <summary>
        /// The wave files will be relative to this folder
        /// </summary>
        public string SMSFolder { get; private set; }
        public string SMSFileName { get; private set; }
        public string WavFolder { get; private set; }
        public string WavFileName { get; private set; }
        public bool Active { get; private set; }
        public bool EnvironmentSound { get; private set; }
        public bool ExternalSource { get; private set; } = true;
        public bool Ignore3D { get; private set; }

        /// <summary>
        /// MSTS treats Stereo() tagged mono wav files specially. This is a flag
        /// indicating if this treatment should be applied here
        /// </summary>
        public bool MstsMonoTreatment { get; private set; }

        /// <summary>
        /// Current distance to camera, squared meter. Is used for comparision to <see cref="CutOffDistanceM2"/>, to determine if is out-of-scope
        /// </summary>
        public float DistanceSquared { get; private set; } = float.MaxValue;

        /// <summary>
        /// List of Streams in sms
        /// </summary>
        public ImmutableArray<SoundStream> SoundStreams { get; private set; } = ImmutableArray<SoundStream>.Empty;
        /// <summary>
        /// Squared cutoff distance. No sound is audible above that, except for the actual player train,
        /// where cutoff occurs at a distance wich is higher than the train length plus offset to 
        /// approximately take into account distance from camera to car
        /// </summary>
        private int CutOffDistanceM2
        {
            get
            {
                const int staticDistanceM2 = 4000000;
                bool player = Car?.Train?.IsActualPlayerTrain ?? false;
                float correctedLength = player ? Car.Train.Length + 50 : 0;
                return (int)Math.Max(staticDistanceM2, correctedLength * correctedLength);
            }
        }
        /// <summary>
        /// Max distance for OpenAL inverse distance model. Equals to Math.Sqrt(CUTOFFDISTANCE)
        /// </summary>
        public const float MaxDistance = 2000f;
        /// <summary>
        /// Desired max gain at max distance for OpenAL inverse distance model
        /// </summary>
        public const float GainAtMaxDistance = 0.025f;
        /// <summary>
        /// Below this distance there is no attenuation. Used by OpenAL inverse distance model
        /// </summary>
        public const float ReferenceDistance = 8f;
        /// <summary>
        /// Sound attenuation factor. Calculated to achieve goal set by <see cref="GainAtMaxDistance"/>
        /// </summary>
        public float RolloffFactor { get; private set; }
        /// <summary>
        /// Used for InGame sounds and activity sounds of type "Overall"
        /// </summary>
        public bool Unattenuated { get; private set; }
        /// <summary>
        /// Used for Horns
        /// </summary>
        public const float HornRolloffFactor = 0.05f;

        /// <summary>
        /// Construct a SoundSource attached to a train car.
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(MSTSWagon car, TrainCarViewer carViewer, string smsFilePath) :
            base(carViewer)
        {
            Car = car ?? throw new ArgumentNullException(nameof(car));
            Initialize(car.WorldPosition.WorldLocation, SoundEventSource.Car, smsFilePath);
        }

        /// <summary>
        /// Initializes a SoundSource which has no specific location - like ingame.sms
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(SoundEventSource eventSource, string smsFilePath, bool unattenuated)
        {
            Unattenuated = unattenuated;
            Initialize(WorldLocation.None, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(in WorldLocation worldLocation, SoundEventSource eventSource, string smsFilePath)
        {
            EnvironmentSound = true;
            Initialize(worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="slowRolloff"></param>
        public SoundSource(in WorldLocation worldLocation, SoundEventSource eventSource, string smsFilePath, bool slowRolloff)
        {
            EnvironmentSound = true;
            this.slowRolloff = slowRolloff;
            Initialize(worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource attached to a train car, with predefined parameters (activity sound).
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(MSTSWagon car, string wavFilePath, OrtsActivitySoundFileType ORTSActSoundFileType)
        {
            Car = car ?? throw new ArgumentNullException(nameof(car));
            Initialize(car.WorldPosition.WorldLocation, wavFilePath, ORTSActSoundFileType);
        }

        /// <summary>
        /// Construct a SoundSource which has no specific location - like ingame.sms, with predefined parameters (activity sound)
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(string wavFilePath, OrtsActivitySoundFileType activitySoundFileType, bool unattenuated)
        {
            Unattenuated = unattenuated;
            Initialize(WorldLocation.None, wavFilePath, activitySoundFileType);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation, with predefined parameters (activity sound)
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="slowRolloff"></param>
        public SoundSource(in WorldLocation worldLocation, string wavFilePath, bool slowRolloff, OrtsActivitySoundFileType activitySoundFileType)
        {
            EnvironmentSound = true;
            this.slowRolloff = slowRolloff;
            Initialize(worldLocation, wavFilePath, activitySoundFileType);
        }

        /// <summary>
        /// Construct a SoundSource that has no specific location and a set of programmatically defined <see cref="SoundStream"/>s.
        /// </summary>
        /// <param name="viewer">The <see cref="Viewer"/> to attach this SoundSource to.</param>
        /// <param name="makeStreams">A generator function to create the attached SoundStreams.</param>
        public SoundSource(Func<SoundSource, IEnumerable<SoundStream>> makeStreams)
        {
            ArgumentNullException.ThrowIfNull(makeStreams, nameof(makeStreams));
            Unattenuated = true;
            Initialize();
            SoundStreams = SoundStreams.AddRange(makeStreams(this));
        }

        /// <summary>
        /// Stop the streams, free up OpenAL sound source IDs and try to unload wave data from memory
        /// </summary>
        public override void Uninitialize()
        {
            foreach (SoundStream ss in SoundStreams)
            {
                ss.Stop();
                ss.HardDeactivate();
                previousOutOfDistance = true;
                NeedsFrequentUpdate = false;
            }
        }

        /// <summary>
        /// Set properties of this SoundSource based on parsing the sms file, and generate SoundStreams
        /// </summary>
        /// <param name="viewer">Current <see cref="Viewer3D"/></param>
        /// <param name="worldLocation">World location of <see cref="SoundSource"/></param>
        /// <param name="eventSource">Type of game part sms belongs to, to determine how to interpret discrete trigger numbers</param>
        /// <param name="smsFilePath">Full path for sms file</param>
        public void Initialize(in WorldLocation worldLocation, SoundEventSource eventSource, string smsFilePath)
        {
            this.worldLocation = worldLocation;

            if (smsFilePath == null)
                return;

            SMSFolder = Path.GetDirectoryName(smsFilePath);
            SMSFileName = Path.GetFileName(smsFilePath);
            SoundManagmentFile smsFile = SharedSMSFileManager.Get(smsFilePath);


            // find correct ScalabiltyGroup
            int scalabiltyGroup = 0;
            while (scalabiltyGroup < smsFile.ScalabiltyGroups.Count)
            {

                if (smsFile.ScalabiltyGroups[scalabiltyGroup].DetailLevel <= viewer.UserSettings.SoundDetailLevel)
                    break;
                ++scalabiltyGroup;
            }
            if (scalabiltyGroup < smsFile.ScalabiltyGroups.Count && smsFile.ScalabiltyGroups[scalabiltyGroup].Streams != null)  // else we want less sound so don't provide any
            {
                ScalabilityGroup mstsScalabiltyGroup = smsFile.ScalabiltyGroups[scalabiltyGroup];

                ActivationConditions = mstsScalabiltyGroup.Activation;
                DeactivationConditions = mstsScalabiltyGroup.Deactivation;
                Volume = mstsScalabiltyGroup.Volume;
                Ignore3D = mstsScalabiltyGroup.Ignore3D | mstsScalabiltyGroup.Stereo;
                MstsMonoTreatment = mstsScalabiltyGroup.Stereo;
                ExternalSource = ActivationConditions.ExternalCam;

                SetRolloffFactor();

                foreach (SmsStream mstsStream in mstsScalabiltyGroup.Streams)
                {
                    SoundStreams = SoundStreams.Add(new SoundStream(mstsStream, eventSource, this));
                }
            }
        }

        /// <summary>
        /// Set properties of this SoundSource with default precompiled parameters, and generate SoundStreams
        /// </summary>
        /// <param name="viewer">Current <see cref="Viewer3D"/></param>
        /// <param name="worldLocation">World location of <see cref="SoundSource"/></param>
        /// <param name="eventSource">Type of game part sound source belongs to, to determine how to interpret discrete trigger numbers</param>
        /// <param name="smsFilePath">Full path for sms file</param>
        public void Initialize(in WorldLocation worldLocation, string wavFilePath, OrtsActivitySoundFileType activitySoundFileType)
        {
            this.worldLocation = worldLocation;

            if (wavFilePath == null)
                return;

            WavFolder = Path.GetDirectoryName(wavFilePath);
            WavFileName = Path.GetFileName(wavFilePath);
            SMSFolder = WavFolder;
            SMSFileName = WavFileName;

            if (viewer.UserSettings.SoundDetailLevel >= 3)
            {
                // base initializations
                ActivationConditions = new SoundActivationCondition(activitySoundFileType, ActivationType.Activate);
                DeactivationConditions = new SoundActivationCondition(activitySoundFileType, ActivationType.Deactivate);
                switch (activitySoundFileType)
                {
                    case OrtsActivitySoundFileType.Everywhere:
                        Ignore3D = true;
                        ExternalSource = true;
                        break;
                    default:
                    case OrtsActivitySoundFileType.Cab:
                    case OrtsActivitySoundFileType.Pass:
                        Ignore3D = true;
                        ExternalSource = false;
                        break;
                    case OrtsActivitySoundFileType.Ground:
                    case OrtsActivitySoundFileType.Location:
                        Ignore3D = false;
                        ExternalSource = true;
                        break;
                }
                Volume = 1.0f;
                SetRolloffFactor();

                // initialization of the only one sound stream
                SoundStreams = SoundStreams.Add(new SoundStream(WavFileName, this));
            }
        }

        private void Initialize()
        {
            this.worldLocation = WorldLocation.None;

            ActivationConditions = new SoundActivationCondition(OrtsActivitySoundFileType.Everywhere, ActivationType.Activate);
            DeactivationConditions = new SoundActivationCondition(OrtsActivitySoundFileType.Everywhere, ActivationType.Deactivate);

            Volume = 1.0f;
            SetRolloffFactor();
        }

        private void SetRolloffFactor()
        {
            float deactivationDistance = DeactivationConditions != null && DeactivationConditions.Distance != 0 ? DeactivationConditions.Distance : MaxDistance;
            float maxDistanceM = Math.Min(MaxDistance, deactivationDistance);

            // OpenAL inverse distance model is based on formula
            // Gain = AL_REFERENCE_DISTANCE / ( AL_REFERENCE_DISTANCE + AL_ROLLOFF_FACTOR * ( Distance - AL_REFERENCE_DISTANCE ) )
            RolloffFactor = slowRolloff ? 0.4f : ReferenceDistance * (1f / GainAtMaxDistance - 1f) / (maxDistanceM - ReferenceDistance);
        }

        /// <summary>
        /// Check if an event needs action from one of discrete triggers
        /// </summary>
        /// <param name="eventID">Occured event</param>
        public void HandleEvent(TrainEvent eventID)
        {
            foreach (SoundStream soundStream in SoundStreams)
            {
                foreach (SoundTrigger trigger in soundStream.Triggers)
                {
                    if (trigger is DiscreteSoundTrigger discreteTrigger)
                        discreteTrigger.OnCarSoundEvent(null, new SoundSourceEventArgs(eventID, null));
                }
            }
        }

        public override void InitInitials()
        {
            if (Car != null)
            {
                this.worldLocation = Car.WorldPosition.WorldLocation;
            }

            if (OutOfDistance())
            {
                if (!previousOutOfDistance)
                {
                    if (!viewer.Simulator.UpdaterWorking)
                    {
                        foreach (SoundStream stream in SoundStreams)
                            stream.HardDeactivate();
                        previousOutOfDistance = true;
                    }
                }
                NeedsFrequentUpdate = false;
            }
            else
            {
                if (previousOutOfDistance)
                {
                    bool ignore3D = worldLocation == WorldLocation.None | Ignore3D | !ExternalSource;
                    foreach (SoundStream stream in SoundStreams)
                    {
                        stream.HardActivate(ignore3D);

                        bool released = false;
                        // run the initial triggers
                        foreach (SoundTrigger trigger in stream.Triggers)
                        {
                            trigger.Initialize();
                            trigger.CheckTrigger();

                            released |= trigger.Signaled &&
                                (trigger.SoundCommand is ReleaseLoopSoundCommand || trigger.SoundCommand is ReleaseLoopReleaseWithJumpSoundCommand);
                            if (trigger is DiscreteSoundTrigger)
                                trigger.Signaled = false;
                        }

                        if (!released && !stream.ALSoundSource.IsPlaying)
                        {
                            foreach (SoundTrigger trigger in stream.Triggers)
                            {
                                if (trigger.Signaled && trigger.Enabled && (trigger.SoundCommand is StartLoopSoundCommand || trigger.SoundCommand is StartLoopReleaseSoundCommand))
                                    trigger.SoundCommand.Run();
                            }
                        }
                    }
                }
                previousOutOfDistance = false;
            }
        }

        public override bool Update()
        {
            if (Car != null && !Car.IsPartOfActiveTrain)
                return false;

            InitInitials();

            if (previousOutOfDistance)
            {
                // It is still needed to try out-of-distance variable triggers, to handle their start and release events, so they will be in
                // correct state when get into scope again. Discrete triggers have their HandleEvent() function to achieve this,
                // but there is no such thing for variable triggers.
                foreach (var stream in SoundStreams)
                    foreach (var trigger in stream.VariableTriggers)
                        trigger.CheckTrigger();

                return true;
            }

            if (!Active)
            {
                if (Activate())
                {
                    Active = true;

                    // restore any looping sounds
                    foreach (SoundStream stream in SoundStreams)
                        stream.Activate();
                }
            }
            else
            {
                if (DeActivate())
                {
                    foreach (SoundStream stream in SoundStreams)
                        stream.Deactivate();

                    Active = false;
                }
            }

            bool needsFrequentUpdate = false;

            if (Car == null && worldLocation != WorldLocation.None && !Ignore3D && ExternalSource)
            {
                worldLocation = worldLocation.NormalizeTo(Camera.SoundBaseTile);
                float[] position = new float[] {
                    worldLocation.Location.X,
                    worldLocation.Location.Y,
                    worldLocation.Location.Z};

                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update(position);
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            else
            {
                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update();
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            NeedsFrequentUpdate = needsFrequentUpdate;

            return true;
        } // Update

        /// <summary>
        /// Calculate current distance to camera, and compare it to <see cref="CutOffDistanceM2"/>
        /// </summary>
        /// <returns>True, if is now out-of-scope</returns>
        public bool OutOfDistance()
        {
            if (WorldLocation == WorldLocation.None)
            {
                DistanceSquared = 0;
                return false;
            }

            if (float.IsNaN(worldLocation.Location.X) ||
                float.IsNaN(worldLocation.Location.Y) ||
                float.IsNaN(worldLocation.Location.Z))
            {
                DistanceSquared = float.MaxValue;
                return true;
            }

            DistanceSquared = (float)WorldLocation.GetDistanceSquared(WorldLocation, viewer.Camera.CameraWorldLocation);

            return DistanceSquared > CutOffDistanceM2;
        }

        /// <summary>
        /// Check if activation conditions are met,
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool Activate()
        {
            if (ActivationConditions == null)
                return false;

            if (ConditionsMet(ActivationConditions))
            {
                if (WorldLocation != WorldLocation.None)
                {
                    // (ActivationConditions.Distance == 0) means distance checking disabled
                    if ((ActivationConditions.Distance == 0 || DistanceSquared < ActivationConditions.Distance * ActivationConditions.Distance) &&
                        DistanceSquared < CutOffDistanceM2)
                        return true;
                }
                else
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Check if deactivation conditions are met
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool DeActivate()
        {
            if (DeactivationConditions == null)
                return false;

            if (ConditionsMet(DeactivationConditions))
                return true;

            if (WorldLocation != WorldLocation.None)
            {
                if (DeactivationConditions.Distance != 0 && DistanceSquared > DeactivationConditions.Distance * DeactivationConditions.Distance ||
                    DistanceSquared > CutOffDistanceM2)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns true if SoundSource belongs to a cabview of a vehicle not currently watched. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool CheckCabView => (viewer.Camera.Style == CameraStyle.Cab || viewer.Camera.Style == CameraStyle.Cab3D || viewer.Camera.Style == CameraStyle.Passenger) && viewer.Camera.AttachedCar != Car;

        /// <summary>
        /// Returns true if SoundSource is a weather sound. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool WeatherSound => viewer.World.WeatherControl.IsWeatherSound(this);

        /// <summary>
        /// Hack for enabling additional cab sounds (like radio sounds) of an attached (maybe invisible) car. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        /// <returns></returns>
        private bool IsInvisibleSoundCar => !EnvironmentSound && !ExternalSource && (viewer.Camera.Style == CameraStyle.Cab || viewer.Camera.Style == CameraStyle.Cab3D)
                    && Car != null && viewer.Camera.AttachedCar != null && Car is not MSTSLocomotive && !Car.HasInsideView && Car.PassengerViewpoints == null
                    && (Car.Train == viewer.Camera.AttachedCar.Train || Car.Train.TrainType == TrainType.Static || Car.Train.TrainType == TrainType.AiNotStarted);

        /// <summary>
        /// Return true of the ViewPoint matches any of the ones specified in the conditions
        /// for activation or deactivation.
        /// </summary>
        /// <param name="conditions"></param>
        /// <returns></returns>
        private bool ConditionsMet(SoundActivationCondition conditions)
        {
            if (conditions == null)
                return false;

            CameraStyle viewpoint = viewer.Camera.Style;

            if (EnvironmentSound || !EnvironmentSound && CheckCabView && !IsInvisibleSoundCar && !WeatherSound)
            {
                viewpoint = CameraStyle.External;
            }

            if (conditions.CabCam && (viewpoint == CameraStyle.Cab || viewpoint == CameraStyle.Cab3D))
                return true;
            if (conditions.PassengerCam && viewpoint == CameraStyle.Passenger)
                return true;
            if (conditions.ExternalCam && viewpoint == CameraStyle.External)
                return true;

            return false;
        }

        // To detect redundant calls
        private bool disposedValue;
        protected override void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing && !SoundStreams.IsDefault)
                {
                    foreach (SoundStream soundStream in SoundStreams)
                        soundStream.Dispose();
                    Car = null;
                }
                disposedValue = true;
            }
            base.Dispose(disposing);
        }
    }
}

