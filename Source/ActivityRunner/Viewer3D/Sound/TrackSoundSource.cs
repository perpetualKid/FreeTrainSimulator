// COPYRIGHT 2009, 2010, 2011, 2012, 2013, 2014, 2015 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;

using FreeTrainSimulator.Common;
using FreeTrainSimulator.Common.Position;

using Orts.ActivityRunner.Viewer3D.RollingStock;
using Orts.Formats.Msts;
using Orts.Formats.Msts.Models;
using Orts.Simulation;
using Orts.Simulation.RollingStocks;
using Orts.Simulation.Track;

namespace Orts.ActivityRunner.Viewer3D.Sound
{
    public class TrackSoundSource : SoundSourceBase
    {
        private int prevTrackSoundType = -1;
        private int curTrackSoundType = -1;
        public SoundSource ActiveInSource { get; private set; }
        public SoundSource ActiveOutSource { get; private set; }
        private readonly List<SoundSource> inSources;
        private readonly List<SoundSource> outSources;

        // data to evaluate if ttype selection is needed or not
        private float nextDist = -1; // initial distance to sound region forward
        private float prevDist = -1; // initial distance to sond region backward
        private float initDist = -1; // initial distance run when last ttype selected
        private int initTrackSection = -1; // track section when last ttype selected
        private MSTSWagon initCar; // initial leading car (to accommodate in case of change of direction)
        private bool carOnSwitch;
        private bool carOnCurve;
        private readonly MSTSWagonViewer wagonViewer;

        public TrackSoundSource(MSTSWagonViewer carViewer) :
            base(carViewer)
        {
            wagonViewer = TrainCar as MSTSWagonViewer ?? throw new InvalidCastException(nameof(carViewer));
            Car = TrainCar.Car as MSTSWagon ?? throw new InvalidCastException(nameof(carViewer));
            inSources = new List<SoundSource>();
            outSources = new List<SoundSource>();

            foreach (TrackType ttdf in viewer.TrackTypes)
            {
                MSTSLocomotive loco = Car as MSTSLocomotive;

                if (!string.IsNullOrEmpty(Car.InteriorShapeFileName) || loco != null && (loco.HasFrontCab || loco.HasRearCab || loco.HasFront3DCab || loco.HasRear3DCab))
                    LoadTrackSound(ttdf.InsideSound, true);

                LoadTrackSound(ttdf.OutsideSound, false);
            }
        }

        private void LoadTrackSound(string filename, bool insideSound)
        {
            if (filename == null)
                return;

            ImmutableArray<string> pathArray = ImmutableArray.Create(
                viewer.Simulator.RouteFolder.SoundFolder, viewer.Simulator.RouteFolder.ContentFolder.SoundFolder);
            string fullPath = FolderStructure.FindFileFromFolders(pathArray, filename);
            if (fullPath == null)
            {
                Trace.TraceWarning("Skipped missing track sound {0}", filename);
                return;
            }
            if (insideSound)
                inSources.Add(new SoundSource(Car, TrainCar, fullPath));
            else
                outSources.Add(new SoundSource(Car, TrainCar, fullPath));
        }

        public override void Uninitialize()
        {
            ActiveInSource?.Uninitialize();
            ActiveOutSource?.Uninitialize();
        }

        public override void InitInitials()
        {
            if (inSources != null && inSources.Count > 0)
                ActiveInSource = inSources[0];

            if (outSources != null && outSources.Count > 0)
                ActiveOutSource = outSources[0];

            curTrackSoundType = 0;
            prevTrackSoundType = 0;
        }

        public void UpdateTType(bool stateChange)
        {
            if (prevTrackSoundType == -1)
            {
                InitInitials();
            }

            if (Car != null && Car.Train != null)
            {
                int carIncrement;
                int carLeading;
                if (Car.Train.SpeedMpS > 0.1f)
                {
                    carIncrement = 1;
                    carLeading = 0;
                }
                else if (Car.Train.SpeedMpS < -0.1f)
                {
                    carIncrement = -1;
                    carLeading = Car.Train.Cars.Count - 1;
                }
                else
                    return;

                int carIndex = Car.Train.Cars.IndexOf(Car);

                if (carIndex == carLeading)
                {
                    bool reSelect = stateChange;
                    if (!reSelect)
                    {
                        if (nextDist == -1 || initCar != Car.Train.Cars[carLeading] ||
                            carLeading == 0 && Car.Train.PresentPosition[Direction.Forward].TrackCircuitSectionIndex != initTrackSection ||
                            carLeading != 0 && Car.Train.PresentPosition[Direction.Backward].TrackCircuitSectionIndex != initTrackSection ||
                            carLeading == 0 && (Car.Train.DistanceTravelledM - initDist > nextDist || initDist - Car.Train.DistanceTravelledM > prevDist) ||
                            carLeading != 0 && (Car.Train.DistanceTravelledM - Car.Train.Length - initDist > nextDist || initDist - Car.Train.DistanceTravelledM + Car.Train.Length > prevDist))
                        {
                            reSelect = true;
                        }
                    }
                    if (reSelect)
                    {
                        initCar = Car;
                        initTrackSection = carLeading == 0 ? Car.Train.PresentPosition[Direction.Forward].TrackCircuitSectionIndex : Car.Train.PresentPosition[Direction.Backward].TrackCircuitSectionIndex;
                        initDist = carLeading == 0 ? Car.Train.DistanceTravelledM : Car.Train.DistanceTravelledM - Car.Train.Length;
                        wagonViewer.TrackSoundType = viewer.World.Sounds.GetTType(Car.Train, out prevDist, out nextDist);
                        if (wagonViewer.TrackSoundType != int.MaxValue)
                            if (wagonViewer.TrackSoundType < viewer.TrackTypes.Count)
                                curTrackSoundType = wagonViewer.TrackSoundType;
                            else
                            {
                                // Track type out of range
                                curTrackSoundType = 0;
                                Trace.TraceWarning("Sound region {0} out of range in tile {1}", wagonViewer.TrackSoundType,
                                    Car.WorldPosition.WorldLocation.Tile);
                                wagonViewer.TrackSoundType = 0;
                            }
                        else
                            if (!SharedSMSFileManager.AutoTrackSound || 
                                curTrackSoundType != SharedSMSFileManager.SwitchSmsNumber &&
                                curTrackSoundType != SharedSMSFileManager.CurveSmsNumber &&
                                curTrackSoundType != SharedSMSFileManager.CurveSwitchSmsNumber)
                            wagonViewer.TrackSoundType = curTrackSoundType;
                        else
                        {
                            wagonViewer.TrackSoundType = 0;
                            curTrackSoundType = 0;
                        }
                    }
                    else
                        wagonViewer.TrackSoundType = curTrackSoundType;
                }
                else
                {
                    if (viewer.World.Trains.Cars.TryGetValue(Car.Train.Cars[carIndex - carIncrement], out TrainCarViewer carAhead) && carAhead.TrackSoundLocation != WorldLocation.None)
                    {
                        if ((curTrackSoundType == wagonViewer.TrackSoundType || stateChange) && wagonViewer.TrackSoundType != carAhead.TrackSoundType)
                        {
                            wagonViewer.TrackSoundType = carAhead.TrackSoundType;
                            wagonViewer.TrackSoundLocation = carAhead.TrackSoundLocation;
                            wagonViewer.TrackSoundDistSquared = (float)WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, wagonViewer.TrackSoundLocation);
                            if (stateChange)
                            {
                                curTrackSoundType = wagonViewer.TrackSoundType;
                            }
                        }

                        if (wagonViewer.TrackSoundLocation != WorldLocation.None)
                        {
                            float trackSoundDistSquared = (float)WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, wagonViewer.TrackSoundLocation);
                            if (trackSoundDistSquared > 9 && trackSoundDistSquared - 2 <= wagonViewer.TrackSoundDistSquared)
                                wagonViewer.TrackSoundDistSquared = trackSoundDistSquared;
                            else
                            {
                                curTrackSoundType = wagonViewer.TrackSoundType;
                            }
                        }
                    }
                }

                if (curTrackSoundType != prevTrackSoundType)
                {
                    if (ActiveInSource != null)
                    {
                        ActiveInSource.Uninitialize();
                        if (0 <= curTrackSoundType && curTrackSoundType < inSources.Count)
                            ActiveInSource = inSources[curTrackSoundType];
                        else
                            Trace.TraceWarning("Could not change inside sound region to {0}", curTrackSoundType);
                    }

                    if (ActiveOutSource != null)
                    {
                        ActiveOutSource.Uninitialize();
                        if (0 <= curTrackSoundType && curTrackSoundType < outSources.Count)
                            ActiveOutSource = outSources[curTrackSoundType];
                        else
                            Trace.TraceWarning("Could not change outside sound region to {0}", curTrackSoundType);
                    }
                    if (carIndex == carLeading)
                        wagonViewer.TrackSoundLocation = Car.WorldPosition.WorldLocation;
                    prevTrackSoundType = curTrackSoundType;
                }
            }
        }

        public override bool Update()
        {
            bool stateChange = false;
            if (SharedSMSFileManager.AutoTrackSound)
                stateChange = UpdateCarOnSwitchAndCurve();
            if (!carOnSwitch && !carOnCurve || !SharedSMSFileManager.AutoTrackSound)
                UpdateTType(stateChange);
            bool retval = true;
            NeedsFrequentUpdate = false;

            if (ActiveInSource != null)
            {
                retval &= ActiveInSource.Update();
                NeedsFrequentUpdate |= ActiveInSource.NeedsFrequentUpdate;
            }

            if (ActiveOutSource != null)
            {
                retval &= ActiveOutSource.Update();
                NeedsFrequentUpdate |= ActiveOutSource.NeedsFrequentUpdate;
            }

            return retval;
        }

        // To detect redundant calls
        private bool disposedValue;
        protected override void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    foreach (SoundSource soundSource in inSources ?? Enumerable.Empty<SoundSource>())
                        soundSource.Dispose();
                    inSources.Clear();
                    foreach (SoundSource s in outSources ?? Enumerable.Empty<SoundSource>())
                        s.Dispose();
                    outSources.Clear();
                    Car = null;
                }
                disposedValue = true;
            }
            base.Dispose(disposing);
        }

        //Checks whether car on switch or on curve or both and selects related .sms file;
        // returns true if state has changed
        public bool UpdateCarOnSwitchAndCurve()
        {
            bool stateChange = false;
            if (Car?.Train != null)
            {
                if (Car.Train.SpeedMpS > 0.1f || Car.Train.SpeedMpS < -0.1f)
                {
                    int carNo = Car.Train.Cars.IndexOf(Car);
                    int carIncrement = 0;
                    if (Car.Train.SpeedMpS > 0.1f && carNo != Car.Train.Cars.Count - 1)
                        carIncrement = 1;
                    if (Car.Train.SpeedMpS < 0.1f && carNo != 0)
                        carIncrement = -1;

                    TrainCar CarBehind = Car.Train.Cars[carNo + carIncrement];
                    bool carPreviouslyOnSwitch = carOnSwitch;
                    carOnSwitch = false;
                    if (Car.Train.PresentPosition[Direction.Forward].TrackCircuitSectionIndex != Car.Train.PresentPosition[Direction.Backward].TrackCircuitSectionIndex)
                    {
                        foreach (TrackCircuitSection section in Car.Train.OccupiedTrack)
                        {
                            if (section.CircuitType == TrackCircuitType.Junction || section.CircuitType == TrackCircuitType.Crossover)
                            {
                                // train is on a switch; let's see if car is on a switch too
                                WorldLocation switchLocation = RuntimeData.Instance.TrackDB.TrackNodes[section.OriginalIndex].UiD.Location;
                                var distanceFromSwitch = WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, switchLocation);
                                if (distanceFromSwitch < Car.CarLengthM * Car.CarLengthM + Math.Min(Car.SpeedMpS * 3, 150))
                                {
                                    carOnSwitch = true;
                                    break;
                                }
                            }
                        }
                    }
                    // here check for curve
                    bool carPreviouslyOnCurve = carOnCurve;
                    carOnCurve = false;
                    if (Car.CurrentCurveRadius > 0 && (Car.CurrentCurveRadius < 301
                         || Car.CurrentCurveRadius < 350 && Car.WagonType == WagonType.Freight) ||
                        CarBehind.CurrentCurveRadius > 0 && (CarBehind.CurrentCurveRadius < 301
                         || CarBehind.CurrentCurveRadius < 350 && Car.WagonType == WagonType.Freight))
                    {
                        carOnCurve = true;
                    }

                    // resume results and select sound if change
                    if (carPreviouslyOnSwitch ^ carOnSwitch || carPreviouslyOnCurve ^ carOnCurve)
                    {
                        stateChange = true;
                    }
                    if (stateChange && (carOnSwitch || carOnCurve))
                    {
                        wagonViewer.TrackSoundLocation = Car.WorldPosition.WorldLocation;
                        if (carOnSwitch && carOnCurve && SharedSMSFileManager.CurveSwitchSmsNumber != -1)
                        {
                            curTrackSoundType = SharedSMSFileManager.CurveSwitchSmsNumber;
                        }
                        else if (carOnCurve && SharedSMSFileManager.CurveSmsNumber != -1)
                        {
                            curTrackSoundType = SharedSMSFileManager.CurveSmsNumber;
                        }
                        else if (carOnSwitch && SharedSMSFileManager.SwitchSmsNumber != -1)
                        // car on switch
                        {
                            curTrackSoundType = SharedSMSFileManager.SwitchSmsNumber;
                        }
                        else
                            stateChange = false;
                    }
                }
                else
                    return stateChange;

                if (curTrackSoundType != prevTrackSoundType)
                {
                    if (ActiveInSource != null)
                    {
                        ActiveInSource.Uninitialize();
                        ActiveInSource = inSources[curTrackSoundType];
                        if (0 <= curTrackSoundType && curTrackSoundType < inSources.Count)
                            ActiveInSource = inSources[curTrackSoundType];
                        else
                            Trace.TraceWarning("Could not change inside sound region to {0}", curTrackSoundType);
                    }

                    if (ActiveOutSource != null)
                    {
                        ActiveOutSource.Uninitialize();
                        ActiveOutSource = outSources[curTrackSoundType];
                        if (0 <= curTrackSoundType && curTrackSoundType < outSources.Count)
                            ActiveInSource = inSources[curTrackSoundType];
                        else
                            Trace.TraceWarning("Could not change outside sound region to {0}", curTrackSoundType);
                    }
                    prevTrackSoundType = curTrackSoundType;
                }
            }
            return stateChange;
        }
    }
}

