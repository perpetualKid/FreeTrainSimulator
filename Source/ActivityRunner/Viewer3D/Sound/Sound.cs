// COPYRIGHT 2009, 2010, 2011, 2012, 2013, 2014, 2015 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

//#define DEBUGSCR

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;

using FreeTrainSimulator.Common;
using FreeTrainSimulator.Common.Calc;
using FreeTrainSimulator.Common.Position;

using Orts.Formats.Msts;
using Orts.Formats.Msts.Files;
using Orts.Formats.Msts.Models;
using Orts.Simulation;
using Orts.Simulation.RollingStocks;

namespace Orts.ActivityRunner.Viewer3D.Sound
{

    /// <summary>
    /// Utility class to avoid loading multiple copies of the same file.
    /// </summary>
    public static class SharedSMSFileManager
    {
        private static readonly Dictionary<string, SoundManagmentFile> sharedSMSFiles = new Dictionary<string, SoundManagmentFile>();

        public static int SwitchSmsNumber { get; private set; }
        public static int CurveSmsNumber { get; private set; }
        public static int CurveSwitchSmsNumber { get; private set; }
        public static bool AutoTrackSound { get; private set; }

        public static SoundManagmentFile Get(string path)
        {
            if (!sharedSMSFiles.TryGetValue(path, out SoundManagmentFile value))
            {
                SoundManagmentFile smsFile = new SoundManagmentFile(path);
                value = smsFile;
                sharedSMSFiles.Add(path, value);
            }
            return value;
        }

        public static void Initialize(int trackTypesNumber)
        {
            if (Simulator.Instance.RouteModel.Settings.TryGetValue("CurveSound", out string settingValue) &&
                int.TryParse(settingValue, out int curveSmsNumber))
                CurveSmsNumber = curveSmsNumber;

            if (Simulator.Instance.RouteModel.Settings.TryGetValue("CurveSwitchSound", out settingValue) &&
                int.TryParse(settingValue, out int curveSwitchSmsNumber))
                CurveSwitchSmsNumber = curveSwitchSmsNumber;

            if (Simulator.Instance.RouteModel.Settings.TryGetValue("SwitchSound", out settingValue) &&
                int.TryParse(settingValue, out int switchSmsNumber))
                SwitchSmsNumber = switchSmsNumber;

            if (SwitchSmsNumber < -1 || SwitchSmsNumber >= trackTypesNumber)
            {
                SwitchSmsNumber = -1;
                Trace.TraceInformation("Switch SMS Number out of range");
            }
            if (SwitchSmsNumber != -1)
                AutoTrackSound = true;

            if (CurveSmsNumber < -1 || CurveSmsNumber >= trackTypesNumber)
            {
                CurveSmsNumber = -1;
                Trace.TraceInformation("Curve SMS Number out of range");
            }
            if (CurveSmsNumber != -1)
                AutoTrackSound = true;

            if (CurveSwitchSmsNumber < -1 || CurveSwitchSmsNumber >= trackTypesNumber)
            {
                CurveSwitchSmsNumber = CurveSmsNumber;
                Trace.TraceInformation("CurveSwitch SMS Number out of range, replaced with curve SMS number");
            }
            if (CurveSwitchSmsNumber != -1)
                AutoTrackSound = true;
        }
    }

    /////////////////////////////////////////////////////////
    // SOUND TRIGGERS
    /////////////////////////////////////////////////////////

    /// <summary>
    /// Trigger is defined in the SMS file as members of a SoundStream.
    /// They are activated by various events.
    /// When triggered, executes a SoundCommand
    /// </summary>
    public class ORTSTrigger
    {
        /// <summary>
        /// Set by the DisableTrigger, EnableTrigger sound commands
        /// </summary>
        public bool Enabled = true;
        /// <summary>
        /// True if trigger activation conditions are met
        /// </summary>
        public bool Signaled;
        /// <summary>
        /// Represents a sound command to be executed, when trigger is activated
        /// </summary>
        public ORTSSoundCommand SoundCommand;

        /// <summary>
        /// Check in every update loop whether to activate the trigger
        /// </summary>
        public virtual void TryTrigger() { }
        /// <summary>
        /// Executed in constructors, or when sound source gets into scope, or for InitialTrigger when other VariableTriggers stop working
        /// </summary>
        public virtual void Initialize() { }
    }


    /// <summary>
    /// Play this sound when a discrete TrainCar event occurs in the simulator
    /// </summary>
    public class ORTSDiscreteTrigger : ORTSTrigger
    {
        /// <summary>
        /// Event this trigger listens to
        /// </summary>
        public TrainEvent TriggerID;
        /// <summary>
        /// Store the owning SoundStream
        /// </summary>
        private SoundStream SoundStream;
        /// <summary>
        /// This flag is set by Updater process, and is used by Sound process to activate the trigger
        /// </summary>
        private bool Triggered;

        public ORTSDiscreteTrigger(SoundStream soundStream, SoundEventSource eventSound, DiscreteTrigger smsData)
        {
            TriggerID = SoundEvent.From(eventSound, smsData.TriggerId);
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        /// <summary>
        /// Construct a discrete sound trigger with an arbitrary event trigger and sound command.
        /// </summary>
        /// <param name="soundStream">The parent sound stream.</param>
        /// <param name="triggerID">The trigger to activate this event.</param>
        /// <param name="soundCommand">The command to run when activated.</param>
        public ORTSDiscreteTrigger(SoundStream soundStream, TrainEvent triggerID, ORTSSoundCommand soundCommand)
        {
            TriggerID = triggerID;
            SoundCommand = soundCommand;
            SoundStream = soundStream;
        }

        /// <summary>
        /// Check if this trigger listens to an event, and if also belongs to the object
        /// </summary>
        /// <param name="trainEvent">Occured event</param>
        /// <param name="viewer">Object the event belongs to</param>
        internal void OnCarSoundEvent(object sender, SoundSourceEventArgs e)
        {
            if (e.SoundEvent == TriggerID)
            {
                Triggered = e.Owner == null || Program.Viewer.SoundProcess.IsSoundSourceOwnedBy(e.Owner, SoundStream.SoundSource);
            }
        }

        public override void TryTrigger()
        {
            Triggered &= Enabled;
            if (Triggered)
            {
                Triggered = false;
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
                Signaled = true;
#if DEBUGSCR
                if (SoundCommand is ORTSSoundPlayCommand && !string.IsNullOrEmpty((SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]))
                    Trace.WriteLine("({0})DiscreteTrigger: {1}:{2}", SoundStream.ALSoundSource.SoundSourceID, TriggerID, (SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]);
                else
                    Trace.WriteLine("({0})DiscreteTrigger: {1}", SoundStream.ALSoundSource.SoundSourceID, TriggerID);
#endif
            }
            // If the SoundSource is not active, should deactivate the SoundStream also
            //   preventing the hearing when not should be audible
            if (!SoundStream.SoundSource.Active)
                SoundStream.Deactivate();
        }

    } // class ORTSDiscreteTrigger

    /// <summary>
    /// Play this sound controlled by the distance a TrainCar has travelled
    /// </summary>
    public sealed class ORTSDistanceTravelledTrigger : ORTSTrigger
    {
        private DistanceTravelledTrigger SMS;
        private float triggerDistance;
        private TrainCar car;
        private SoundStream SoundStream;

        public ORTSDistanceTravelledTrigger(SoundStream soundStream, DistanceTravelledTrigger smsData)
        {
            SoundStream = soundStream;
            car = soundStream.SoundSource.Car;
            SMS = smsData;
            SoundCommand = ORTSSoundCommand.FromMSTS(SMS.SoundCommand, soundStream);
            Initialize();
        }

        public override void Initialize()
        {
            UpdateTriggerDistance();
        }

        public override void TryTrigger()
        {
            if (car.DistanceTravelled > triggerDistance)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)StaticRandom.NextDouble() * (SMS.MaximumVolume - SMS.MinimumVolume) + SMS.MinimumVolume;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerDistance();
#if DEBUGSCR
                Trace.WriteLine("({0})DistanceTravelledTrigger: Current:{1}, Next:{2}", SoundStream.ALSoundSource.SoundSourceID, car.DistanceM, triggerDistance);
#endif

            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate a new random distance to travel till the next trigger action
        /// </summary>
        private void UpdateTriggerDistance()
        {
            if (SMS.MaximumDistance != SMS.MinimumDistance)
            {
                triggerDistance = car.DistanceTravelled + ((float)StaticRandom.NextDouble() * (SMS.MaximumDistance - SMS.MinimumDistance) + SMS.MinimumDistance);
            }
            else
            {
                triggerDistance = car.DistanceTravelled + ((float)StaticRandom.NextDouble() * SMS.MinimumDistance + SMS.MinimumDistance);
            }
        }

    } // class ORTSDistanceTravelledTrigger

    /// <summary>
    /// Play this sound immediately when this SoundSource becomes active, or in case no other VariableTriggers are active
    /// </summary>
    public class ORTSInitialTrigger : ORTSTrigger
    {
        private SoundStream SoundStream;

        public ORTSInitialTrigger(SoundStream soundStream, InitialTrigger smsData)
        {
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        // For pre-compiled activity sound
        public ORTSInitialTrigger(SoundStream soundStream, string wavFileName)
        {
            SoundCommand = ORTSSoundCommand.Precompiled(wavFileName, soundStream);
            SoundStream = soundStream;
        }

        public override void Initialize()
        {
            if (Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
#if DEBUGSCR
                if (SoundCommand is ORTSSoundPlayCommand && !string.IsNullOrEmpty((SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]))
                    Trace.WriteLine("({0})InitialTrigger: {1}", SoundStream.ALSoundSource.SoundSourceID, (SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]);
#endif
            }

            Signaled = true;
        }

    }

    /// <summary>
    /// Play the sound at random times
    /// </summary>
    public sealed class ORTSRandomTrigger : ORTSTrigger
    {
        private RandomTrigger SMS;
        private double triggerAtSeconds;
        private SoundStream SoundStream;

        public ORTSRandomTrigger(SoundStream soundStream, RandomTrigger smsData)
        {
            SoundStream = soundStream;
            SMS = smsData;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void Initialize()
        {
            UpdateTriggerAtSeconds();
        }

        public override void TryTrigger()
        {
            if (Simulator.Instance.ClockTime > triggerAtSeconds)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)StaticRandom.NextDouble() * (SMS.MaximumVolume - SMS.MinimumVolume) + SMS.MinimumVolume;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerAtSeconds();
            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate new random time till the next triggering action
        /// </summary>
        private void UpdateTriggerAtSeconds()
        {
            double interval = StaticRandom.NextDouble() * (SMS.MaximumDelay - SMS.MinimumDelay) + SMS.MinimumDelay;
            triggerAtSeconds = Simulator.Instance.ClockTime + interval;
        }

    }  // class RandomTrigger

    /// <summary>
    /// Control sounds based on TrainCar variables in the simulator 
    /// </summary>
    public sealed class ORTSVariableTrigger : ORTSTrigger
    {
        private VariableTrigger SMS;
        private MSTSWagon car;
        private SoundStream SoundStream;
        private float StartValue;
        public bool IsBellow;

        public ORTSVariableTrigger(SoundStream soundStream, VariableTrigger smsData)
        {
            SMS = smsData;
            car = soundStream.SoundSource.Car ?? (MSTSWagon)Program.Viewer.Camera.AttachedCar;
            SoundStream = soundStream;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void Initialize()
        {
            StartValue = SMS.Event == VariableTrigger.TriggerEvent.DistanceDecrease ? float.MaxValue : 0;

            /*if ((new Variable_Trigger.Events[] { Variable_Trigger.Events.Variable1_Dec_Past,
                Variable_Trigger.Events.Variable1_Inc_Past, Variable_Trigger.Events.Variable2_Dec_Past, 
                Variable_Trigger.Events.Variable2_Inc_Past, Variable_Trigger.Events.Variable3_Dec_Past,
                Variable_Trigger.Events.Variable3_Inc_Past}).Contains(SMS.Event) && SMS.Threshold >= 1)
            {
                SMS.Threshold /= 100f;
            }*/
            IsBellow = StartValue < SMS.Threshold;
        }

        public override void TryTrigger()
        {
            float newValue = ReadValue();
            bool triggered = false;
            Signaled = false;

            switch (SMS.Event)
            {
                case VariableTrigger.TriggerEvent.DistanceDecrease:
                case VariableTrigger.TriggerEvent.SpeedDecrease:
                case VariableTrigger.TriggerEvent.Variable1Decrease:
                case VariableTrigger.TriggerEvent.Variable2Decrease:
                case VariableTrigger.TriggerEvent.Variable3Decrease:
                case VariableTrigger.TriggerEvent.BrakeCylinderDecrease:
                case VariableTrigger.TriggerEvent.CurveForceDecrease:
                    if (newValue < SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold <= StartValue)
                            triggered = true;
                    }
                    break;
                case VariableTrigger.TriggerEvent.DistanceIncrease:
                case VariableTrigger.TriggerEvent.SpeedIncrease:
                case VariableTrigger.TriggerEvent.Variable1Increase:
                case VariableTrigger.TriggerEvent.Variable2Increase:
                case VariableTrigger.TriggerEvent.Variable3Increase:
                case VariableTrigger.TriggerEvent.BrakeCylinderIncrease:
                case VariableTrigger.TriggerEvent.CurveForceIncrease:
                    if (newValue > SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold >= StartValue)
                            triggered = true;
                    }
                    break;
            }

            //Signaled = triggered;

            StartValue = newValue;
            IsBellow = newValue < SMS.Threshold;

            if (triggered && Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;

#if DEBUGSCR
                ORTSStartLoop sl = SoundCommand as ORTSStartLoop;
                if (sl != null)
                {
                    Trace.WriteLine("({0})StartLoop ({1} {2}): {3} ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString(), sl.Files[sl.iFile]);
                }
                ORTSStartLoopRelease slr = SoundCommand as ORTSStartLoopRelease;
                if (slr != null)
                {
                    Trace.WriteLine("({0})StartLoopRelease ({1} {2}): {3} ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString(), slr.Files[slr.iFile]);
                }
                ORTSReleaseLoopRelease rlr = SoundCommand as ORTSReleaseLoopRelease;
                if (rlr != null)
                {
                    Trace.WriteLine("({0})ReleaseLoopRelease ({1} {2}) ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString());
                }
                ORTSReleaseLoopReleaseWithJump rlrwj = SoundCommand as ORTSReleaseLoopReleaseWithJump;
                if (rlrwj != null)
                {
                    Trace.WriteLine("({0})ReleaseLoopReleaseWithJump ({1} {2}) ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString());
                }
#endif
            }
        }

        /// <summary>
        /// Read the desired variable either from the attached TrainCar, or the distance to sound source
        /// </summary>
        /// <returns></returns>
        private float ReadValue()
        {
            switch (SMS.Event)
            {
                case VariableTrigger.TriggerEvent.DistanceDecrease:
                case VariableTrigger.TriggerEvent.DistanceIncrease:
                    return SoundStream.SoundSource.DistanceSquared;
                case VariableTrigger.TriggerEvent.SpeedDecrease:
                case VariableTrigger.TriggerEvent.SpeedIncrease:
                    return car.AbsSpeedMpS;
                case VariableTrigger.TriggerEvent.Variable1Decrease:
                case VariableTrigger.TriggerEvent.Variable1Increase:
                    return car.SoundValues.X;
                case VariableTrigger.TriggerEvent.Variable2Decrease:
                case VariableTrigger.TriggerEvent.Variable2Increase:
                    return car.SoundValues.Y;
                case VariableTrigger.TriggerEvent.Variable3Decrease:
                case VariableTrigger.TriggerEvent.Variable3Increase:
                    return car.SoundValues.Z;
                case VariableTrigger.TriggerEvent.BrakeCylinderDecrease:
                case VariableTrigger.TriggerEvent.BrakeCylinderIncrease:
                    return car.BrakeSystem.GetCylPressurePSI();
                case VariableTrigger.TriggerEvent.CurveForceDecrease:
                case VariableTrigger.TriggerEvent.CurveForceIncrease:
                    return (float)car.CurveForceFiltered;
                default:
                    return 0;
            }
        }

    }  // class VariableTrigger


    /////////////////////////////////////////////////////////
    // SOUND COMMANDS
    /////////////////////////////////////////////////////////


    /// <summary>
    /// Start playing the whole sound stream once, then stop
    /// </summary>
    public class ORTSPlayOneShot : ORTSSoundPlayCommand
    {
        public ORTSPlayOneShot(SoundStream ortsStream, SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream, mstsSoundPlayCommand)
        {
        }
        // precompiled version for activity sounds
        public ORTSPlayOneShot(SoundStream ortsStream, string wavFileName)
            : base(ortsStream, wavFileName)
        {
        }

        public override void Run()
        {
            string p = GetNextFile();
            if (!string.IsNullOrEmpty(p))
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.OneShot, ORTSStream.SoundSource.ExternalSource, ORTSStream.RepeatedTrigger);
            }
        }
    }

    /// <summary>
    /// Start looping the whole stream, release it only at the end
    /// </summary>
    public class ORTSStartLoop : ORTSSoundPlayCommand
    {
        public ORTSStartLoop(SoundStream ortsStream, SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream, mstsSoundPlayCommand)
        {
        }
        public override void Run()
        {
            // Support for Loop functions - by GeorgeS
            string p = GetNextFile();
            if (!string.IsNullOrEmpty(p))
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.Loop, ORTSStream.SoundSource.ExternalSource, false);
            }
        }
    }

    /// <summary>
    /// Release the sound by playing the looped sustain part till its end, then play the last part
    /// </summary>
    public class ORTSReleaseLoopRelease : ORTSSoundCommand
    {
        public ORTSReleaseLoopRelease(SoundStream ortsStream)
            : base(ortsStream)
        {
        }

        public override void Run()
        {
            if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                ORTSStream.ALSoundSource.Queue("", PlayMode.Release, ORTSStream.SoundSource.ExternalSource, false);
        }
    }

    /// <summary>
    /// Start by playing the first part, then start looping the sustain part of the stream
    /// </summary>
    public class ORTSStartLoopRelease : ORTSSoundPlayCommand
    {
        public ORTSStartLoopRelease(SoundStream ortsStream, SoundPlayCommand mstsStartLoopRelease)
            : base(ortsStream, mstsStartLoopRelease)
        {
        }

        // Support for Loop functions - by GeorgeS
        public override void Run()
        {
            string p = GetNextFile();
            if (!string.IsNullOrEmpty(p))
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.LoopRelease, ORTSStream.SoundSource.ExternalSource, ORTSStream.IsReleasedWithJump);
            }
        }
    }

    /// <summary>
    /// Release the sound by playing the looped sustain part till the next cue point, then jump to the last part and play that  
    /// </summary>
    public class ORTSReleaseLoopReleaseWithJump : ORTSSoundCommand
    {
        public ORTSReleaseLoopReleaseWithJump(SoundStream ortsStream)
            : base(ortsStream)
        {
        }

        public override void Run()
        {
            if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                ORTSStream.ALSoundSource.Queue("", PlayMode.ReleaseWithJump, ORTSStream.SoundSource.ExternalSource, true);
        }
    }

    /// <summary>
    /// Shut down this stream trigger 
    /// </summary>
    public class ORTSDisableTrigger : ORTSSoundCommand
    {
        private int TriggerIndex;  // index into the stream's trigger list 

        public ORTSDisableTrigger(SoundStream ortsStream, TriggerCommand smsData)
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerId - 1;
        }

        public override void Run()
        {
            if (TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Length)
                ORTSStream.Triggers[TriggerIndex].Enabled = false;
        }
    }

    /// <summary>
    /// Re-enable this stream trigger
    /// </summary>
    public class ORTSEnableTrigger : ORTSSoundCommand
    {
        private int TriggerIndex;

        public ORTSEnableTrigger(SoundStream ortsStream, TriggerCommand smsData)
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerId - 1;
        }

        public override void Run()
        {
            if (TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Length)
                ORTSStream.Triggers[TriggerIndex].Enabled = true;
        }
    }

    /// <summary>
    /// Set Volume of Stream
    /// </summary>
    public class ORTSSetStreamVolume : ORTSSoundCommand
    {
        private float Volume;

        public ORTSSetStreamVolume(SoundStream ortsStream, StreamVolumeCommand smsData)
            : base(ortsStream)
        {
            Volume = smsData.Volume;
        }

        public override void Run()
        {
            ORTSStream.Volume = Volume;
        }
    }

    /// <summary>
    /// Used when the SMS file sound command is missing or malformed
    /// </summary>
    public class ORTSNoOp : ORTSSoundCommand
    {
        public ORTSNoOp()
            : base(null)
        {
        }
        public override void Run()
        {
        }
    }

    /// <summary>
    /// A base class for all sound commands
    /// Defines that they all have a stream and a 'Run()' function
    /// </summary>
    public abstract class ORTSSoundCommand
    {
        /// <summary>
        /// The Stream in .sms file it belongs to
        /// </summary>
        protected SoundStream ORTSStream;

        protected ORTSSoundCommand(SoundStream ortsStream)
        {
            ORTSStream = ortsStream;
        }

        /// <summary>
        /// Put the command into stream's queue, or set its volume, or enable/disable other commands
        /// </summary>
        public abstract void Run();


        /// <summary>
        /// Create a sound command based on the sound command variable of a trigger in an SMS file.
        /// </summary>
        /// <param name="mstsSoundCommand"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand FromMSTS(SoundCommand mstsSoundCommand, SoundStream soundStream)
        {
            if (mstsSoundCommand == null)
            {
                return new ORTSNoOp();
            }
            else if (mstsSoundCommand is SoundPlayCommand playCommand)
            {
                switch (playCommand.CommandType)
                {
                    case SoundPlayCommand.SoundCommandType.PlayOneShot:
                        return new ORTSPlayOneShot(soundStream, playCommand);
                    case SoundPlayCommand.SoundCommandType.StartLoop:
                        return new ORTSStartLoop(soundStream, playCommand);
                    case SoundPlayCommand.SoundCommandType.StartLoopRelease:
                        return new ORTSStartLoopRelease(soundStream, playCommand);
                }
            }
            else if (mstsSoundCommand is LoopRelease releaseCommand)
            {
                switch (releaseCommand.ReleaseMode)
                {
                    case LoopRelease.ReleaseType.Release:
                        return new ORTSReleaseLoopRelease(soundStream);
                    case LoopRelease.ReleaseType.ReleaseWithJump:
                        return new ORTSReleaseLoopReleaseWithJump(soundStream);
                }
            }
            else if (mstsSoundCommand is StreamVolumeCommand)
            {
                return new ORTSSetStreamVolume(soundStream, (StreamVolumeCommand)mstsSoundCommand);
            }
            else if (mstsSoundCommand is TriggerCommand triggerCommand)
            {
                switch (triggerCommand.Trigger)
                {
                    case TriggerCommand.TriggerType.Disable:
                        return new ORTSDisableTrigger(soundStream, triggerCommand);
                    case TriggerCommand.TriggerType.Enable:
                        return new ORTSEnableTrigger(soundStream, triggerCommand);
                }
            }
            throw new ArgumentException("Unexpected soundCommand type " + mstsSoundCommand.GetType().ToString() + " in " + soundStream.SoundSource.SMSFolder, nameof(mstsSoundCommand));
        }


        /// <summary>
        /// Create a pre-compiled sound command for activity files.
        /// </summary>
        /// <param name="wavFilePath"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand Precompiled(string wavFileName, SoundStream soundStream)
        {
            return new ORTSPlayOneShot(soundStream, wavFileName);
        }

    }// ORTSSoundCommand


    /// <summary>
    /// A base class for commands that play a sound.
    /// Provides for selecting the sound from multiple files
    /// using a random or sequential selection strategy.
    /// </summary>
    public abstract class ORTSSoundPlayCommand : ORTSSoundCommand
    {
        /// <summary>
        /// File names to select from for playing
        /// </summary>
        public IList<string> Files { get; private set; }
        /// <summary>
        /// How to select from available files
        /// </summary>
        private readonly SoundPlayCommand.Selection selectionMethod;
        /// <summary>
        /// Index of the file to play inside <see cref="Files"/> vector
        /// </summary>
        private int fileIndex;

        protected ORTSSoundPlayCommand(SoundStream ortsStream, SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream)
        {
            Files = mstsSoundPlayCommand?.Files;
            selectionMethod = mstsSoundPlayCommand.SelectionMethod;
        }

        // precompiled version for activity sounds
        protected ORTSSoundPlayCommand(SoundStream ortsStream, string wavFileName)
            : base(ortsStream)
        {
            Files = new List<string>() { wavFileName };
            selectionMethod = SoundPlayCommand.Selection.Sequential;
        }

        /// <summary>
        /// Select a file from the Files list using the SelectionMethod
        /// </summary>
        /// <returns>File name with full path </returns>
        protected string GetNextFile()
        {
            if (selectionMethod == SoundPlayCommand.Selection.Sequential)
            {
                ++fileIndex;
                if (fileIndex >= Files.Count)
                    fileIndex = 0;
            }
            else if (selectionMethod == SoundPlayCommand.Selection.Random)
            {
                fileIndex = StaticRandom.Next(Files.Count);
            }

            ImmutableArray<string> pathArray = ImmutableArray.Create(
                Simulator.Instance.RouteFolder.SoundFolder,
                ORTSStream.SoundSource.SMSFolder,
                Simulator.Instance.RouteFolder.ContentFolder.SoundFolder);
            return FolderStructure.FindFileFromFolders(pathArray, Files[fileIndex]) ?? string.Empty;
        }
    }

    public class WorldSounds
    {
        private readonly Dictionary<string, IList<WorldSoundRegion>> soundRegions = new Dictionary<string, IList<WorldSoundRegion>>();
        private readonly Viewer viewer;
        private SoundSource soundSource;

        public WorldSounds(Viewer viewer)
        {
            this.viewer = viewer;
        }

        public int GetTType(Simulation.Physics.Train train, out float outPrevDist, out float outNextDist)
        {
            int retval = 0;
            Traveller traveller;
            Traveller tmp;
            outPrevDist = -1;
            outNextDist = -1;

            if (train.SpeedMpS >= 0)
            {
                traveller = new Traveller(train.FrontTDBTraveller);
            }
            else
            {
                traveller = new Traveller(train.RearTDBTraveller, true);
            }

            TrackDB trackDB = RuntimeData.Instance.TrackDB;
            List<TrackItem> trItems = trackDB.TrackItems;

            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;

            float prevDist = float.MaxValue;
            float nextDist = float.MaxValue;
            float d;

            lock (soundRegions)
            {
                // Check every sound region's all track nodes
                foreach (List<WorldSoundRegion> lwsr in soundRegions.Values)
                {
                    foreach (WorldSoundRegion wsr in lwsr)
                    {
                        foreach (int trNode in wsr.TrackNodes)
                        {
                            if (trItems[trNode] is SoundRegionItem)
                            {
                                tmp = new Traveller(traveller);

                                // Try to find forward
                                d = tmp.DistanceTo(trItems[trNode].Location, 8192);

                                if (d != -1)
                                {
                                    // This is nearer than previous one
                                    if (d < nextDist)
                                    {
                                        nextDist = d;
                                        nextItem = wsr;
                                    }
                                    // Or at exactly the same distance
                                    else if (d == nextDist)
                                    {
                                        if (traveller.Direction == tmp.Direction)
                                            tmp.ReverseDirection();

                                        // If faces toward us then it is applicable
                                        if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                        {
                                            nextDist = d;
                                            nextItem = wsr;
                                        }
                                    }
                                }
                                else
                                {
                                    // Not found forward, check backward
                                    tmp = new Traveller(traveller, true);

                                    d = tmp.DistanceTo(trItems[trNode].Location, 8192);
                                    if (d != -1)
                                    {
                                        // It is nearer than previous
                                        if (d < prevDist)
                                        {
                                            prevDist = d;
                                            prevItem = wsr;
                                        }
                                        else if (d == prevDist)
                                        {
                                            if (traveller.Direction != tmp.Direction)
                                                tmp.ReverseDirection();

                                            // Applicable if faces with us
                                            if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                            {
                                                prevDist = d;
                                                prevItem = wsr;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Have before and behind us
            if (prevItem != null && nextItem != null)
            {
                // Between same type, means we are in a sound region
                if (prevItem.TrackType == nextItem.TrackType)
                {
                    // return one of those, doesn't matter which.
                    retval = prevItem.TrackType;
                    outPrevDist = prevDist;
                    outNextDist = nextDist;
                }
                else if (nextDist < 10)
                {
                    // We are between different regions and the next is very near
                    // This case we won't change to default, unnecessary to that short period of time
                    // int.MaxValue means do not change the current region even if we left it
                    retval = int.MaxValue;
                }
                //  they are different types and far from each other
                //  So we are in a neutral zone, retval is 0, default track type
            }
            else if (prevItem != null)
            {
                // only one, take it!
                retval = prevItem.TrackType;
                outPrevDist = prevDist;
            }
            else if (nextItem != null)
            {
                // only one, take it!
                retval = nextItem.TrackType;
                outNextDist = nextDist;
            }
            //  - Missing items before or behind us, maintain last sound
            else
            {
                retval = int.MaxValue;
            }
            return retval;
        }

        public void AddByTile(in Tile tile)
        {
            string name = Path.Combine(Simulator.Instance.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(tile) + "s");
            WorldSoundFile wf = new WorldSoundFile(name, RuntimeData.Instance.TrackDB.TrackItems.Count);
            if (wf.TrackItemSound != null)
            {
                ImmutableArray<string> pathArray = ImmutableArray.Create(
                    Simulator.Instance.RouteFolder.SoundFolder, Simulator.Instance.RouteFolder.ContentFolder.SoundFolder);

                Collection<SoundSourceBase> ls = new Collection<SoundSourceBase>();
                foreach (var fss in wf.TrackItemSound.SoundSources)
                {
                    WorldLocation wl = new WorldLocation(tile, fss.Position);
                    var fullPath = FolderStructure.FindFileFromFolders(pathArray, fss.FileName);
                    if (fullPath != null)
                    {
                        soundSource = new SoundSource(wl, SoundEventSource.None, fullPath, true);
                        ls.Add(soundSource);
                    }
                }
                viewer.SoundProcess.AddSoundSources(name, ls);

                lock (soundRegions)
                {
                    if (!soundRegions.ContainsKey(name))
                    {
                        soundRegions.Add(name, wf.TrackItemSound.SoundRegions);
                    }
                }
            }
        }

        public void RemoveByTile(in Tile tile)
        {
            string name = Path.Combine(viewer.Simulator.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(tile) + "s");
            viewer.SoundProcess.RemoveSoundSources(name);
            lock (soundRegions)
            {
                soundRegions.Remove(name);
            }
        }
    }

    public class ORTSActSoundSources
    {
        public ORTSActSoundSources()
        {
        }

        public void Update()
        {
            if (Simulator.Instance.ActivityRun == null || Simulator.Instance.ActivityRun.TriggeredActivityEvent == null ||
                Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.SoundFile == null && (Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes == null
                || Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes.ActivitySound == null))
                return;
            var localEventID = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.ID;
            string ORTSActSoundFile;
            OrtsActivitySoundFileType ORTSActSoundFileType;
            ActivitySound activitySound = null;
            if (Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes == null
                || Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes.ActivitySound == null)
            {
                ORTSActSoundFile = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.SoundFile;
                ORTSActSoundFileType = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.SoundFileType;
            }
            else
            {
                activitySound = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes.ActivitySound;
                ORTSActSoundFile = activitySound.SoundFile;
                ORTSActSoundFileType = activitySound.SoundFileType;
            }
            var train = Simulator.Instance.ActivityRun.TriggeredActivityEvent.Train;
            Simulator.Instance.ActivityRun.TriggeredActivityEvent = null;
            var extension = Path.GetExtension(ORTSActSoundFile);
            SoundSource ActivitySounds;
            switch (extension)
            {
                case ".sms":
                    switch (ORTSActSoundFileType)
                    {
                        case OrtsActivitySoundFileType.Everywhere:
                            ActivitySounds = new SoundSource(SoundEventSource.InGame, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(playerLoco, Program.Viewer.World.Trains.GetViewer(playerLoco), ORTSActSoundFile);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Pass:
                            if (Program.Viewer.Camera.Style == CameraStyle.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(selectedWagon, Program.Viewer.World.Trains.GetViewer(selectedWagon), ORTSActSoundFile);
                                Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            }
                            break;
                        case OrtsActivitySoundFileType.Ground:
                            var loco = train == Program.Viewer.Simulator.PlayerLocomotive.Train ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];
                            //                            string wsName = Program.Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(worldLocation.TileX, worldLocation.TileZ) + "s";
                            ActivitySounds = new SoundSource(loco.WorldPosition.WorldLocation.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Location:
                            ActivitySounds = new SoundSource(activitySound.Location.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        default:
                            break;
                    }
                    break;
                case ".wav":
                    switch (ORTSActSoundFileType)
                    {
                        case OrtsActivitySoundFileType.Everywhere:
                            ActivitySounds = new SoundSource(ORTSActSoundFile, ORTSActSoundFileType, true);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(playerLoco, ORTSActSoundFile, ORTSActSoundFileType);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Pass:
                            if (Program.Viewer.Camera.Style == CameraStyle.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(selectedWagon, ORTSActSoundFile, ORTSActSoundFileType);
                                Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            }
                            break;
                        case OrtsActivitySoundFileType.Ground:
                            var loco = train == Program.Viewer.Simulator.PlayerLocomotive.Train ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];
                            //                           string wsName = Program.Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(worldLocation.TileX, worldLocation.TileZ) + "s";
                            ActivitySounds = new SoundSource(loco.WorldPosition.WorldLocation.ChangeElevation(3.0f), ORTSActSoundFile, true, ORTSActSoundFileType);// Sound does not come from earth!
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Location:
                            ActivitySounds = new SoundSource(activitySound.Location.ChangeElevation(3.0f), ORTSActSoundFile, true, ORTSActSoundFileType);// Sound does not come from earth!
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            return;
        }
    }
}

