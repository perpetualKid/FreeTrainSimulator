// COPYRIGHT 2009, 2010, 2011, 2012, 2013, 2014, 2015 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;

using FreeTrainSimulator.Common;
using FreeTrainSimulator.Common.Calc;
using FreeTrainSimulator.Common.Position;

using Orts.Formats.Msts;
using Orts.Formats.Msts.Files;
using Orts.Formats.Msts.Models;
using Orts.Simulation;
using Orts.Simulation.RollingStocks;

namespace Orts.ActivityRunner.Viewer3D.Sound
{

    /// <summary>
    /// Utility class to avoid loading multiple copies of the same file.
    /// </summary>
    public static class SharedSMSFileManager
    {
        private static readonly Dictionary<string, SoundManagmentFile> sharedSMSFiles = new Dictionary<string, SoundManagmentFile>();

        public static int SwitchSmsNumber { get; private set; }
        public static int CurveSmsNumber { get; private set; }
        public static int CurveSwitchSmsNumber { get; private set; }
        public static bool AutoTrackSound { get; private set; }

        public static SoundManagmentFile Get(string path)
        {
            if (!sharedSMSFiles.TryGetValue(path, out SoundManagmentFile value))
            {
                SoundManagmentFile smsFile = new SoundManagmentFile(path);
                value = smsFile;
                sharedSMSFiles.Add(path, value);
            }
            return value;
        }

        public static void Initialize(int trackTypesNumber)
        {
            if (Simulator.Instance.RouteModel.Settings.TryGetValue("CurveSound", out string settingValue) &&
                int.TryParse(settingValue, out int curveSmsNumber))
                CurveSmsNumber = curveSmsNumber;

            if (Simulator.Instance.RouteModel.Settings.TryGetValue("CurveSwitchSound", out settingValue) &&
                int.TryParse(settingValue, out int curveSwitchSmsNumber))
                CurveSwitchSmsNumber = curveSwitchSmsNumber;

            if (Simulator.Instance.RouteModel.Settings.TryGetValue("SwitchSound", out settingValue) &&
                int.TryParse(settingValue, out int switchSmsNumber))
                SwitchSmsNumber = switchSmsNumber;

            if (SwitchSmsNumber < -1 || SwitchSmsNumber >= trackTypesNumber)
            {
                SwitchSmsNumber = -1;
                Trace.TraceInformation("Switch SMS Number out of range");
            }
            if (SwitchSmsNumber != -1)
                AutoTrackSound = true;

            if (CurveSmsNumber < -1 || CurveSmsNumber >= trackTypesNumber)
            {
                CurveSmsNumber = -1;
                Trace.TraceInformation("Curve SMS Number out of range");
            }
            if (CurveSmsNumber != -1)
                AutoTrackSound = true;

            if (CurveSwitchSmsNumber < -1 || CurveSwitchSmsNumber >= trackTypesNumber)
            {
                CurveSwitchSmsNumber = CurveSmsNumber;
                Trace.TraceInformation("CurveSwitch SMS Number out of range, replaced with curve SMS number");
            }
            if (CurveSwitchSmsNumber != -1)
                AutoTrackSound = true;
        }
    }

    public class WorldSounds
    {
        private readonly Dictionary<string, IList<WorldSoundRegion>> soundRegions = new Dictionary<string, IList<WorldSoundRegion>>();
        private readonly Viewer viewer;
        private SoundSource soundSource;

        public WorldSounds(Viewer viewer)
        {
            this.viewer = viewer;
        }

        public int GetTType(Simulation.Physics.Train train, out float outPrevDist, out float outNextDist)
        {
            int retval = 0;
            Traveller traveller;
            Traveller tmp;
            outPrevDist = -1;
            outNextDist = -1;

            if (train.SpeedMpS >= 0)
            {
                traveller = new Traveller(train.FrontTDBTraveller);
            }
            else
            {
                traveller = new Traveller(train.RearTDBTraveller, true);
            }

            TrackDB trackDB = RuntimeData.Instance.TrackDB;
            List<TrackItem> trItems = trackDB.TrackItems;

            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;

            float prevDist = float.MaxValue;
            float nextDist = float.MaxValue;
            float d;

            lock (soundRegions)
            {
                // Check every sound region's all track nodes
                foreach (List<WorldSoundRegion> lwsr in soundRegions.Values)
                {
                    foreach (WorldSoundRegion wsr in lwsr)
                    {
                        foreach (int trNode in wsr.TrackNodes)
                        {
                            if (trItems[trNode] is SoundRegionItem)
                            {
                                tmp = new Traveller(traveller);

                                // Try to find forward
                                d = tmp.DistanceTo(trItems[trNode].Location, 8192);

                                if (d != -1)
                                {
                                    // This is nearer than previous one
                                    if (d < nextDist)
                                    {
                                        nextDist = d;
                                        nextItem = wsr;
                                    }
                                    // Or at exactly the same distance
                                    else if (d == nextDist)
                                    {
                                        if (traveller.Direction == tmp.Direction)
                                            tmp.ReverseDirection();

                                        // If faces toward us then it is applicable
                                        if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                        {
                                            nextDist = d;
                                            nextItem = wsr;
                                        }
                                    }
                                }
                                else
                                {
                                    // Not found forward, check backward
                                    tmp = new Traveller(traveller, true);

                                    d = tmp.DistanceTo(trItems[trNode].Location, 8192);
                                    if (d != -1)
                                    {
                                        // It is nearer than previous
                                        if (d < prevDist)
                                        {
                                            prevDist = d;
                                            prevItem = wsr;
                                        }
                                        else if (d == prevDist)
                                        {
                                            if (traveller.Direction != tmp.Direction)
                                                tmp.ReverseDirection();

                                            // Applicable if faces with us
                                            if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                            {
                                                prevDist = d;
                                                prevItem = wsr;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Have before and behind us
            if (prevItem != null && nextItem != null)
            {
                // Between same type, means we are in a sound region
                if (prevItem.TrackType == nextItem.TrackType)
                {
                    // return one of those, doesn't matter which.
                    retval = prevItem.TrackType;
                    outPrevDist = prevDist;
                    outNextDist = nextDist;
                }
                else if (nextDist < 10)
                {
                    // We are between different regions and the next is very near
                    // This case we won't change to default, unnecessary to that short period of time
                    // int.MaxValue means do not change the current region even if we left it
                    retval = int.MaxValue;
                }
                //  they are different types and far from each other
                //  So we are in a neutral zone, retval is 0, default track type
            }
            else if (prevItem != null)
            {
                // only one, take it!
                retval = prevItem.TrackType;
                outPrevDist = prevDist;
            }
            else if (nextItem != null)
            {
                // only one, take it!
                retval = nextItem.TrackType;
                outNextDist = nextDist;
            }
            //  - Missing items before or behind us, maintain last sound
            else
            {
                retval = int.MaxValue;
            }
            return retval;
        }

        public void AddByTile(in Tile tile)
        {
            string name = Path.Combine(Simulator.Instance.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(tile) + "s");
            WorldSoundFile wf = new WorldSoundFile(name, RuntimeData.Instance.TrackDB.TrackItems.Count);
            if (wf.TrackItemSound != null)
            {
                ImmutableArray<string> pathArray = ImmutableArray.Create(
                    Simulator.Instance.RouteFolder.SoundFolder, Simulator.Instance.RouteFolder.ContentFolder.SoundFolder);

                Collection<SoundSourceBase> ls = new Collection<SoundSourceBase>();
                foreach (var fss in wf.TrackItemSound.SoundSources)
                {
                    WorldLocation wl = new WorldLocation(tile, fss.Position);
                    var fullPath = FolderStructure.FindFileFromFolders(pathArray, fss.FileName);
                    if (fullPath != null)
                    {
                        soundSource = new SoundSource(wl, SoundEventSource.None, fullPath, true);
                        ls.Add(soundSource);
                    }
                }
                viewer.SoundProcess.AddSoundSources(name, ls);

                lock (soundRegions)
                {
                    if (!soundRegions.ContainsKey(name))
                    {
                        soundRegions.Add(name, wf.TrackItemSound.SoundRegions);
                    }
                }
            }
        }

        public void RemoveByTile(in Tile tile)
        {
            string name = Path.Combine(viewer.Simulator.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(tile) + "s");
            viewer.SoundProcess.RemoveSoundSources(name);
            lock (soundRegions)
            {
                soundRegions.Remove(name);
            }
        }
    }

    public class ORTSActSoundSources
    {
        public ORTSActSoundSources()
        {
        }

        public void Update()
        {
            if (Simulator.Instance.ActivityRun == null || Simulator.Instance.ActivityRun.TriggeredActivityEvent == null ||
                Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.SoundFile == null && (Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes == null
                || Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes.ActivitySound == null))
                return;
            var localEventID = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.ID;
            string ORTSActSoundFile;
            OrtsActivitySoundFileType ORTSActSoundFileType;
            ActivitySound activitySound = null;
            if (Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes == null
                || Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes.ActivitySound == null)
            {
                ORTSActSoundFile = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.SoundFile;
                ORTSActSoundFileType = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.SoundFileType;
            }
            else
            {
                activitySound = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes.ActivitySound;
                ORTSActSoundFile = activitySound.SoundFile;
                ORTSActSoundFileType = activitySound.SoundFileType;
            }
            var train = Simulator.Instance.ActivityRun.TriggeredActivityEvent.Train;
            Simulator.Instance.ActivityRun.TriggeredActivityEvent = null;
            var extension = Path.GetExtension(ORTSActSoundFile);
            SoundSource ActivitySounds;
            switch (extension)
            {
                case ".sms":
                    switch (ORTSActSoundFileType)
                    {
                        case OrtsActivitySoundFileType.Everywhere:
                            ActivitySounds = new SoundSource(SoundEventSource.InGame, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(playerLoco, Program.Viewer.World.Trains.GetViewer(playerLoco), ORTSActSoundFile);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Pass:
                            if (Program.Viewer.Camera.Style == CameraStyle.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(selectedWagon, Program.Viewer.World.Trains.GetViewer(selectedWagon), ORTSActSoundFile);
                                Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            }
                            break;
                        case OrtsActivitySoundFileType.Ground:
                            var loco = train == Program.Viewer.Simulator.PlayerLocomotive.Train ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];
                            //                            string wsName = Program.Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(worldLocation.TileX, worldLocation.TileZ) + "s";
                            ActivitySounds = new SoundSource(loco.WorldPosition.WorldLocation.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Location:
                            ActivitySounds = new SoundSource(activitySound.Location.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        default:
                            break;
                    }
                    break;
                case ".wav":
                    switch (ORTSActSoundFileType)
                    {
                        case OrtsActivitySoundFileType.Everywhere:
                            ActivitySounds = new SoundSource(ORTSActSoundFile, ORTSActSoundFileType, true);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(playerLoco, ORTSActSoundFile, ORTSActSoundFileType);
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Pass:
                            if (Program.Viewer.Camera.Style == CameraStyle.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(selectedWagon, ORTSActSoundFile, ORTSActSoundFileType);
                                Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            }
                            break;
                        case OrtsActivitySoundFileType.Ground:
                            var loco = train == Program.Viewer.Simulator.PlayerLocomotive.Train ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];
                            //                           string wsName = Program.Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(worldLocation.TileX, worldLocation.TileZ) + "s";
                            ActivitySounds = new SoundSource(loco.WorldPosition.WorldLocation.ChangeElevation(3.0f), ORTSActSoundFile, true, ORTSActSoundFileType);// Sound does not come from earth!
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        case OrtsActivitySoundFileType.Location:
                            ActivitySounds = new SoundSource(activitySound.Location.ChangeElevation(3.0f), ORTSActSoundFile, true, ORTSActSoundFileType);// Sound does not come from earth!
                            Program.Viewer.SoundProcess.AddSoundSource(localEventID, ActivitySounds);
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            return;
        }
    }
}

