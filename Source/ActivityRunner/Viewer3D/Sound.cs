// COPYRIGHT 2009, 2010, 2011, 2012, 2013, 2014, 2015 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

//#define DEBUGSCR

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows.Forms;

using Orts.ActivityRunner.Viewer3D.RollingStock;
using Orts.ActivityRunner.Viewer3D.Sound;
using Orts.Common;
using Orts.Common.Calc;
using Orts.Common.Position;
using Orts.Formats.Msts;
using Orts.Formats.Msts.Files;
using Orts.Formats.Msts.Models;
using Orts.Settings;
using Orts.Simulation;
using Orts.Simulation.RollingStocks;
using Orts.Simulation.Track;

namespace Orts.ActivityRunner.Viewer3D
{

    /// <summary>
    /// Utility class to avoid loading multiple copies of the same file.
    /// </summary>
    public static class SharedSMSFileManager
    {
        private static readonly Dictionary<string, SoundManagmentFile> sharedSMSFiles = new Dictionary<string, SoundManagmentFile>();

        public static int SwitchSmsNumber { get; private set; }
        public static int CurveSmsNumber { get; private set; }
        public static int CurveSwitchSmsNumber { get; private set; }
        public static bool AutoTrackSound { get; private set; }

        public static SoundManagmentFile Get(string path)
        {
            if (!sharedSMSFiles.ContainsKey(path))
            {
                SoundManagmentFile smsFile = new SoundManagmentFile(path);
                sharedSMSFiles.Add(path, smsFile);
            }
            return sharedSMSFiles[path];
        }

        public static void Initialize(int trackTypesNumber, int switchSmsNumber, int curveSmsNumber, int curveSwitchSmsNumber)
        {
            SwitchSmsNumber = switchSmsNumber;

            if (SwitchSmsNumber < -1 || SwitchSmsNumber >= trackTypesNumber)
            {
                SwitchSmsNumber = -1;
                Trace.TraceInformation("Switch SMS Number out of range");
            }
            if (SwitchSmsNumber != -1)
                AutoTrackSound = true;

            CurveSmsNumber = curveSmsNumber;
            if (CurveSmsNumber < -1 || CurveSmsNumber >= trackTypesNumber)
            {
                CurveSmsNumber = -1;
                Trace.TraceInformation("Curve SMS Number out of range");
            }
            if (CurveSmsNumber != -1)
                AutoTrackSound = true;

            CurveSwitchSmsNumber = curveSwitchSmsNumber;
            if (CurveSwitchSmsNumber < -1 || CurveSwitchSmsNumber >= trackTypesNumber)
            {
                CurveSwitchSmsNumber = CurveSmsNumber;
                Trace.TraceInformation("CurveSwitch SMS Number out of range, replaced with curve SMS number");
            }
            if (CurveSwitchSmsNumber != -1)
                AutoTrackSound = true;

        }
    }

    /////////////////////////////////////////////////////////
    // SOUND SOURCE
    /////////////////////////////////////////////////////////

    /// <summary>
    /// Represents an sms file,
    /// may have a physical location in the world,
    /// may be attached to a railcar in which case it moves with the car,
    /// owns one or more SoundStreams
    /// </summary>
    public abstract class SoundSourceBase : IDisposable
    {
        public abstract void InitInitials();
        public abstract void Uninitialize();
        public abstract bool Update();

        /// <summary>
        /// The sound may be from a train car
        /// </summary>
        public MSTSWagon Car { get; set; }
        public TrainCarViewer TrainCar { get; }

        private protected static readonly Viewer viewer = Program.Viewer;
        /// <summary>
        /// Volume of the ScalabiltyGroup
        /// </summary>
        public float Volume { get; set; } = 1;
        /// <summary>
        /// If needs active management or can be left to OpenAL to deal with sound properties
        /// </summary>
        public bool NeedsFrequentUpdate { get; protected set; }
        private bool disposedValue;

        protected SoundSourceBase()
        {
        }

        protected SoundSourceBase(TrainCarViewer trainCar)
        {
            TrainCar = trainCar;
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // TODO: dispose managed state (managed objects)
                }

                disposedValue = true;
            }
        }

        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }

    public class TrackSoundSource : SoundSourceBase
    {
        private int prevTrackSoundType = -1;
        private int curTrackSoundType = -1;
        public SoundSource ActiveInSource { get; private set; }
        public SoundSource ActiveOutSource { get; private set; }
        private readonly List<SoundSource> inSources;
        private readonly List<SoundSource> outSources;

        // data to evaluate if ttype selection is needed or not
        private float nextDist = -1; // initial distance to sound region forward
        private float prevDist = -1; // initial distance to sond region backward
        private float initDist = -1; // initial distance run when last ttype selected
        private int initTrackSection = -1; // track section when last ttype selected
        private MSTSWagon initCar; // initial leading car (to accommodate in case of change of direction)
        private bool carOnSwitch;
        private bool carOnCurve;
        private readonly MSTSWagonViewer wagonViewer;

        public TrackSoundSource(MSTSWagonViewer carViewer) :
            base(carViewer)
        {
            wagonViewer = TrainCar as MSTSWagonViewer ?? throw new InvalidCastException(nameof(carViewer));
            Car = TrainCar.Car as MSTSWagon ?? throw new InvalidCastException(nameof(carViewer));
            inSources = new List<SoundSource>();
            outSources = new List<SoundSource>();

            foreach (TrackType ttdf in viewer.TrackTypes)
            {
                MSTSLocomotive loco = Car as MSTSLocomotive;

                if (!string.IsNullOrEmpty(Car.InteriorShapeFileName) || (loco != null && (loco.HasFrontCab || loco.HasRearCab || loco.HasFront3DCab || loco.HasRear3DCab)))
                    LoadTrackSound(ttdf.InsideSound, true);

                LoadTrackSound(ttdf.OutsideSound, false);
            }
        }

        private void LoadTrackSound(string filename, bool insideSound)
        {
            if (filename == null)
                return;

            string[] pathArray = { viewer.Simulator.RouteFolder.SoundFolder, viewer.Simulator.RouteFolder.ContentFolder.SoundFolder };
            var fullPath = FolderStructure.FindFileFromFolders(pathArray, filename);
            if (fullPath == null)
            {
                Trace.TraceWarning("Skipped missing track sound {0}", filename);
                return;
            }
            if (insideSound)
                inSources.Add(new SoundSource(Car, TrainCar, fullPath));
            else
                outSources.Add(new SoundSource(Car, TrainCar, fullPath));
        }

        public override void Uninitialize()
        {
            if (ActiveInSource != null)
                ActiveInSource.Uninitialize();
            if (ActiveOutSource != null)
                ActiveOutSource.Uninitialize();
        }

        public override void InitInitials()
        {
            if (inSources != null && inSources.Count > 0)
                ActiveInSource = inSources[0];

            if (outSources != null && outSources.Count > 0)
                ActiveOutSource = outSources[0];

            curTrackSoundType = 0;
            prevTrackSoundType = 0;
        }

        public void UpdateTType(bool stateChange)
        {
            if (prevTrackSoundType == -1)
            {
                InitInitials();
            }

            if (Car != null && Car.Train != null)
            {
                int carIncrement;
                int carLeading;
                if (Car.Train.SpeedMpS > 0.1f)
                {
                    carIncrement = 1;
                    carLeading = 0;
                }
                else if (Car.Train.SpeedMpS < -0.1f)
                {
                    carIncrement = -1;
                    carLeading = Car.Train.Cars.Count - 1;
                }
                else
                    return;

                int carIndex = Car.Train.Cars.IndexOf(Car);

                if (carIndex == carLeading)
                {
                    bool reSelect = stateChange;
                    if (!reSelect)
                    {
                        if (nextDist == -1 || initCar != Car.Train.Cars[carLeading] ||
                            (carLeading == 0 && Car.Train.PresentPosition[Direction.Forward].TrackCircuitSectionIndex != initTrackSection) ||
                            (carLeading != 0 && Car.Train.PresentPosition[Direction.Backward].TrackCircuitSectionIndex != initTrackSection) ||
                            (carLeading == 0 && (Car.Train.DistanceTravelledM - initDist > nextDist || initDist - Car.Train.DistanceTravelledM > prevDist)) ||
                            (carLeading != 0 && (Car.Train.DistanceTravelledM - Car.Train.Length - initDist > nextDist || initDist - Car.Train.DistanceTravelledM + Car.Train.Length > prevDist)))
                        {
                            reSelect = true;
                        }
                    }
                    if (reSelect)
                    {
                        initCar = Car;
                        initTrackSection = carLeading == 0 ? Car.Train.PresentPosition[Direction.Forward].TrackCircuitSectionIndex : Car.Train.PresentPosition[Direction.Backward].TrackCircuitSectionIndex;
                        initDist = carLeading == 0 ? Car.Train.DistanceTravelledM : Car.Train.DistanceTravelledM - Car.Train.Length;
                        wagonViewer.TrackSoundType = viewer.World.Sounds.GetTType(Car.Train, out prevDist, out nextDist);
                        if (wagonViewer.TrackSoundType != int.MaxValue)
                            if (wagonViewer.TrackSoundType < viewer.TrackTypes.Count)
                                curTrackSoundType = wagonViewer.TrackSoundType;
                            else
                            {
                                // Track type out of range
                                curTrackSoundType = 0;
                                Trace.TraceWarning("Sound region {0} out of range in tile {1} {2}", wagonViewer.TrackSoundType,
                                    Car.WorldPosition.WorldLocation.TileX, Car.WorldPosition.WorldLocation.TileZ);
                                wagonViewer.TrackSoundType = 0;
                            }
                        else
                            if (!SharedSMSFileManager.AutoTrackSound || (
                                curTrackSoundType != SharedSMSFileManager.SwitchSmsNumber &&
                                curTrackSoundType != SharedSMSFileManager.CurveSmsNumber &&
                                curTrackSoundType != SharedSMSFileManager.CurveSwitchSmsNumber))
                            wagonViewer.TrackSoundType = curTrackSoundType;
                        else
                        {
                            wagonViewer.TrackSoundType = 0;
                            curTrackSoundType = 0;
                        }
                    }
                    else
                        wagonViewer.TrackSoundType = curTrackSoundType;
                }
                else
                {
                    if (viewer.World.Trains.Cars.TryGetValue(Car.Train.Cars[carIndex - carIncrement], out TrainCarViewer carAhead) && carAhead.TrackSoundLocation != WorldLocation.None)
                    {
                        if ((curTrackSoundType == wagonViewer.TrackSoundType || stateChange) && wagonViewer.TrackSoundType != carAhead.TrackSoundType)
                        {
                            wagonViewer.TrackSoundType = carAhead.TrackSoundType;
                            wagonViewer.TrackSoundLocation = carAhead.TrackSoundLocation;
                            wagonViewer.TrackSoundDistSquared = (float)WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, wagonViewer.TrackSoundLocation);
                            if (stateChange)
                            {
                                curTrackSoundType = wagonViewer.TrackSoundType;
                            }
                        }

                        if (wagonViewer.TrackSoundLocation != WorldLocation.None)
                        {
                            float trackSoundDistSquared = (float)WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, wagonViewer.TrackSoundLocation);
                            if (trackSoundDistSquared > 9 && (trackSoundDistSquared - 2) <= wagonViewer.TrackSoundDistSquared)
                                wagonViewer.TrackSoundDistSquared = trackSoundDistSquared;
                            else
                            {
                                curTrackSoundType = wagonViewer.TrackSoundType;
                            }
                        }
                    }
                }

                if (curTrackSoundType != prevTrackSoundType)
                {
                    if (ActiveInSource != null)
                    {
                        ActiveInSource.Uninitialize();
                        if (0 <= curTrackSoundType && curTrackSoundType < inSources.Count)
                            ActiveInSource = inSources[curTrackSoundType];
                        else
                            Trace.TraceWarning("Could not change inside sound region to {0}", curTrackSoundType);
                    }

                    if (ActiveOutSource != null)
                    {
                        ActiveOutSource.Uninitialize();
                        if (0 <= curTrackSoundType && curTrackSoundType < outSources.Count)
                            ActiveOutSource = outSources[curTrackSoundType];
                        else
                            Trace.TraceWarning("Could not change outside sound region to {0}", curTrackSoundType);
                    }
                    if (carIndex == carLeading)
                        wagonViewer.TrackSoundLocation = Car.WorldPosition.WorldLocation;
                    prevTrackSoundType = curTrackSoundType;
                }
            }
        }

        public override bool Update()
        {
            bool stateChange = false;
            if (SharedSMSFileManager.AutoTrackSound)
                stateChange = UpdateCarOnSwitchAndCurve();
            if ((!carOnSwitch && !carOnCurve) || !SharedSMSFileManager.AutoTrackSound)
                UpdateTType(stateChange);
            bool retval = true;
            NeedsFrequentUpdate = false;

            if (ActiveInSource != null)
            {
                retval &= ActiveInSource.Update();
                NeedsFrequentUpdate |= ActiveInSource.NeedsFrequentUpdate;
            }

            if (ActiveOutSource != null)
            {
                retval &= ActiveOutSource.Update();
                NeedsFrequentUpdate |= ActiveOutSource.NeedsFrequentUpdate;
            }

            return retval;
        }

        // To detect redundant calls
        private bool disposedValue;
        protected override void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    foreach (SoundSource soundSource in inSources ?? Enumerable.Empty<SoundSource>())
                        soundSource.Dispose();
                    inSources.Clear();
                    foreach (SoundSource s in outSources ?? Enumerable.Empty<SoundSource>())
                        s.Dispose();
                    outSources.Clear();
                    Car = null;
                }
                disposedValue = true;
            }
            base.Dispose(disposing);
        }

        //Checks whether car on switch or on curve or both and selects related .sms file;
        // returns true if state has changed
        public bool UpdateCarOnSwitchAndCurve()
        {
            bool stateChange = false;
            if (Car?.Train != null)
            {
                if (Car.Train.SpeedMpS > 0.1f || Car.Train.SpeedMpS < -0.1f)
                {
                    int carNo = Car.Train.Cars.IndexOf(Car);
                    int carIncrement = 0;
                    if (Car.Train.SpeedMpS > 0.1f && carNo != Car.Train.Cars.Count - 1)
                        carIncrement = 1;
                    if (Car.Train.SpeedMpS < 0.1f && carNo != 0)
                        carIncrement = -1;

                    TrainCar CarBehind = Car.Train.Cars[carNo + carIncrement];
                    bool carPreviouslyOnSwitch = carOnSwitch;
                    carOnSwitch = false;
                    if (Car.Train.PresentPosition[Direction.Forward].TrackCircuitSectionIndex != Car.Train.PresentPosition[Direction.Backward].TrackCircuitSectionIndex)
                    {
                        foreach (TrackCircuitSection section in Car.Train.OccupiedTrack)
                        {
                            if (section.CircuitType == TrackCircuitType.Junction || section.CircuitType == TrackCircuitType.Crossover)
                            {
                                // train is on a switch; let's see if car is on a switch too
                                WorldLocation switchLocation = RuntimeData.Instance.TrackDB.TrackNodes[section.OriginalIndex].UiD.Location;
                                var distanceFromSwitch = WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, switchLocation);
                                if (distanceFromSwitch < Car.CarLengthM * Car.CarLengthM + Math.Min(Car.SpeedMpS * 3, 150))
                                {
                                    carOnSwitch = true;
                                    break;
                                }
                            }
                        }
                    }
                    // here check for curve
                    var carPreviouslyOnCurve = carOnCurve;
                    carOnCurve = false;
                    if ((Car.CurrentCurveRadius > 0 && (Car.CurrentCurveRadius < 301
                         || (Car.CurrentCurveRadius < 350 && Car.WagonType == WagonType.Freight))) ||
                        (CarBehind.CurrentCurveRadius > 0 && (CarBehind.CurrentCurveRadius < 301
                         || (CarBehind.CurrentCurveRadius < 350 && Car.WagonType == WagonType.Freight))))
                    {
                        carOnCurve = true;
                    }

                    // resume results and select sound if change
                    if (carPreviouslyOnSwitch ^ carOnSwitch || carPreviouslyOnCurve ^ carOnCurve)
                    {
                        stateChange = true;
                    }
                    if (stateChange && (carOnSwitch || carOnCurve))
                    {
                        wagonViewer.TrackSoundLocation = Car.WorldPosition.WorldLocation;
                        if (carOnSwitch && carOnCurve && SharedSMSFileManager.CurveSwitchSmsNumber != -1)
                        {
                            curTrackSoundType = SharedSMSFileManager.CurveSwitchSmsNumber;
                        }
                        else if (carOnCurve && SharedSMSFileManager.CurveSmsNumber != -1)
                        {
                            curTrackSoundType = SharedSMSFileManager.CurveSmsNumber;
                        }
                        else if (carOnSwitch && SharedSMSFileManager.SwitchSmsNumber != -1)
                        // car on switch
                        {
                            curTrackSoundType = SharedSMSFileManager.SwitchSmsNumber;
                        }
                        else
                            stateChange = false;
                    }
                }
                else
                    return stateChange;

                if (curTrackSoundType != prevTrackSoundType)
                {
                    if (ActiveInSource != null)
                    {
                        ActiveInSource.Uninitialize();
                        ActiveInSource = inSources[curTrackSoundType];
                        if (0 <= curTrackSoundType && curTrackSoundType < inSources.Count)
                            ActiveInSource = inSources[curTrackSoundType];
                        else
                            Trace.TraceWarning("Could not change inside sound region to {0}", curTrackSoundType);
                    }

                    if (ActiveOutSource != null)
                    {
                        ActiveOutSource.Uninitialize();
                        ActiveOutSource = outSources[curTrackSoundType];
                        if (0 <= curTrackSoundType && curTrackSoundType < outSources.Count)
                            ActiveInSource = inSources[curTrackSoundType];
                        else
                            Trace.TraceWarning("Could not change outside sound region to {0}", curTrackSoundType);
                    }
                    prevTrackSoundType = curTrackSoundType;
                }
            }
            return stateChange;
        }
    }

    /// <summary>
    /// Represents an sms file
    /// </summary>
    public class SoundSource : SoundSourceBase
    {
        /// <summary>
        /// Squared cutoff distance. No sound is audible above that, except for the actual player train,
        /// where cutoff occurs at a distance wich is higher than the train length plus offset to 
        /// approximately take into account distance from camera to car
        /// </summary>
        private int CutOffDistanceM2
        {
            get
            {
                const int staticDistanceM2 = 4000000;
                var isPlayer = Car?.Train?.IsActualPlayerTrain ?? false;
                var correctedLength = isPlayer ? Car.Train.Length + 50 : 0;
                return (int)Math.Max(staticDistanceM2, correctedLength * correctedLength);
            }
        }
        /// <summary>
        /// Max distance for OpenAL inverse distance model. Equals to Math.Sqrt(CUTOFFDISTANCE)
        /// </summary>
        public const float MaxDistanceM = 2000f;
        /// <summary>
        /// Desired max gain at max distance for OpenAL inverse distance model
        /// </summary>
        public const float GainAtMaxDistance = 0.025f;
        /// <summary>
        /// Below this distance there is no attenuation. Used by OpenAL inverse distance model
        /// </summary>
        public const float ReferenceDistanceM = 8f;
        /// <summary>
        /// Sound attenuation factor. Calculated to achieve goal set by <see cref="GainAtMaxDistance"/>
        /// </summary>
        public float RolloffFactor;
        /// <summary>
        /// Used for InGame sounds and activity sounds of type "Overall"
        /// </summary>
        public bool IsUnattenuated;
        /// <summary>
        /// Used for Horns
        /// </summary>
        public float HornRolloffFactor = 0.05f;

        /// <summary>
        /// Construct a SoundSource attached to a train car.
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(MSTSWagon car, TrainCarViewer carViewer, string smsFilePath): 
            base(carViewer)
        {
            Car = car;
            Initialize(car.WorldPosition.WorldLocation, SoundEventSource.Car, smsFilePath);
        }

        /// <summary>
        /// Initializes a SoundSource which has no specific location - like ingame.sms
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(SoundEventSource eventSource, string smsFilePath, bool isUnattenuated)
        {
            IsUnattenuated = isUnattenuated;
            Initialize(WorldLocation.None, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(in WorldLocation worldLocation, SoundEventSource eventSource, string smsFilePath)
        {
            IsEnvSound = true;
            Initialize(worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="slowRolloff"></param>
        public SoundSource(in WorldLocation worldLocation, SoundEventSource eventSource, string smsFilePath, bool slowRolloff)
        {
            IsEnvSound = true;
            SlowRolloff = slowRolloff;
            Initialize(worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource attached to a train car, with predefined parameters (activity sound).
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(MSTSWagon car, string wavFilePath, OrtsActivitySoundFileType ORTSActSoundFileType, bool preCompiled)
        {
            Car = car;
            Initialize(car.WorldPosition.WorldLocation, SoundEventSource.Car, wavFilePath, ORTSActSoundFileType, preCompiled);
        }

        /// <summary>
        /// Construct a SoundSource which has no specific location - like ingame.sms, with predefined parameters (activity sound)
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(SoundEventSource eventSource, string wavFilePath, OrtsActivitySoundFileType ORTSActSoundFileType, bool isUnattenuated, bool preCompiled)
        {
            IsUnattenuated = isUnattenuated;
            Initialize(WorldLocation.None, eventSource, wavFilePath, ORTSActSoundFileType, preCompiled);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation, with predefined parameters (activity sound)
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="slowRolloff"></param>
        public SoundSource(in WorldLocation worldLocation, SoundEventSource eventSource, string wavFilePath, bool slowRolloff, OrtsActivitySoundFileType ORTSActSoundFileType, bool preCompiled)
        {
            IsEnvSound = true;
            SlowRolloff = slowRolloff;
            Initialize(worldLocation, eventSource, wavFilePath, ORTSActSoundFileType, preCompiled);
        }

        /// <summary>
        /// Construct a SoundSource that has no specific location and a set of programmatically defined <see cref="SoundStream"/>s.
        /// </summary>
        /// <param name="viewer">The <see cref="Viewer"/> to attach this SoundSource to.</param>
        /// <param name="makeStreams">A generator function to create the attached SoundStreams.</param>
        public SoundSource(Func<SoundSource, IEnumerable<SoundStream>> makeStreams)
        {
            IsUnattenuated = true;
            Initialize();
            SoundStreams.AddRange(makeStreams(this));
        }

        /// <summary>
        /// Stop the streams, free up OpenAL sound source IDs and try to unload wave data from memory
        /// </summary>
        public override void Uninitialize()
        {
            foreach (SoundStream ss in SoundStreams)
            {
                ss.Stop();
                ss.HardDeactivate();
                WasOutOfDistance = true;
                NeedsFrequentUpdate = false;
            }
        }

        /// <summary>
        /// Current location of the sound source
        /// </summary>
        public WorldLocation WorldLocation;

        /// <summary>
        /// The wave files will be relative to this folder
        /// </summary>
        public string SMSFolder;
        public string SMSFileName;
        public string WavFolder;
        public string WavFileName;
        public bool Active;
        private SoundActivationCondition ActivationConditions;
        private SoundActivationCondition DeactivationConditions;
        public bool IsEnvSound;
        public bool IsExternal = true;
        public bool Ignore3D;
        /// <summary>
        /// MSTS treats Stereo() tagged mono wav files specially. This is a flag
        /// indicating if this treatment should be applied here
        /// </summary>
        public bool MstsMonoTreatment;

        /// <summary>
        /// Current distance to camera, squared meter. Is used for comparision to <see cref="CutOffDistanceM2"/>, to determine if is out-of-scope
        /// </summary>
        public float DistanceSquared = float.MaxValue;
        /// <summary>
        /// Out-of-scope state in previous <see cref="Update"/> loop
        /// </summary>
        private bool WasOutOfDistance = true;
        /// <summary>
        /// Different rolloff factor is used for track sounds not to attenuate so fast. As a bargain they are not silenced at cutoff distance
        /// </summary>
        private bool SlowRolloff;

        /// <summary>
        /// List of Streams in sms
        /// </summary>
        public List<SoundStream> SoundStreams = new List<SoundStream>();

        /// <summary>
        /// Set properties of this SoundSource based on parsing the sms file, and generate SoundStreams
        /// </summary>
        /// <param name="viewer">Current <see cref="Viewer3D"/></param>
        /// <param name="worldLocation">World location of <see cref="SoundSource"/></param>
        /// <param name="eventSource">Type of game part sms belongs to, to determine how to interpret discrete trigger numbers</param>
        /// <param name="smsFilePath">Full path for sms file</param>
        public void Initialize(in WorldLocation worldLocation, SoundEventSource eventSource, string smsFilePath)
        {
            WorldLocation = worldLocation;

            if (smsFilePath == null)
                return;

            SMSFolder = Path.GetDirectoryName(smsFilePath);
            SMSFileName = Path.GetFileName(smsFilePath);
            SoundManagmentFile smsFile = SharedSMSFileManager.Get(smsFilePath);


            // find correct ScalabiltyGroup
            int iSG = 0;
            while (iSG < smsFile.ScalabiltyGroups.Count)
            {
                if (smsFile.ScalabiltyGroups[iSG].DetailLevel <= Simulator.Instance.Settings.SoundDetailLevel)
                    break;
                ++iSG;
            }
            if (iSG < smsFile.ScalabiltyGroups.Count && smsFile.ScalabiltyGroups[iSG].Streams != null)  // else we want less sound so don't provide any
            {
                ScalabilityGroup mstsScalabiltyGroup = smsFile.ScalabiltyGroups[iSG];

                ActivationConditions = mstsScalabiltyGroup.Activation;
                DeactivationConditions = mstsScalabiltyGroup.Deactivation;
                Volume = mstsScalabiltyGroup.Volume;
                Ignore3D = mstsScalabiltyGroup.Ignore3D | mstsScalabiltyGroup.Stereo;
                MstsMonoTreatment = mstsScalabiltyGroup.Stereo;
                IsExternal = ActivationConditions.ExternalCam;

                SetRolloffFactor();

                foreach (SmsStream mstsStream in mstsScalabiltyGroup.Streams)
                {
                    SoundStreams.Add(new SoundStream(mstsStream, eventSource, this));
                }
            }
        }

        /// <summary>
        /// Set properties of this SoundSource with default precompiled parameters, and generate SoundStreams
        /// </summary>
        /// <param name="viewer">Current <see cref="Viewer3D"/></param>
        /// <param name="worldLocation">World location of <see cref="SoundSource"/></param>
        /// <param name="eventSource">Type of game part sound source belongs to, to determine how to interpret discrete trigger numbers</param>
        /// <param name="smsFilePath">Full path for sms file</param>
        public void Initialize(in WorldLocation worldLocation, SoundEventSource eventSource, string wavFilePath, OrtsActivitySoundFileType ORTSActSoundFileType, bool preCompiled)
        {
            WorldLocation = worldLocation;

            if (wavFilePath == null)
                return;

            WavFolder = Path.GetDirectoryName(wavFilePath);
            WavFileName = Path.GetFileName(wavFilePath);
            SMSFolder = WavFolder;
            SMSFileName = WavFileName;

            if (SoundSourceBase.viewer.Settings.SoundDetailLevel >= 3)
            {
                // base initializations
                ActivationConditions = new SoundActivationCondition(ORTSActSoundFileType, ActivationType.Activate);
                DeactivationConditions = new SoundActivationCondition(ORTSActSoundFileType, ActivationType.Deactivate);
                switch (ORTSActSoundFileType)
                {
                    case OrtsActivitySoundFileType.Everywhere:
                        Ignore3D = true;
                        IsExternal = true;
                        break;
                    default:
                    case OrtsActivitySoundFileType.Cab:
                    case OrtsActivitySoundFileType.Pass:
                        Ignore3D = true;
                        IsExternal = false;
                        break;
                    case OrtsActivitySoundFileType.Ground:
                    case OrtsActivitySoundFileType.Location:
                        Ignore3D = false;
                        IsExternal = true;
                        break;
                }
                Volume = 1.0f;
                SetRolloffFactor();

                // initialization of the only one sound stream
                SoundStreams.Add(new SoundStream(WavFileName, eventSource, this));
            }
        }

        private void Initialize()
        {
            WorldLocation = WorldLocation.None;

            ActivationConditions = new SoundActivationCondition(OrtsActivitySoundFileType.Everywhere, ActivationType.Activate);
            DeactivationConditions = new SoundActivationCondition(OrtsActivitySoundFileType.Everywhere, ActivationType.Deactivate);

            Volume = 1.0f;
            SetRolloffFactor();
        }

        private void SetRolloffFactor()
        {
            var deactivationDistance = DeactivationConditions != null && DeactivationConditions.Distance != 0 ? DeactivationConditions.Distance : MaxDistanceM;
            var maxDistanceM = Math.Min(MaxDistanceM, deactivationDistance);

            // OpenAL inverse distance model is based on formula
            // Gain = AL_REFERENCE_DISTANCE / ( AL_REFERENCE_DISTANCE + AL_ROLLOFF_FACTOR * ( Distance - AL_REFERENCE_DISTANCE ) )
            RolloffFactor = SlowRolloff ? 0.4f : ReferenceDistanceM * (1f / GainAtMaxDistance - 1f) / (maxDistanceM - ReferenceDistanceM);
        }

        /// <summary>
        /// Check if an event needs action from one of discrete triggers
        /// </summary>
        /// <param name="eventID">Occured event</param>
        public void HandleEvent(TrainEvent eventID)
        {
            foreach (SoundStream ss in SoundStreams)
            {
                foreach (ORTSTrigger trg in ss.Triggers)
                {
                    if (trg is ORTSDiscreteTrigger discreteTrigger)
                        discreteTrigger.OnCarSoundEvent(null, new SoundSourceEventArgs(eventID, null));
                }
            }
        }

        public override void InitInitials()
        {
            if (Car != null)
            {
                WorldLocation = Car.WorldPosition.WorldLocation;
            }

            if (OutOfDistance())
            {
                if (!WasOutOfDistance)
                {
                    if (!viewer.Simulator.UpdaterWorking)
                    {
                        foreach (SoundStream stream in SoundStreams)
                            stream.HardDeactivate();
                        WasOutOfDistance = true;
                    }
                }
                NeedsFrequentUpdate = false;
            }
            else
            {
                if (WasOutOfDistance)
                {
                    var ignore3D = WorldLocation == WorldLocation.None | Ignore3D | !IsExternal;
                    foreach (SoundStream stream in SoundStreams)
                    {
                        stream.HardActivate(ignore3D);

                        bool released = false;
                        // run the initial triggers
                        foreach (ORTSTrigger trigger in stream.Triggers)
                        {
                            trigger.Initialize();
                            trigger.TryTrigger();

                            released |= trigger.Signaled &&
                                (trigger.SoundCommand is ORTSReleaseLoopRelease || trigger.SoundCommand is ORTSReleaseLoopReleaseWithJump);
                            if (trigger is ORTSDiscreteTrigger)
                                trigger.Signaled = false;
                        }

                        if (!released && !stream.ALSoundSource.IsPlaying)
                        {
                            foreach (ORTSTrigger trigger in stream.Triggers)
                            {
                                if (trigger.Signaled && trigger.Enabled && (trigger.SoundCommand is ORTSStartLoop || trigger.SoundCommand is ORTSStartLoopRelease))
                                    trigger.SoundCommand.Run();
                            }
                        }
                    }
                }
                WasOutOfDistance = false;
            }
        }

        public override bool Update()
        {
            if (Car != null && !Car.IsPartOfActiveTrain)
                return false;

            InitInitials();

            if (WasOutOfDistance)
            {
                // It is still needed to try out-of-distance variable triggers, to handle their start and release events, so they will be in
                // correct state when get into scope again. Discrete triggers have their HandleEvent() function to achieve this,
                // but there is no such thing for variable triggers.
                foreach (var stream in SoundStreams)
                    foreach (var trigger in stream.VariableTriggers)
                        trigger.TryTrigger();

                return true;
            }

            if (!Active)
            {
                if (Activate())
                {
                    Active = true;

                    // restore any looping sounds
                    foreach (SoundStream stream in SoundStreams)
                        stream.Activate();
                }
            }
            else
            {
                if (DeActivate())
                {
                    foreach (SoundStream stream in SoundStreams)
                        stream.Deactivate();

                    Active = false;
                }
            }

            bool needsFrequentUpdate = false;

            if (Car == null && WorldLocation != WorldLocation.None && !Ignore3D && IsExternal)
            {
                WorldLocation = WorldLocation.NormalizeTo(Camera.SoundBaseTile.X, Camera.SoundBaseTile.Y);
                float[] position = new float[] {
                    WorldLocation.Location.X,
                    WorldLocation.Location.Y,
                    WorldLocation.Location.Z};

                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update(position);
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            else
            {
                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update();
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            NeedsFrequentUpdate = needsFrequentUpdate;

            return true;
        } // Update

        /// <summary>
        /// Calculate current distance to camera, and compare it to <see cref="CutOffDistanceM2"/>
        /// </summary>
        /// <returns>True, if is now out-of-scope</returns>
        public bool OutOfDistance()
        {
            if (WorldLocation == WorldLocation.None)
            {
                DistanceSquared = 0;
                return false;
            }

            if (float.IsNaN(WorldLocation.Location.X) ||
                float.IsNaN(WorldLocation.Location.Y) ||
                float.IsNaN(WorldLocation.Location.Z))
            {
                DistanceSquared = float.MaxValue;
                return true;
            }

            DistanceSquared = (float)WorldLocation.GetDistanceSquared(WorldLocation, viewer.Camera.CameraWorldLocation);

            return DistanceSquared > CutOffDistanceM2;
        }

        /// <summary>
        /// Check if activation conditions are met,
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool Activate()
        {
            if (ActivationConditions == null)
                return false;

            if (ConditionsMet(ActivationConditions))
            {
                if (WorldLocation != WorldLocation.None)
                {
                    // (ActivationConditions.Distance == 0) means distance checking disabled
                    if ((ActivationConditions.Distance == 0 || DistanceSquared < ActivationConditions.Distance * ActivationConditions.Distance) &&
                        DistanceSquared < CutOffDistanceM2)
                        return true;
                }
                else
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Check if deactivation conditions are met
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool DeActivate()
        {
            if (DeactivationConditions == null)
                return false;

            if (ConditionsMet(DeactivationConditions))
                return true;

            if (WorldLocation != WorldLocation.None)
            {
                if (DeactivationConditions.Distance != 0 && DistanceSquared > DeactivationConditions.Distance * DeactivationConditions.Distance ||
                    DistanceSquared > CutOffDistanceM2)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns true if SoundSource belongs to a cabview of a vehicle not currently watched. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool IsntThisCabView
        {
            get
            {
                return (viewer.Camera.Style == Camera.Styles.Cab || viewer.Camera.Style == Camera.Styles.ThreeDimCab || viewer.Camera.Style == Camera.Styles.Passenger) && (viewer.Camera.AttachedCar != Car);
            }
        }

        /// <summary>
        /// Returns true if SoundSource is a weather sound. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool WeatherSound { get { return viewer.World.WeatherControl.WeatherSounds.Contains(this); } }

        /// <summary>
        /// Hack for enabling additional cab sounds (like radio sounds) of an attached (maybe invisible) car. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        /// <returns></returns>
        private bool IsInvisibleSoundCar
        {
            get
            {
                return (!IsEnvSound && !IsExternal && (viewer.Camera.Style == Camera.Styles.Cab || viewer.Camera.Style == Camera.Styles.ThreeDimCab)
                    && Car != null && viewer.Camera.AttachedCar != null && !(Car is MSTSLocomotive) && !Car.HasInsideView && Car.PassengerViewpoints == null
                    && (Car.Train == viewer.Camera.AttachedCar.Train || Car.Train.TrainType == TrainType.Static || Car.Train.TrainType == TrainType.AiNotStarted));
            }
        }

        /// <summary>
        /// Return true of the ViewPoint matches any of the ones specified in the conditions
        /// for activation or deactivation.
        /// </summary>
        /// <param name="conditions"></param>
        /// <returns></returns>
        private bool ConditionsMet(SoundActivationCondition conditions)
        {
            if (conditions == null)
                return false;

            Camera.Styles viewpoint = viewer.Camera.Style;

            if (IsEnvSound || !IsEnvSound && IsntThisCabView && !IsInvisibleSoundCar && !WeatherSound)
            {
                viewpoint = Camera.Styles.External;
            }

            if (conditions.CabCam && (viewpoint == Camera.Styles.Cab || viewpoint == Camera.Styles.ThreeDimCab))
                return true;
            if (conditions.PassengerCam && viewpoint == Camera.Styles.Passenger)
                return true;
            if (conditions.ExternalCam && viewpoint == Camera.Styles.External)
                return true;

            return false;
        }

        // To detect redundant calls
        private bool disposedValue;
        protected override void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    foreach (SoundStream soundStream in SoundStreams ?? Enumerable.Empty<SoundStream>())
                        soundStream.Dispose();
                    SoundStreams.Clear();
                    Car = null;
                }
                disposedValue = true;
            }
            base.Dispose(disposing);
        }
    }

    /////////////////////////////////////////////////////////
    // SOUND STREAM
    /////////////////////////////////////////////////////////

    /// <summary>
    /// Owned by a <see cref="SoundSource"/>,
    /// can play only one sound at a time,
    /// the sound played is controlled by the various triggers
    /// </summary>
    public class SoundStream : IDisposable
    {
        /// <summary>
        /// Owner SoundSource
        /// </summary>
        public SoundSource SoundSource;
        /// <summary>
        /// Stream's volume can be controlled independently of the SoundSource's
        /// </summary>
        public float Volume;
        /// <summary>
        /// List of triggers controlling this stream
        /// </summary>
        public List<ORTSTrigger> Triggers = new List<ORTSTrigger>();
        /// <summary>
        /// OpenAL compatible representation of SoundStream.
        /// By OpenAL terminilogy our SoundStream is called as "SoundSource"
        /// </summary>
        public ALSoundSource ALSoundSource { get; private set; }
        /// <summary>
        /// A stream as is represented in sms file
        /// </summary>
        protected SmsStream MSTSStream;
        /// <summary>
        /// Each stream can contain only one initial trigger, which should be audible
        /// in case the SoundSource is in scope, and no other variable trigger is active
        /// </summary>
        private ORTSInitialTrigger _InitialTrigger;
        /// <summary>
        /// If soundstream needs active management by sound process, or can be left to OpenAL
        /// </summary>
        public bool NeedsFrequentUpdate;
        /// <summary>
        /// If stream contains a release trigger with jump, looping cannot be handled fully by OpenAL.
        /// Sound process needs to watch carefully for jump command
        /// </summary>
        public bool IsReleasedWithJump;
        /// <summary>
        /// Store trigger used last time for being able to check if trigger got repeated
        /// </summary>
        public ORTSTrigger LastTriggered = new ORTSTrigger();
        /// <summary>
        /// True if the same trigger was used repeatedly.
        /// Needs for avoiding to queue same sound multiple times
        /// in case the player keeps hitting the keyboard
        /// </summary>
        public bool RepeatedTrigger;
        /// <summary>
        /// List of owned variable triggers. Used at determining if initial trigger is to be audible
        /// </summary>
        public List<ORTSVariableTrigger> VariableTriggers = new List<ORTSVariableTrigger>();

        /// <summary>
        /// Helper object for determining if initial trigger is to be audible
        /// </summary>
        private IEnumerable<ORTSTrigger> TriggersList;

        public SoundStream(SmsStream mstsStream, SoundEventSource eventSource, SoundSource soundSource)
        {
            SoundSource = soundSource;
            MSTSStream = mstsStream;
            Volume = MSTSStream.Volume;
            var rolloffFactor = SoundSource.RolloffFactor;

            // Insert lower RollOff for horns
            if (mstsStream.Triggers != null)
            {
                foreach (Trigger trigger in mstsStream.Triggers)
                    if (trigger is DiscreteTrigger && soundSource.Car != null && (trigger as DiscreteTrigger).TriggerId == 8)
                    {
                        rolloffFactor = SoundSource.HornRolloffFactor;
                        break;
                    }
            }

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, rolloffFactor);

            if (mstsStream.Triggers != null)
                foreach (Trigger trigger in mstsStream.Triggers)
                {
                    if (trigger.SoundCommand == null) // ignore improperly formed SMS files
                    {
                        Triggers.Add(new ORTSTrigger()); // null trigger
                    }
                    else if (trigger is DistanceTravelledTrigger distanceTrigger && soundSource.Car != null)
                    {
                        Triggers.Add(new ORTSDistanceTravelledTrigger(this, distanceTrigger));
                    }
                    else if (trigger is InitialTrigger initialTrigger)
                    {
                        _InitialTrigger = new ORTSInitialTrigger(this, initialTrigger);
                        Triggers.Add(_InitialTrigger);
                    }
                    else if (trigger is RandomTrigger randomTrigger)
                    {
                        Triggers.Add(new ORTSRandomTrigger(this, randomTrigger));
                    }
                    else if (trigger is VariableTrigger variableTrigger && (soundSource.Car != null || soundSource.IsEnvSound))
                    {
                        Triggers.Add(new ORTSVariableTrigger(this, variableTrigger));
                    }
                    else if (trigger is DiscreteTrigger discreteTrigger)
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, eventSource, discreteTrigger);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable
                        if (SoundSource.Car != null)
                            SoundSource.Car.OnCarSound += ortsTrigger.OnCarSoundEvent; // tell the simulator to call us when the event occurs
                    }
                    // unapplicable trigger type
                    else
                    {
                        Triggers.Add(new ORTSTrigger()); // null trigger
                        if (SoundSource.SMSFileName != "ingame.sms")
                            Trace.TraceWarning("Trigger type of trigger number {2} in stream number {1} in file {0} is not existent or not applicable",
SoundSource.SMSFileName, SoundSource.SoundStreams.Count, Triggers.Count - 1);
                    }
                    IsReleasedWithJump |= (Triggers.Last().SoundCommand is ORTSReleaseLoopReleaseWithJump);
                }  // for each mstsStream.Trigger

            VariableTriggers = Triggers.OfType<ORTSVariableTrigger>().ToList();
        }

        public SoundStream(string wavFileName, SoundEventSource eventSource, SoundSource soundSource)
        {
            SoundSource = soundSource;
            Volume = 1.0f;

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, soundSource.RolloffFactor);

            _InitialTrigger = new ORTSInitialTrigger(this, wavFileName);
            Triggers.Add(_InitialTrigger);

        }

        /// <summary>
        /// Create a sound stream with an arbitrary set of triggers.
        /// </summary>
        /// <param name="soundSource">The parent sound source.</param>
        /// <param name="makeTriggers">A generator function to create the triggers.</param>
        public SoundStream(SoundSource soundSource, Func<SoundStream, IEnumerable<ORTSTrigger>> makeTriggers)
        {
            SoundSource = soundSource;
            Volume = 1.0f;

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, soundSource.RolloffFactor);
            Triggers.AddRange(makeTriggers(this));
        }

        /// <summary>
        /// Update OpenAL sound source position, then calls the main <see cref="Update()"/> function
        /// Position is relative to camera tile's center
        /// </summary>
        /// <param name="position"></param>
        public void Update(float[] position)
        {
            OpenAL.Sourcefv(ALSoundSource.SoundSourceID, OpenAL.AL_POSITION, position);
            Update();
        }

        /// <summary>
        /// Try triggers, update frequency and volume according to curves, call queue management
        /// </summary>
        public void Update()
        {
            if (ALSoundSource == null)
            {
                return;
            }

            foreach (ORTSTrigger trigger in Triggers)
                trigger.TryTrigger();

            if (_InitialTrigger != null)
            {
                // If no triggers active, Initialize the Initial
                if (!ALSoundSource.IsPlaying)
                {
                    if (VariableTriggers.Count > 0 || Triggers.Count == 1)
                    {
                        TriggersList = from ORTSVariableTrigger t in VariableTriggers
                                       where t.IsBellow
                                       select t as ORTSTrigger;
                        if (TriggersList.Count() == VariableTriggers.Count && _InitialTrigger.SoundCommand is ORTSSoundPlayCommand
                            && !(_InitialTrigger.SoundCommand is ORTSPlayOneShot && _InitialTrigger.Signaled))
                        {
                            _InitialTrigger.Initialize();
                        }
                    }
                }
                // If triggers are active, reset the Initial
                else
                {
                    TriggersList = from t in Triggers
                                   where t.Signaled &&
                                   (t.SoundCommand is ORTSStartLoop || t.SoundCommand is ORTSStartLoopRelease)
                                   select t;
                    if (TriggersList.Count() > 1 && _InitialTrigger.Signaled)
                        _InitialTrigger.Signaled = false;
                }
            }

            SetFreqAndVolume();

            ALSoundSource.Update();
            NeedsFrequentUpdate |= ALSoundSource.NeedsFrequentUpdate;
        }

        /// <summary>
        /// Calculate frequency and volume according to curves defined in sms file
        /// </summary>
        private void SetFreqAndVolume()
        {
            if (ALSoundSource == null)
                return;

            if (MSTSStream != null && MSTSStream.FrequencyCurve != null)
            {
                if (SoundSource.Car != null || Program.Viewer.Camera.AttachedCar != null)
                {
                    float x = 0;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Mode, SoundSource.Car);
                    else if (Program.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Mode, (MSTSWagon)Program.Viewer.Camera.AttachedCar);
                    float y = Interpolate(x, MSTSStream.FrequencyCurve);
                    if (SoundSource.MstsMonoTreatment && ALSoundSource.MstsMonoTreatment)
                        y *= 2;

                    ALSoundSource.PlaybackSpeed = y / ALSoundSource.SampleRate;
                    NeedsFrequentUpdate = x != 0;
                }
            }

            float volume = SoundSource.Volume * Volume;

            if (MSTSStream != null && MSTSStream.VolumeCurves.Count > 0)
                for (int i = 0; i < MSTSStream.VolumeCurves.Count; i++)
                {
                    float x;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Mode, SoundSource.Car);
                    else if (Program.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Mode, (MSTSWagon)Program.Viewer.Camera.AttachedCar);
                    else
                        x = SoundSource.DistanceSquared;

                    volume *= Interpolate(x, MSTSStream.VolumeCurves[i]);
                }

            if (SoundSource.IsExternal && Program.Viewer.Camera.Style != Camera.Styles.External && !SoundSource.IsUnattenuated)
            {
                if (Program.Viewer.Camera.AttachedCar == null || ((MSTSWagon)Program.Viewer.Camera.AttachedCar).ExternalSoundPassThruPercent == -1)
                    volume *= Program.Viewer.Settings.ExternalSoundPassThruPercent * 0.01f;
                else
                    volume *= ((MSTSWagon)Program.Viewer.Camera.AttachedCar).ExternalSoundPassThruPercent * 0.01f;
            }

            ALSoundSource.Volume = volume;
        }

        /// <summary>
        /// There must be at least two points in the curve
        /// // TODO do we need to implement support for Granularity()
        /// </summary>
        /// <param name="x"></param>
        /// <param name="Curve"></param>
        /// <returns></returns>
        private static float Interpolate(float x, Curve Curve)
        {
            if (Curve.CurvePoints.Length < 2)
                return Curve.CurvePoints[0].Y;

            CurvePoint[] curvePoints = Curve.CurvePoints;

            if (x < curvePoints[0].X)
                return curvePoints[0].Y;
            if (x > curvePoints[curvePoints.Length - 1].X)
                return curvePoints[curvePoints.Length - 1].Y;

            int i = 1;
            while (i < curvePoints.Length - 1
                && curvePoints[i].X < x)
                ++i;
            // i points to the point equal to or above x, or to the last point in the table

            x -= curvePoints[i - 1].X;
            float rx = x / (curvePoints[i].X - curvePoints[i - 1].X);

            float dy = curvePoints[i].Y - curvePoints[i - 1].Y;

            float y = curvePoints[i - 1].Y + rx * dy;

            return y;
        }

        /// <summary>
        /// Read a variable from the attached TrainCar data
        /// </summary>
        /// <param name="control"></param>
        /// <param name="car"></param>
        /// <returns></returns>
        private float ReadValue(Curve.ControlMode control, MSTSWagon car)
        {
            switch (control)
            {
                case Curve.ControlMode.Distance:
                    return SoundSource.DistanceSquared;
                case Curve.ControlMode.Speed:
                    return car.AbsSpeedMpS;
                case Curve.ControlMode.Variable1:
                    return car.Variable1;
                case Curve.ControlMode.Variable2:
                    return car.Variable2;
                case Curve.ControlMode.Variable3:
                    return car.Variable3;
                case Curve.ControlMode.BrakeCylinder:
                    return car.BrakeSystem.GetCylPressurePSI();
                case Curve.ControlMode.CurveForce:
                    return (float)car.CurveForceFiltered;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// Stop OpenAL playing this stream, and flush buffers
        /// </summary>
        public void Stop()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Stop();
            }
        }

        /// <summary>
        /// Restore any previously playing sounds
        /// </summary>
        public void Activate()
        {
            if (ALSoundSource != null)
            {
                // Precalc volume to avoid glitches
                SetFreqAndVolume();
                ALSoundSource.Active = true;
            }
        }

        /// <summary>
        /// Deactivates a previously active sound
        /// </summary>
        public void Deactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Active = false;
                ALSoundSource.HardDeactivate();
            }
        }

        /// <summary>
        /// Allocates a new sound source ID in OpenAL, if one is not allocated yet.
        /// </summary>
        /// <param name="ignore3D">Whether the stream's world position should be ignored</param>
        public void HardActivate(bool ignore3D)
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardActivate(ignore3D, SoundSource.TrainCar);
            }
        }

        /// <summary>
        /// Frees up the allocated sound source ID, and tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        public void HardDeactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardDeactivate();
            }
            Sweep();
        }

        public void Dispose()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardDeactivate();
                ALSoundSource.Dispose();
                ALSoundSource = null;
            }
            Sweep();
        }

        /// <summary>
        /// Tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        private void Sweep()
        {
            foreach (var trigger in Triggers)
                if (trigger.SoundCommand is ORTSSoundPlayCommand)
                    foreach (var name in (trigger.SoundCommand as ORTSSoundPlayCommand).Files)
                        SoundItem.Sweep(name, SoundSource.IsExternal, IsReleasedWithJump);
        }

    } // class ORTSStream

    /////////////////////////////////////////////////////////
    // SOUND TRIGGERS
    /////////////////////////////////////////////////////////

    /// <summary>
    /// Trigger is defined in the SMS file as members of a SoundStream.
    /// They are activated by various events.
    /// When triggered, executes a SoundCommand
    /// </summary>
    public class ORTSTrigger
    {
        /// <summary>
        /// Set by the DisableTrigger, EnableTrigger sound commands
        /// </summary>
        public bool Enabled = true;
        /// <summary>
        /// True if trigger activation conditions are met
        /// </summary>
        public bool Signaled;
        /// <summary>
        /// Represents a sound command to be executed, when trigger is activated
        /// </summary>
        public ORTSSoundCommand SoundCommand;

        /// <summary>
        /// Check in every update loop whether to activate the trigger
        /// </summary>
        public virtual void TryTrigger() { }
        /// <summary>
        /// Executed in constructors, or when sound source gets into scope, or for InitialTrigger when other VariableTriggers stop working
        /// </summary>
        public virtual void Initialize() { }
    }


    /// <summary>
    /// Play this sound when a discrete TrainCar event occurs in the simulator
    /// </summary>
    public class ORTSDiscreteTrigger : ORTSTrigger
    {
        /// <summary>
        /// Event this trigger listens to
        /// </summary>
        public TrainEvent TriggerID;
        /// <summary>
        /// Store the owning SoundStream
        /// </summary>
        private SoundStream SoundStream;
        /// <summary>
        /// This flag is set by Updater process, and is used by Sound process to activate the trigger
        /// </summary>
        private bool Triggered;

        public ORTSDiscreteTrigger(SoundStream soundStream, SoundEventSource eventSound, DiscreteTrigger smsData)
        {
            TriggerID = SoundEvent.From(eventSound, smsData.TriggerId);
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        /// <summary>
        /// Construct a discrete sound trigger with an arbitrary event trigger and sound command.
        /// </summary>
        /// <param name="soundStream">The parent sound stream.</param>
        /// <param name="triggerID">The trigger to activate this event.</param>
        /// <param name="soundCommand">The command to run when activated.</param>
        public ORTSDiscreteTrigger(SoundStream soundStream, TrainEvent triggerID, ORTSSoundCommand soundCommand)
        {
            TriggerID = triggerID;
            SoundCommand = soundCommand;
            SoundStream = soundStream;
        }

        /// <summary>
        /// Check if this trigger listens to an event, and if also belongs to the object
        /// </summary>
        /// <param name="trainEvent">Occured event</param>
        /// <param name="viewer">Object the event belongs to</param>
        internal void OnCarSoundEvent(object sender, SoundSourceEventArgs e)
        {
            if (e.SoundEvent == TriggerID)
            {
                Triggered = e.Owner == null || Program.Viewer.SoundProcess.IsSoundSourceOwnedBy(e.Owner, SoundStream.SoundSource);
            }
        }

        public override void TryTrigger()
        {
            Triggered &= Enabled;
            if (Triggered)
            {
                Triggered = false;
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
                Signaled = true;
#if DEBUGSCR
                if (SoundCommand is ORTSSoundPlayCommand && !string.IsNullOrEmpty((SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]))
                    Trace.WriteLine("({0})DiscreteTrigger: {1}:{2}", SoundStream.ALSoundSource.SoundSourceID, TriggerID, (SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]);
                else
                    Trace.WriteLine("({0})DiscreteTrigger: {1}", SoundStream.ALSoundSource.SoundSourceID, TriggerID);
#endif
            }
            // If the SoundSource is not active, should deactivate the SoundStream also
            //   preventing the hearing when not should be audible
            if (!SoundStream.SoundSource.Active)
                SoundStream.Deactivate();
        }

    } // class ORTSDiscreteTrigger

    /// <summary>
    /// Play this sound controlled by the distance a TrainCar has travelled
    /// </summary>
    public sealed class ORTSDistanceTravelledTrigger : ORTSTrigger
    {
        private DistanceTravelledTrigger SMS;
        private float triggerDistance;
        private TrainCar car;
        private SoundStream SoundStream;

        public ORTSDistanceTravelledTrigger(SoundStream soundStream, DistanceTravelledTrigger smsData)
        {
            SoundStream = soundStream;
            car = soundStream.SoundSource.Car;
            SMS = smsData;
            SoundCommand = ORTSSoundCommand.FromMSTS(SMS.SoundCommand, soundStream);
            Initialize();
        }

        public override void Initialize()
        {
            UpdateTriggerDistance();
        }

        public override void TryTrigger()
        {
            if (car.DistanceTravelled > triggerDistance)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)StaticRandom.NextDouble() * (SMS.MaximumVolume - SMS.MinimumVolume) + SMS.MinimumVolume;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerDistance();
#if DEBUGSCR
                Trace.WriteLine("({0})DistanceTravelledTrigger: Current:{1}, Next:{2}", SoundStream.ALSoundSource.SoundSourceID, car.DistanceM, triggerDistance);
#endif

            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate a new random distance to travel till the next trigger action
        /// </summary>
        private void UpdateTriggerDistance()
        {
            if (SMS.MaximumDistance != SMS.MinimumDistance)
            {
                triggerDistance = car.DistanceTravelled + ((float)StaticRandom.NextDouble() * (SMS.MaximumDistance - SMS.MinimumDistance) + SMS.MinimumDistance);
            }
            else
            {
                triggerDistance = car.DistanceTravelled + ((float)StaticRandom.NextDouble() * (SMS.MinimumDistance) + SMS.MinimumDistance);
            }
        }

    } // class ORTSDistanceTravelledTrigger

    /// <summary>
    /// Play this sound immediately when this SoundSource becomes active, or in case no other VariableTriggers are active
    /// </summary>
    public class ORTSInitialTrigger : ORTSTrigger
    {
        private SoundStream SoundStream;

        public ORTSInitialTrigger(SoundStream soundStream, InitialTrigger smsData)
        {
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        // For pre-compiled activity sound
        public ORTSInitialTrigger(SoundStream soundStream, string wavFileName)
        {
            SoundCommand = ORTSSoundCommand.Precompiled(wavFileName, soundStream);
            SoundStream = soundStream;
        }

        public override void Initialize()
        {
            if (Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
#if DEBUGSCR
                if (SoundCommand is ORTSSoundPlayCommand && !string.IsNullOrEmpty((SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]))
                    Trace.WriteLine("({0})InitialTrigger: {1}", SoundStream.ALSoundSource.SoundSourceID, (SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]);
#endif
            }

            Signaled = true;
        }

    }

    /// <summary>
    /// Play the sound at random times
    /// </summary>
    public sealed class ORTSRandomTrigger : ORTSTrigger
    {
        private RandomTrigger SMS;
        private double triggerAtSeconds;
        private SoundStream SoundStream;

        public ORTSRandomTrigger(SoundStream soundStream, RandomTrigger smsData)
        {
            SoundStream = soundStream;
            SMS = smsData;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void Initialize()
        {
            UpdateTriggerAtSeconds();
        }

        public override void TryTrigger()
        {
            if (Simulator.Instance.ClockTime > triggerAtSeconds)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)StaticRandom.NextDouble() * (SMS.MaximumVolume - SMS.MinimumVolume) + SMS.MinimumVolume;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerAtSeconds();
            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate new random time till the next triggering action
        /// </summary>
        private void UpdateTriggerAtSeconds()
        {
            double interval = StaticRandom.NextDouble() * (SMS.MaximumDelay - SMS.MinimumDelay) + SMS.MinimumDelay;
            triggerAtSeconds = Simulator.Instance.ClockTime + interval;
        }

    }  // class RandomTrigger

    /// <summary>
    /// Control sounds based on TrainCar variables in the simulator 
    /// </summary>
    public sealed class ORTSVariableTrigger : ORTSTrigger
    {
        private VariableTrigger SMS;
        private MSTSWagon car;
        private SoundStream SoundStream;
        private float StartValue;
        public bool IsBellow;

        public ORTSVariableTrigger(SoundStream soundStream, VariableTrigger smsData)
        {
            SMS = smsData;
            car = soundStream.SoundSource.Car ?? (MSTSWagon)Program.Viewer.Camera.AttachedCar;
            SoundStream = soundStream;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void Initialize()
        {
            StartValue = SMS.Event == VariableTrigger.TriggerEvent.DistanceDecrease ? float.MaxValue : 0;

            /*if ((new Variable_Trigger.Events[] { Variable_Trigger.Events.Variable1_Dec_Past,
                Variable_Trigger.Events.Variable1_Inc_Past, Variable_Trigger.Events.Variable2_Dec_Past, 
                Variable_Trigger.Events.Variable2_Inc_Past, Variable_Trigger.Events.Variable3_Dec_Past,
                Variable_Trigger.Events.Variable3_Inc_Past}).Contains(SMS.Event) && SMS.Threshold >= 1)
            {
                SMS.Threshold /= 100f;
            }*/
            IsBellow = StartValue < SMS.Threshold;
        }

        public override void TryTrigger()
        {
            float newValue = ReadValue();
            bool triggered = false;
            Signaled = false;

            switch (SMS.Event)
            {
                case VariableTrigger.TriggerEvent.DistanceDecrease:
                case VariableTrigger.TriggerEvent.SpeedDecrease:
                case VariableTrigger.TriggerEvent.Variable1Decrease:
                case VariableTrigger.TriggerEvent.Variable2Decrease:
                case VariableTrigger.TriggerEvent.Variable3Decrease:
                case VariableTrigger.TriggerEvent.BrakeCylinderDecrease:
                case VariableTrigger.TriggerEvent.CurveForceDecrease:
                    if (newValue < SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold <= StartValue)
                            triggered = true;
                    }
                    break;
                case VariableTrigger.TriggerEvent.DistanceIncrease:
                case VariableTrigger.TriggerEvent.SpeedIncrease:
                case VariableTrigger.TriggerEvent.Variable1Increase:
                case VariableTrigger.TriggerEvent.Variable2Increase:
                case VariableTrigger.TriggerEvent.Variable3Increase:
                case VariableTrigger.TriggerEvent.BrakeCylinderIncrease:
                case VariableTrigger.TriggerEvent.CurveForceIncrease:
                    if (newValue > SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold >= StartValue)
                            triggered = true;
                    }
                    break;
            }

            //Signaled = triggered;

            StartValue = newValue;
            IsBellow = newValue < SMS.Threshold;

            if (triggered && Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;

#if DEBUGSCR
                ORTSStartLoop sl = SoundCommand as ORTSStartLoop;
                if (sl != null)
                {
                    Trace.WriteLine("({0})StartLoop ({1} {2}): {3} ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString(), sl.Files[sl.iFile]);
                }
                ORTSStartLoopRelease slr = SoundCommand as ORTSStartLoopRelease;
                if (slr != null)
                {
                    Trace.WriteLine("({0})StartLoopRelease ({1} {2}): {3} ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString(), slr.Files[slr.iFile]);
                }
                ORTSReleaseLoopRelease rlr = SoundCommand as ORTSReleaseLoopRelease;
                if (rlr != null)
                {
                    Trace.WriteLine("({0})ReleaseLoopRelease ({1} {2}) ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString());
                }
                ORTSReleaseLoopReleaseWithJump rlrwj = SoundCommand as ORTSReleaseLoopReleaseWithJump;
                if (rlrwj != null)
                {
                    Trace.WriteLine("({0})ReleaseLoopReleaseWithJump ({1} {2}) ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString());
                }
#endif
            }
        }

        /// <summary>
        /// Read the desired variable either from the attached TrainCar, or the distance to sound source
        /// </summary>
        /// <returns></returns>
        private float ReadValue()
        {
            switch (SMS.Event)
            {
                case VariableTrigger.TriggerEvent.DistanceDecrease:
                case VariableTrigger.TriggerEvent.DistanceIncrease:
                    return SoundStream.SoundSource.DistanceSquared;
                case VariableTrigger.TriggerEvent.SpeedDecrease:
                case VariableTrigger.TriggerEvent.SpeedIncrease:
                    return car.AbsSpeedMpS;
                case VariableTrigger.TriggerEvent.Variable1Decrease:
                case VariableTrigger.TriggerEvent.Variable1Increase:
                    return car.Variable1;
                case VariableTrigger.TriggerEvent.Variable2Decrease:
                case VariableTrigger.TriggerEvent.Variable2Increase:
                    return car.Variable2;
                case VariableTrigger.TriggerEvent.Variable3Decrease:
                case VariableTrigger.TriggerEvent.Variable3Increase:
                    return car.Variable3;
                case VariableTrigger.TriggerEvent.BrakeCylinderDecrease:
                case VariableTrigger.TriggerEvent.BrakeCylinderIncrease:
                    return car.BrakeSystem.GetCylPressurePSI();
                case VariableTrigger.TriggerEvent.CurveForceDecrease:
                case VariableTrigger.TriggerEvent.CurveForceIncrease:
                    return (float)car.CurveForceFiltered;
                default:
                    return 0;
            }
        }

    }  // class VariableTrigger


    /////////////////////////////////////////////////////////
    // SOUND COMMANDS
    /////////////////////////////////////////////////////////


    /// <summary>
    /// Start playing the whole sound stream once, then stop
    /// </summary>
    public class ORTSPlayOneShot : ORTSSoundPlayCommand
    {
        public ORTSPlayOneShot(SoundStream ortsStream, SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream, mstsSoundPlayCommand)
        {
        }
        // precompiled version for activity sounds
        public ORTSPlayOneShot(SoundStream ortsStream, string wavFileName)
            : base(ortsStream, wavFileName)
        {
        }

        public override void Run()
        {
            string p = GetNextFile();
            if (!string.IsNullOrEmpty(p))
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.OneShot, ORTSStream.SoundSource.IsExternal, ORTSStream.RepeatedTrigger);
            }
        }
    }

    /// <summary>
    /// Start looping the whole stream, release it only at the end
    /// </summary>
    public class ORTSStartLoop : ORTSSoundPlayCommand
    {
        public ORTSStartLoop(SoundStream ortsStream, SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream, mstsSoundPlayCommand)
        {
        }
        public override void Run()
        {
            // Support for Loop functions - by GeorgeS
            string p = GetNextFile();
            if (!string.IsNullOrEmpty(p))
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.Loop, ORTSStream.SoundSource.IsExternal, false);
            }
        }
    }

    /// <summary>
    /// Release the sound by playing the looped sustain part till its end, then play the last part
    /// </summary>
    public class ORTSReleaseLoopRelease : ORTSSoundCommand
    {
        public ORTSReleaseLoopRelease(SoundStream ortsStream)
            : base(ortsStream)
        {
        }

        public override void Run()
        {
            if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                ORTSStream.ALSoundSource.Queue("", PlayMode.Release, ORTSStream.SoundSource.IsExternal, false);
        }
    }

    /// <summary>
    /// Start by playing the first part, then start looping the sustain part of the stream
    /// </summary>
    public class ORTSStartLoopRelease : ORTSSoundPlayCommand
    {
        public ORTSStartLoopRelease(SoundStream ortsStream, SoundPlayCommand mstsStartLoopRelease)
            : base(ortsStream, mstsStartLoopRelease)
        {
        }

        // Support for Loop functions - by GeorgeS
        public override void Run()
        {
            string p = GetNextFile();
            if (!string.IsNullOrEmpty(p))
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.LoopRelease, ORTSStream.SoundSource.IsExternal, ORTSStream.IsReleasedWithJump);
            }
        }
    }

    /// <summary>
    /// Release the sound by playing the looped sustain part till the next cue point, then jump to the last part and play that  
    /// </summary>
    public class ORTSReleaseLoopReleaseWithJump : ORTSSoundCommand
    {
        public ORTSReleaseLoopReleaseWithJump(SoundStream ortsStream)
            : base(ortsStream)
        {
        }

        public override void Run()
        {
            if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                ORTSStream.ALSoundSource.Queue("", PlayMode.ReleaseWithJump, ORTSStream.SoundSource.IsExternal, true);
        }
    }

    /// <summary>
    /// Shut down this stream trigger 
    /// </summary>
    public class ORTSDisableTrigger : ORTSSoundCommand
    {
        private int TriggerIndex;  // index into the stream's trigger list 

        public ORTSDisableTrigger(SoundStream ortsStream, TriggerCommand smsData)
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerId - 1;
        }

        public override void Run()
        {
            if (TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = false;
        }
    }

    /// <summary>
    /// Re-enable this stream trigger
    /// </summary>
    public class ORTSEnableTrigger : ORTSSoundCommand
    {
        private int TriggerIndex;

        public ORTSEnableTrigger(SoundStream ortsStream, TriggerCommand smsData)
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerId - 1;
        }

        public override void Run()
        {
            if (TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = true;
        }
    }

    /// <summary>
    /// Set Volume of Stream
    /// </summary>
    public class ORTSSetStreamVolume : ORTSSoundCommand
    {
        private float Volume;

        public ORTSSetStreamVolume(SoundStream ortsStream, StreamVolumeCommand smsData)
            : base(ortsStream)
        {
            Volume = smsData.Volume;
        }

        public override void Run()
        {
            ORTSStream.Volume = Volume;
        }
    }

    /// <summary>
    /// Used when the SMS file sound command is missing or malformed
    /// </summary>
    public class ORTSNoOp : ORTSSoundCommand
    {
        public ORTSNoOp()
            : base(null)
        {
        }
        public override void Run()
        {
        }
    }

    /// <summary>
    /// A base class for all sound commands
    /// Defines that they all have a stream and a 'Run()' function
    /// </summary>
    public abstract class ORTSSoundCommand
    {
        /// <summary>
        /// The Stream in .sms file it belongs to
        /// </summary>
        protected SoundStream ORTSStream;

        protected ORTSSoundCommand(SoundStream ortsStream)
        {
            ORTSStream = ortsStream;
        }

        /// <summary>
        /// Put the command into stream's queue, or set its volume, or enable/disable other commands
        /// </summary>
        public abstract void Run();


        /// <summary>
        /// Create a sound command based on the sound command variable of a trigger in an SMS file.
        /// </summary>
        /// <param name="mstsSoundCommand"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand FromMSTS(SoundCommand mstsSoundCommand, SoundStream soundStream)
        {
            if (mstsSoundCommand == null)
            {
                return new ORTSNoOp();
            }
            else if (mstsSoundCommand is SoundPlayCommand playCommand)
            {
                switch (playCommand.CommandType)
                {
                    case SoundPlayCommand.SoundCommandType.PlayOneShot:
                        return new ORTSPlayOneShot(soundStream, playCommand);
                    case SoundPlayCommand.SoundCommandType.StartLoop:
                        return new ORTSStartLoop(soundStream, playCommand);
                    case SoundPlayCommand.SoundCommandType.StartLoopRelease:
                        return new ORTSStartLoopRelease(soundStream, playCommand);
                }
            }
            else if (mstsSoundCommand is LoopRelease releaseCommand)
            {
                switch (releaseCommand.ReleaseMode)
                {
                    case LoopRelease.ReleaseType.Release:
                        return new ORTSReleaseLoopRelease(soundStream);
                    case LoopRelease.ReleaseType.ReleaseWithJump:
                        return new ORTSReleaseLoopReleaseWithJump(soundStream);
                }
            }
            else if (mstsSoundCommand is StreamVolumeCommand)
            {
                return new ORTSSetStreamVolume(soundStream, (StreamVolumeCommand)mstsSoundCommand);
            }
            else if (mstsSoundCommand is TriggerCommand triggerCommand)
            {
                switch (triggerCommand.Trigger)
                {
                    case TriggerCommand.TriggerType.Disable:
                        return new ORTSDisableTrigger(soundStream, triggerCommand);
                    case TriggerCommand.TriggerType.Enable:
                        return new ORTSEnableTrigger(soundStream, triggerCommand);
                }
            }
            throw new ArgumentException("Unexpected soundCommand type " + mstsSoundCommand.GetType().ToString() + " in " + soundStream.SoundSource.SMSFolder, nameof(mstsSoundCommand));
        }


        /// <summary>
        /// Create a pre-compiled sound command for activity files.
        /// </summary>
        /// <param name="wavFilePath"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand Precompiled(string wavFileName, SoundStream soundStream)
        {
            return new ORTSPlayOneShot(soundStream, wavFileName);
        }

    }// ORTSSoundCommand


    /// <summary>
    /// A base class for commands that play a sound.
    /// Provides for selecting the sound from multiple files
    /// using a random or sequential selection strategy.
    /// </summary>
    public abstract class ORTSSoundPlayCommand : ORTSSoundCommand
    {
        /// <summary>
        /// File names to select from for playing
        /// </summary>
        public IList<string> Files { get; private set; }
        /// <summary>
        /// How to select from available files
        /// </summary>
        private readonly SoundPlayCommand.Selection selectionMethod;
        /// <summary>
        /// Index of the file to play inside <see cref="Files"/> vector
        /// </summary>
        private int fileIndex;

        protected ORTSSoundPlayCommand(SoundStream ortsStream, SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream)
        {
            Files = mstsSoundPlayCommand?.Files;
            selectionMethod = mstsSoundPlayCommand.SelectionMethod;
        }

        // precompiled version for activity sounds
        protected ORTSSoundPlayCommand(SoundStream ortsStream, string wavFileName)
            : base(ortsStream)
        {
            Files = new List<string>() { wavFileName };
            selectionMethod = SoundPlayCommand.Selection.Sequential;
        }

        /// <summary>
        /// Select a file from the Files list using the SelectionMethod
        /// </summary>
        /// <returns>File name with full path </returns>
        protected string GetNextFile()
        {
            if (selectionMethod == SoundPlayCommand.Selection.Sequential)
            {
                ++fileIndex;
                if (fileIndex >= Files.Count)
                    fileIndex = 0;
            }
            else if (selectionMethod == SoundPlayCommand.Selection.Random)
            {
                fileIndex = StaticRandom.Next(Files.Count);
            }

            string[] pathArray = {  Simulator.Instance.RouteFolder.SoundFolder,
                                    ORTSStream.SoundSource.SMSFolder,
                                    Simulator.Instance.RouteFolder.ContentFolder.SoundFolder };
            return FolderStructure.FindFileFromFolders(pathArray, Files[fileIndex]) ?? string.Empty;
        }
    }

    public class WorldSounds
    {
        private readonly Dictionary<string, IList<WorldSoundRegion>> soundRegions = new Dictionary<string, IList<WorldSoundRegion>>();
        private readonly Viewer viewer;
        private SoundSource soundSource;

        public WorldSounds(Viewer viewer)
        {
            this.viewer = viewer;
        }

        public int GetTType(Simulation.Physics.Train train, out float outPrevDist, out float outNextDist)
        {
            int retval = 0;
            Traveller traveller;
            Traveller tmp;
            outPrevDist = -1;
            outNextDist = -1;

            if (train.SpeedMpS >= 0)
            {
                traveller = new Traveller(train.FrontTDBTraveller);
            }
            else
            {
                traveller = new Traveller(train.RearTDBTraveller, true);
            }

            TrackDB trackDB = RuntimeData.Instance.TrackDB;
            List<TrackItem> trItems = trackDB.TrackItems;

            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;

            float prevDist = float.MaxValue;
            float nextDist = float.MaxValue;
            float d;

            lock (soundRegions)
            {
                // Check every sound region's all track nodes
                foreach (List<WorldSoundRegion> lwsr in soundRegions.Values)
                {
                    foreach (WorldSoundRegion wsr in lwsr)
                    {
                        foreach (int trNode in wsr.TrackNodes)
                        {
                            if (trItems[trNode] is SoundRegionItem)
                            {
                                tmp = new Traveller(traveller);

                                // Try to find forward
                                d = tmp.DistanceTo(trItems[trNode].Location, 8192);

                                if (d != -1)
                                {
                                    // This is nearer than previous one
                                    if (d < nextDist)
                                    {
                                        nextDist = d;
                                        nextItem = wsr;
                                    }
                                    // Or at exactly the same distance
                                    else if (d == nextDist)
                                    {
                                        if (traveller.Direction == tmp.Direction)
                                            tmp.ReverseDirection();

                                        // If faces toward us then it is applicable
                                        if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                        {
                                            nextDist = d;
                                            nextItem = wsr;
                                        }
                                    }
                                }
                                else
                                {
                                    // Not found forward, check backward
                                    tmp = new Traveller(traveller, true);

                                    d = tmp.DistanceTo(trItems[trNode].Location, 8192);
                                    if (d != -1)
                                    {
                                        // It is nearer than previous
                                        if (d < prevDist)
                                        {
                                            prevDist = d;
                                            prevItem = wsr;
                                        }
                                        else if (d == prevDist)
                                        {
                                            if (traveller.Direction != tmp.Direction)
                                                tmp.ReverseDirection();

                                            // Applicable if faces with us
                                            if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                            {
                                                prevDist = d;
                                                prevItem = wsr;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Have before and behind us
            if (prevItem != null && nextItem != null)
            {
                // Between same type, means we are in a sound region
                if (prevItem.TrackType == nextItem.TrackType)
                {
                    // return one of those, doesn't matter which.
                    retval = prevItem.TrackType;
                    outPrevDist = prevDist;
                    outNextDist = nextDist;
                }
                else if (nextDist < 10)
                {
                    // We are between different regions and the next is very near
                    // This case we won't change to default, unnecessary to that short period of time
                    // int.MaxValue means do not change the current region even if we left it
                    retval = int.MaxValue;
                }
                //  they are different types and far from each other
                //  So we are in a neutral zone, retval is 0, default track type
            }
            else if (prevItem != null)
            {
                // only one, take it!
                retval = prevItem.TrackType;
                outPrevDist = prevDist;
            }
            else if (nextItem != null)
            {
                // only one, take it!
                retval = nextItem.TrackType;
                outNextDist = nextDist;
            }
            //  - Missing items before or behind us, maintain last sound
            else
            {
                retval = int.MaxValue;
            }
            return retval;
        }

        public void AddByTile(int TileX, int TileZ)
        {
            string name = Path.Combine(Simulator.Instance.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(TileX, TileZ) + "s");
            WorldSoundFile wf = new WorldSoundFile(name, RuntimeData.Instance.TrackDB.TrackItems.Count);
            if (wf.TrackItemSound != null)
            {
                string[] pathArray = { Simulator.Instance.RouteFolder.SoundFolder, Simulator.Instance.RouteFolder.ContentFolder.SoundFolder };

                var ls = new List<SoundSourceBase>();
                foreach (var fss in wf.TrackItemSound.SoundSources)
                {
                    WorldLocation wl = new WorldLocation(TileX, TileZ, fss.Position);
                    var fullPath = FolderStructure.FindFileFromFolders(pathArray, fss.FileName);
                    if (fullPath != null)
                    {
                        soundSource = new SoundSource(wl, SoundEventSource.None, fullPath, true);
                        ls.Add(soundSource);
                    }
                }
                viewer.SoundProcess.AddSoundSources(name, ls);

                lock (soundRegions)
                {
                    if (!soundRegions.ContainsKey(name))
                    {
                        soundRegions.Add(name, wf.TrackItemSound.SoundRegions);
                    }
                }
            }
        }

        public void RemoveByTile(int TileX, int TileZ)
        {
            string name = Path.Combine(viewer.Simulator.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(TileX, TileZ) + "s");
            viewer.SoundProcess.RemoveSoundSources(name);
            lock (soundRegions)
            {
                if (soundRegions.ContainsKey(name))
                {
                    soundRegions.Remove(name);
                }
            }
        }
    }

    public class ORTSActSoundSources
    {
        public ORTSActSoundSources()
        {
        }

        public void Update()
        {
            if (Simulator.Instance.ActivityRun == null || Simulator.Instance.ActivityRun.TriggeredActivityEvent == null ||
                (Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.SoundFile == null && (Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes == null
                || Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes.ActivitySound == null)))
                return;
            var localEventID = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.ID;
            string ORTSActSoundFile;
            OrtsActivitySoundFileType ORTSActSoundFileType;
            ActivitySound activitySound = null;
            if (Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes == null
                || Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes.ActivitySound == null)
            {
                ORTSActSoundFile = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.SoundFile;
                ORTSActSoundFileType = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.SoundFileType;
            }
            else
            {
                activitySound = Simulator.Instance.ActivityRun.TriggeredActivityEvent.ActivityEvent.Outcomes.ActivitySound;
                ORTSActSoundFile = activitySound.SoundFile;
                ORTSActSoundFileType = activitySound.SoundFileType;
            }
            var train = Simulator.Instance.ActivityRun.TriggeredActivityEvent.Train;
            Simulator.Instance.ActivityRun.TriggeredActivityEvent = null;
            var extension = Path.GetExtension(ORTSActSoundFile);
            SoundSource ActivitySounds;
            switch (extension)
            {
                case ".sms":
                    switch (ORTSActSoundFileType)
                    {
                        case OrtsActivitySoundFileType.Everywhere:
                            ActivitySounds = new SoundSource(SoundEventSource.InGame, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(playerLoco, Program.Viewer.World.Trains.GetViewer(playerLoco), ORTSActSoundFile);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Pass:
                            if (Program.Viewer.Camera.Style == Camera.Styles.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(selectedWagon, Program.Viewer.World.Trains.GetViewer(selectedWagon), ORTSActSoundFile);
                                Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            }
                            break;
                        case OrtsActivitySoundFileType.Ground:
                            var loco = (train == Program.Viewer.Simulator.PlayerLocomotive.Train) ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];
                            //                            string wsName = Program.Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(worldLocation.TileX, worldLocation.TileZ) + "s";
                            ActivitySounds = new SoundSource(loco.WorldPosition.WorldLocation.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Location:
                            ActivitySounds = new SoundSource(activitySound.Location.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        default:
                            break;
                    }
                    break;
                case ".wav":
                    switch (ORTSActSoundFileType)
                    {
                        case OrtsActivitySoundFileType.Everywhere:
                            ActivitySounds = new SoundSource(SoundEventSource.InGame, ORTSActSoundFile, ORTSActSoundFileType, true, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(playerLoco, ORTSActSoundFile, ORTSActSoundFileType, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Pass:
                            if (Program.Viewer.Camera.Style == Camera.Styles.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(selectedWagon, ORTSActSoundFile, ORTSActSoundFileType, true);
                                Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            }
                            break;
                        case OrtsActivitySoundFileType.Ground:
                            var loco = (train == Program.Viewer.Simulator.PlayerLocomotive.Train) ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];
                            //                           string wsName = Program.Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(worldLocation.TileX, worldLocation.TileZ) + "s";
                            ActivitySounds = new SoundSource(loco.WorldPosition.WorldLocation.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true, ORTSActSoundFileType, true);// Sound does not come from earth!
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Location:
                            ActivitySounds = new SoundSource(activitySound.Location.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true, ORTSActSoundFileType, true);// Sound does not come from earth!
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            return;
        }
    }
}

