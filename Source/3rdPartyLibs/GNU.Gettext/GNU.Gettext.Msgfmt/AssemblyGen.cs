using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.Globalization;
using System.CodeDom.Compiler;
using System.Diagnostics;
using Microsoft.CSharp;

using GNU.Gettext;

namespace GNU.Gettext.Msgfmt
{
    public class AssemblyGen
    {
        private IndentedTextWriter cw;
        private StringWriter sw;
		private Catalog catalog;

        public Dictionary<string, string> Entries { get; private set; }
		public string CsharpSourceFileName { get; private set; }
		public string AssemblyOutDir  { get; private set; }
		public Options Options { get; private set; }
		public string ClassName { get; private set; }

		#region Constructors
        public AssemblyGen(Options options)
        {
            sw = new StringWriter();
            cw = new IndentedTextWriter(sw);
			this.Options = options;
			ClassName = GettextResourceManager.MakeResourceSetClassName(Options.BaseName, Options.Locale);
//            CsharpSourceFileName = Path.Combine(
//				Options.OutDir,
//                String.Format("{0}.{1}.resources.cs", Options.BaseName, Options.Locale.Name));
            CsharpSourceFileName = Path.GetTempFileName();
        }
		#endregion

        public void Run()
        {
			catalog = new Catalog();
			catalog.Load(Options.InputFiles[0]);
			for(int i = 1; i < Options.InputFiles.Count; i++)
			{
				Catalog temp = new Catalog();
				temp.Load(Options.InputFiles[i]);
				catalog.Append(temp);
			}
			Check();
			Generate();
			SaveToFile();
			Compile();
			if (!Options.DebugMode)
				File.Delete(CsharpSourceFileName);
        }
		
		private void Check()
		{
			if (!Options.CheckFormat)
				return;
			foreach(CatalogEntry entry in catalog)
			{
				if (entry.IsInFormat("csharp"))
				{
					ValidateFormatString(entry.String);
					ValidateFormatString(entry.PluralString);
					for (int i = 0; i < entry.TranslationsCount; i++)
						ValidateFormatString(entry.GetTranslation(i));
				}
			}
		}
		
		private void ValidateFormatString(string s)
		{
			FormatValidator v = new FormatValidator(s);
			FormatValidateResult result = v.Validate();
			if (!result.Result)
			{
				throw new FormatException(String.Format("Invalid sting format: '{0}'\n{1}", s, result.ErrorMessage));
			}
		}

		private void Generate()
		{
			cw.WriteLine("// This file was generated by GNU msgfmt at {0}", DateTime.Now);
			cw.WriteLine("// Do not modify it!");
			cw.WriteLine();
			cw.WriteLine("using GNU.Gettext;");
			cw.WriteLine();

			/* Assign a strong name to the assembly, so that two different localizations
			 * of the same domain can be loaded one after the other.  This strong name
			 * tells the Global Assembly Cache that they are meant to be different.
			 */
			cw.WriteLine("[assembly: System.Reflection.AssemblyCulture(\"{0}\")]", Options.Locale.Name);

			if (Options.HasNamespace)
			{
				cw.WriteLine("namespace {0}", Options.BaseName);
				cw.WriteLine("{");
				cw.Indent++;
			}

			cw.WriteLine("public class {0} : {1}",
                ClassName,
                typeof(GettextResourceSet).FullName);
            cw.WriteLine("{");
			cw.Indent++;

			// Constructor
			cw.WriteLine("public {0} () : base()", ClassName);
			cw.WriteLine("{ }");
			cw.WriteLine();

			cw.WriteLine("private bool TableInitialized;");
			cw.WriteLine();
			
			if (catalog.HasHeader(Catalog.PluralFormsHeader))
			{
				cw.WriteLine("public override string PluralForms {{ get {{ return {0}; }} }}", ToConstStr(catalog.GetPluralFormsHeader()));
				cw.WriteLine();
			}

			cw.WriteLine("protected override void ReadResources() {");
			/* In some implementations, such as mono < 2009-02-27, the ReadResources
			 * method is called just once, when Table == null.  In other implementations,
			 * such as mono >= 2009-02-27, it is called at every GetObject call, and it
			 * is responsible for doing the initialization only once, even when called
			 * simultaneously from multiple threads.
			 */
			cw.Indent++; cw.WriteLine("if (!TableInitialized) {");
			cw.Indent++; cw.WriteLine("lock (this) {");
			cw.Indent++; cw.WriteLine("if (!TableInitialized) {");
			/* In some implementations, the ResourceSet constructor initializes Table
			 * before calling ReadResources().  In other implementations, the
			 * ReadResources() method is expected to initialize the Table.  */
			cw.Indent++; cw.WriteLine("if (Table == null)");
			cw.Indent++; cw.WriteLine("Table = new System.Collections.Hashtable();");
			cw.Indent--; cw.WriteLine("System.Collections.Hashtable t = Table;");
			foreach(CatalogEntry entry in catalog)
			{
			  cw.WriteLine("t.Add({0}, {1});", ToMsgid(entry), ToMsgstr(entry));
			}
			cw.WriteLine("TableInitialized = true;");
			cw.Indent--; cw.WriteLine("}");
			cw.Indent--; cw.WriteLine("}");
			cw.Indent--; cw.WriteLine("}");
			cw.Indent--; cw.WriteLine("}");
			cw.WriteLine();

			// Emit the msgid_plural strings. Only used by msgunfmt.
			if (catalog.PluralFormsCount > 0)
			{
				cw.WriteLine("public static System.Collections.Hashtable GetMsgidPluralTable() {");
				cw.Indent++; cw.WriteLine("System.Collections.Hashtable t = new System.Collections.Hashtable();");
				foreach(CatalogEntry entry in catalog)
				{
					if (entry.HasPlural)
					{
				        cw.WriteLine("t.Add({0}, {1});", ToMsgid(entry), ToMsgstr(entry));
					}
				}
				cw.WriteLine("return t;");
				cw.Indent--; cw.WriteLine("}");
			}

			cw.Indent--;
            cw.WriteLine("}");

			if (Options.HasNamespace)
			{
				cw.Indent--;
				cw.WriteLine("}");
			}

		}

		private void SaveToFile()
		{
            using (StreamWriter writer = new StreamWriter(CsharpSourceFileName, false, Encoding.UTF8))
            {
                writer.WriteLine(sw.ToString());
            }

			AssemblyOutDir = Path.Combine(Path.GetFullPath(Options.OutDir), Options.Locale.Name);
			if (!Directory.Exists(AssemblyOutDir))
				Directory.CreateDirectory(AssemblyOutDir);
			if (!Directory.Exists(AssemblyOutDir))
				throw new Exception(String.Format("Error creating output directory {0}", AssemblyOutDir));
		}


		private void Compile()
		{
            if (File.Exists(GettextResourceManager.GetSatelliteAssemblyName(Options.BaseName)))
                File.Delete(GettextResourceManager.GetSatelliteAssemblyName(Options.BaseName));

            CompilerParameters cp = new CompilerParameters();
            cp.GenerateExecutable = false;
            cp.OutputAssembly = GettextResourceManager.GetSatelliteAssemblyName(Options.BaseName);
            cp.IncludeDebugInformation = false;
            cp.ReferencedAssemblies.Add("GNU.Gettext.dll");
            cp.GenerateInMemory = false;
            cp.CompilerOptions = "-optimize+";

            CSharpCodeProvider Compiler = new CSharpCodeProvider(new Dictionary<string, string>() { { "CompilerVersion", "v3.5" } });
            CompilerResults cr = Compiler.CompileAssemblyFromFile(cp, CsharpSourceFileName);

            if (!cr.Errors.HasErrors)
            {
                if (File.Exists(Path.Combine(AssemblyOutDir, GettextResourceManager.GetSatelliteAssemblyName(Options.BaseName))))
                    File.Delete(Path.Combine(AssemblyOutDir, GettextResourceManager.GetSatelliteAssemblyName(Options.BaseName)));
                File.Move(GettextResourceManager.GetSatelliteAssemblyName(Options.BaseName), Path.Combine(AssemblyOutDir, GettextResourceManager.GetSatelliteAssemblyName(Options.BaseName)));
            }
            else
            {
                String error = "Assembly compilation failed.";
                foreach (CompilerError er in cr.Errors)
                    error += "\n" + cr.Output;
                throw new Exception(error);
            }
		}


		static string ToConstStr(string s)
		{
			return String.Format("@\"{0}\"", s.Replace("\"", "\"\""));
		}

		static string ToMsgid(CatalogEntry entry)
		{
			return ToConstStr(
				entry.HasContext ? 
				GettextResourceManager.MakeContextMsgid(entry.Context, entry.String) : entry.String);
		}


		/// <summary>
		/// Write C# code that returns the value for a message.  If the message
		/// has plural forms, it is an expression of type System.String[], otherwise it
		/// is an expression of type System.String.
		/// </summary>
		/// <returns>
		/// The expression (string or string[]) to initialize hashtable associated object.
		/// </returns>
		/// <param name='entry'>
		/// Catalog entry.
		/// </param>
		static string ToMsgstr(CatalogEntry entry)
		{
			StringBuilder sb = new StringBuilder();
			if (entry.HasPlural)
			{
				sb.Append("new System.String[] { ");
				for(int i = 0; i < entry.TranslationsCount; i++)
				{
					if (i > 0)
						sb.Append(", ");
					sb.Append(ToConstStr(entry.GetTranslation(i)));
				}
				sb.Append(" }");
			}
			else
			{
				sb.Append(ToConstStr(entry.GetTranslation(0)));
			}
			return sb.ToString();
		}

    }
}
