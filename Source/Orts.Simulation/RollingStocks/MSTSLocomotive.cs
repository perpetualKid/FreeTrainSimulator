// COPYRIGHT 2009, 2010, 2011, 2012, 2013 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

/* LOCOMOTIVE CLASSES
 * 
 * Used as a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  MSTSLocomotive - defines the behaviour, ie physics, motion, power generated etc
 *  MSTSLocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCar - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

using FreeTrainSimulator.Common;
using FreeTrainSimulator.Common.Calc;
using FreeTrainSimulator.Common.DebugInfo;

using Microsoft.Xna.Framework;

using Orts.Formats.Msts;
using Orts.Formats.Msts.Files;
using Orts.Formats.Msts.Models;
using Orts.Formats.Msts.Parsers;
using Orts.Models.State;
using Orts.Simulation.Commanding;
using Orts.Simulation.Multiplayer;
using Orts.Simulation.Multiplayer.Messaging;
using Orts.Simulation.Physics;
using Orts.Simulation.RollingStocks.SubSystems;
using Orts.Simulation.RollingStocks.SubSystems.Brakes;
using Orts.Simulation.RollingStocks.SubSystems.Brakes.MSTS;
using Orts.Simulation.RollingStocks.SubSystems.Controllers;
using Orts.Simulation.RollingStocks.SubSystems.ControlSystems;
using Orts.Simulation.RollingStocks.SubSystems.PowerSupplies;
using Orts.Simulation.RollingStocks.SubSystems.PowerTransmissions;

namespace Orts.Simulation.RollingStocks
{
    /// <summary>
    /// Adds Throttle, Direction, Horn, Sander and Wiper control
    /// to the basic TrainCar.
    /// Use as a base for Electric, Diesel or Steam locomotives.
    /// </summary>
    public abstract partial class MSTSLocomotive : MSTSWagon
    {
        protected bool speedSelectorModeDecreasing = false;

        // simulation parameters
        public bool ManualHorn;
        public bool TCSHorn;
        public bool Horn;
        private bool previousHorn;

        public bool ManualBell;
        public SoundState BellState = SoundState.Stopped;
        public bool Bell;
        private bool previousBell;

        public bool VacuumExhausterPressed;
        public bool FastVacuumExhausterFitted;

        public bool AlerterSnd;
        public bool VigilanceMonitor;
        public bool Sander;
        public bool Wiper;
        public bool BailOff;
        public bool DynamicBrake;
        public float MaxPowerW;
        public float MaxForceN;
        public float AbsTractionSpeedMpS;
        public float MaxCurrentA;
        public float MaxSpeedMpS = 1e3f;
        public float UnloadingSpeedMpS;
        public float MainResPressurePSI = 130;
        public float MaximumMainReservoirPipePressurePSI;
        public bool CompressorIsOn;
        public bool CompressorIsMechanical;
        public float AverageForceN;
        public float PowerOnDelayS;
        public bool CabLightOn;
        public bool ShowCab = true;
        public int DistributedPowerUnitId;
        public float DrvWheelWeightKg; // current weight on locomotive drive wheels, includes drag factor (changes as mass changes)
        public float InitialDrvWheelWeightKg; // initialising weight on locomotive drive wheels, includes drag factor
        public bool CabRadioOn;
        public bool OnLineCabRadio;
        public string OnLineCabRadioURL;

        // Water trough filling
        public bool HasWaterScoop; // indicates whether loco + tender have a water scoop or not
        public float ScoopMaxPickupSpeedMpS = 200.0f; // Maximum scoop pickup speed - used in steam locomotive viewer
        public bool ScoopIsBroken; // becomes broken if activated where there is no trough
        public bool RefillingFromTrough; // refilling from through is ongoing
        public float WaterScoopFillElevationM; // height water has to be raised to fill tender
        public float WaterScoopDepthM; // depth that water scoop goes into trough (pan)
        public float WaterScoopWidthM; // width of water scoop
        public float WaterScoopVelocityMpS; // Velocity of water entering water scoop
        public float WaterScoopDragForceN; // drag force due to scoop being in water trough
        public float WaterScoopedQuantityLpS; // Amount of water scooped up by water scoop per second
        public float WaterScoopInputAmountL; // Water scooped in elapsed time
        public float WaterScoopMinSpeedMpS; // Minimum speed for water pickup
        public bool IsWaterScoopDown;
        public bool WaterScoopDown;
        public const float GravitationalAccelerationFtpSpS = 32.26f;
        public float TenderWaterLevelFraction;
        public float WaterScoopTotalWaterL;
        private bool WaterScoopOverTroughFlag;
        private bool WaterScoopNotFittedFlag;
        private bool WaterScoopSlowSpeedFlag;
        private bool WaterScoopDirectionFlag;
        public bool IsWaterScoopPlayerLocomotive;
        private bool WaterScoopSoundOn;
        public float MaxTotalCombinedWaterVolumeUKG;
        public MSTSNotchController WaterController = new MSTSNotchController(0, 1, 0.01f);
        public float CombinedTenderWaterVolumeUKG          // Decreased by running injectors and increased by refilling
        {
            get { return WaterController.CurrentValue * MaxTotalCombinedWaterVolumeUKG; }
            set { WaterController.CurrentValue = value / MaxTotalCombinedWaterVolumeUKG; }
        }

        public double CurrentLocomotiveSteamHeatBoilerWaterCapacityL
        {
            get { return WaterController.CurrentValue * maximumSteamHeatBoilerWaterTankCapacityL; }
            set { WaterController.CurrentValue = (float)(value / maximumSteamHeatBoilerWaterTankCapacityL); }
        }

        public float IsTenderRequired = 1.0f;  // Flag indicates that a tender is required for operation of the locomotive. Typically tank locomotives do not require a tender. Assume by default that tender is required.

        public float BoilerPressurePSI;     // Steam Gauge pressure - what the engineer sees.
        public float MaxBoilerPressurePSI = 180f;  // maximum boiler pressure, safety valve setting

        // Vacuum Reservoir and Exhauster Settings

        // Steam heating Flags
        public bool IsSteamInitial = true;        // To initialise steam heat
        public bool IsSteamHeatFirstTime = true;  // Flag for first pass at steam heating.
        public bool IsSteamHeatFitted;    // Is steam heating fitted to locomotive
        public float CurrentSteamHeatPressurePSI;   // Current pressure in steam heat system

        public string LocomotiveName; // Name of locomotive from ENG file

        // Carriage Steam Heating Parameters
        public float MaxSteamHeatPressurePSI;    // Maximum Steam heating pressure
        public Interpolator SteamHeatPressureToTemperaturePSItoF;
        public Interpolator SteamDensityPSItoLBpFT3;   // saturated steam density given pressure
        public Interpolator SteamHeatPSItoBTUpLB;      // total heat in saturated steam given pressure
        public bool IsSteamHeatingBoilerFitted;   // Flag to indicate when steam heat boiler van is fitted
        public float CalculatedCarHeaterSteamUsageLBpS;

        // Adhesion parameters
        public SlipControlType SlipControlSystem { get; private set; }
        private float BaseFrictionCoefficientFactor;  // Factor used to adjust Curtius formula depending upon weather conditions
        private float SlipFrictionCoefficientFactor;
        public float SteamStaticWheelForce;
        public float SteamTangentialWheelForce;
        public float SteamDrvWheelWeightLbs;  // Weight on each drive axle
        public float PreviousThrottleSetting;  // Holds the value of the previous throttle setting for calculating the correct antislip speed

        // parameters for Track Sander based upon compressor air and abrasive table for 1/2" sand blasting nozzle @ 50psi
        public float MaxTrackSandBoxCapacityM3 = (float)Size.Volume.FromFt3(40.0f);  // Capacity of sandbox - assume 40.0 cu ft
        public float CurrentTrackSandBoxCapacityM3 = 5.0f;   // This value needs to be initialised to the value above, as it reduces as sand is used.
        public float TrackSanderAirComsumptionM3pS = (float)Size.Volume.FromFt3(195.0f) / 60.0f;  // Default value - cubic feet per min (CFM) 195 ft3/m
        public float TrackSanderAirPressurePSI = 50.0f;
        public float TrackSanderSandConsumptionM3pS = (float)Size.Volume.FromFt3(11.6f) / 3600.0f; // Default value 11.6 ft3/h

        // Vacuum Braking parameters
        public bool SmallSteamEjectorIsOn;
        public bool LargeSteamEjectorIsOn;
        public bool VacuumPumpOperating;
        public float SteamEjectorSmallPressurePSI;
        public float SteamEjectorLargePressurePSI;
        public bool VacuumPumpFitted;
        public bool SmallEjectorControllerFitted;
        public float VacuumPumpResistanceN;
        public float EjectorSmallSteamConsumptionLbpS;
        public float EjectorLargeSteamConsumptionLbpS;
        public float SteamEjectorSmallSetting;
        public float SteamEjectorLargeSetting;
        public float MaxVaccuumMaxPressurePSI = 110.0f;  // Value for the boiler pressure when maximum vacuum will be produced for the steam ejector 
        public float SmallEjectorFeedFraction = 0.35f;
        public float LargeEjectorFeedFraction = 1.0f;
        public bool LargeEjectorControllerFitted;
        public float VacuumPumpChargingRateInHgpS;
        public bool VacuumBrakeEQFitted;  // Flag to indicate that equalising resevoir fitted to vacuum brakes
        public float HUDNetBPLossGainPSI;
        public float SmallEjectorBrakePipeChargingRatePSIorInHgpS;
        public float LargeEjectorBrakePipeChargingRatePSIorInHgpS;
        public float ExhausterHighSBPChargingRatePSIorInHgpS;  // Rate for Exhauster in high speed mode
        public float ExhausterLowSBPChargingRatePSIorInHgpS;  // Rate for Exhauster in high speed mode
        public bool VacuumBrakeCutoffActivated;
        public bool BrakeFlagDecrease;
        public bool BrakeFlagIncrease;

        private bool _SmallEjectorSoundOn;
        public bool SmallEjectorSoundOn
        {
            get => _SmallEjectorSoundOn;
            set
            {
                if (value != _SmallEjectorSoundOn)
                {
                    SignalEvent(value ? TrainEvent.SmallEjectorOn : TrainEvent.SmallEjectorOff);
                    _SmallEjectorSoundOn = value;
                }
            }
        }

        private bool _LargeEjectorSoundOn;
        public bool LargeEjectorSoundOn
        {
            get => _LargeEjectorSoundOn;
            set
            {
                if (value != _LargeEjectorSoundOn)
                {
                    SignalEvent(value ? TrainEvent.LargeEjectorOn : TrainEvent.LargeEjectorOff);
                    _LargeEjectorSoundOn = value;
                }
            }
        }

        public bool DriveWheelOnlyBrakes;
        public bool SteamEngineBrakeFitted;
        public bool TrainBrakeFitted;
        public bool EngineBrakeFitted;
        public bool BrakemanBrakeFitted;
        public bool VacuumExhausterIsOn;
        public float VacuumBrakesMainResVolumeM3 = (float)Size.Volume.FromFt3(200.0f); // Main vacuum reservoir volume
        public float VacuumBrakesMainResMaxVacuumPSIAorInHg = (float)Pressure.Vacuum.ToPressure(23);
        public float VacuumBrakesExhausterRestartVacuumPSIAorInHg = (float)Pressure.Vacuum.ToPressure(21);
        public float VacuumBrakesMainResChargingRatePSIAorInHgpS = (float)Pressure.Atmospheric.ToPSI(Pressure.Atmospheric.FromInHg(0.2f));
        public float VacuumMainResVacuumPSIAorInHg = (float)Pressure.Vacuum.ToPressure(23); // Vacuum currently in Main Reservoir

        // Set values for display in HUD
        public float WagonCoefficientFrictionHUD;
        public float LocomotiveCoefficientFrictionHUD;
        public float HuDGearMaximumTractiveForce;

        public Pressure.Unit MainPressureUnit { get; protected set; } = Pressure.Unit.None;

        public EnumArray<Pressure.Unit, BrakeSystemComponent> BrakeSystemPressureUnits { get; } = new EnumArray<Pressure.Unit, BrakeSystemComponent>(Pressure.Unit.None);

        private float odometerResetPositionM;
        private bool odometerCountingUp = true;
        private bool odometerCountingForwards = true;
        public bool OdometerResetButtonPressed { get; private set; }

        public bool OdometerVisible { get; private set; }
        public float OdometerM => Train == null
                    ? 0
                    : odometerCountingForwards ? Train.DistanceTravelledM - odometerResetPositionM : odometerResetPositionM - Train.DistanceTravelledM;

        // ENG file data
        public string CabSoundFileName;
        public string CVFFileName;
        public float MaxMainResPressurePSI;
        public float MainResVolumeM3;
        public float TrainBrakePipeLeakPSIorInHgpS;    // Air leakage from train brake pipe - should normally be no more then 5psi/min - default off
        public float CompressorRestartPressurePSI = 110;
        public float CompressorChargingRateM3pS = 0.075f;
        public float MainResChargingRatePSIpS = 0.4f;
        public float EngineBrakeReleaseRatePSIpS = 12.5f;
        public float EngineBrakeApplyRatePSIpS = 12.5f;
        public float BrakePipeTimeFactorS = 0.0015f;
        public float BrakePipeDischargeTimeFactor;
        public float BrakeServiceTimeFactorPSIpS;
        public float BrakeEmergencyTimeFactorPSIpS;
        public float BrakePipeChargingRatePSIorInHgpS;
        public float BrakePipeQuickChargingRatePSIpS;
        public Interpolator2D TractiveForceCurves;
        public Interpolator2D DynamicBrakeForceCurves;
        public float DynamicBrakeSpeed1MpS = (float)Speed.MeterPerSecond.FromKpH(5);
        public float DynamicBrakeSpeed2MpS = (float)Speed.MeterPerSecond.FromKpH(30);
        public float DynamicBrakeSpeed3MpS = (float)Speed.MeterPerSecond.FromKpH(999);
        public float DynamicBrakeSpeed4MpS = (float)Speed.MeterPerSecond.FromKpH(999);
        public float DynamicBrakeRatioAtSpeed4;
        public float MaxDynamicBrakeForceN;
        public float DynamicBrakeMaxCurrentA;
        public float DynamicBrakeDelayS;
        public bool DynamicBrakeAutoBailOff;
        public bool UsingRearCab;   // TODO 20240421 use CabViewType enum
        public bool BrakeOverchargeSoundOn;

        protected bool DynamicBrakeBlended; // dynamic brake blending is currently active
        protected bool DynamicBrakeBlendingEnabled; // dynamic brake blending is configured
        public bool DynamicBrakeAvailable { get; protected set; } // dynamic brake is available
        private AirSinglePipe airPipeSystem;
        public double DynamicBrakeCommandStartTime { get; internal set; }
        protected bool DynamicBrakeBlendingOverride; // true when DB lever >0% should always override the blending. When false, the bigger command is applied.
        protected bool DynamicBrakeBlendingForceMatch = true; // if true, dynamic brake blending tries to achieve the same braking force as the airbrake would have.

        public CombinedControl CombinedControlType;
        public float CombinedControlSplitPosition;
        public bool HasSmoothStruc;
        private bool controlTrailerBrakeSystemSet;

        public float MaxContinuousForceN;
        public float SpeedOfMaxContinuousForceMpS;  // Speed where maximum tractive effort occurs
        public float MSTSSpeedOfMaxContinuousForceMpS;  // Speed where maximum tractive effort occurs - MSTS parameter if used
        public float ContinuousForceTimeFactor = 1800;
        public bool AntiSlip;
        public bool AdvancedAdhesionModel; // flag set depending upon adhesion model used.
        public float SanderSpeedEffectUpToMpS;
        public float SanderSpeedOfMpS = 30.0f;
        public string EngineOperatingProcedures;

        public bool EmergencyButtonPressed { get; set; }
        public bool EmergencyCausesPowerDown { get; private set; }
        public bool EmergencyCausesThrottleDown { get; private set; }
        public bool EmergencyEngagesHorn { get; private set; }
        public bool WheelslipCausesThrottleDown { get; private set; }

        public float BrakeRestoresPowerAtBrakePipePressurePSI { get; private set; }
        public float BrakeCutsPowerAtBrakePipePressurePSI { get; private set; }
        public bool DoesVacuumBrakeCutPower { get; private set; }
        public bool DoesBrakeCutPower { get; private set; }
        public float BrakeCutsPowerAtBrakeCylinderPressurePSI { get; private set; }
        public bool DoesHornTriggerBell { get; private set; }

        protected const float DefaultCompressorRestartToMaxSysPressureDiff = 35;    // Used to check if difference between these two .eng parameters is correct, and to correct it
        protected const float DefaultMaxMainResToCompressorRestartPressureDiff = 10; // Used to check if difference between these two .eng parameters is correct, and to correct it
        protected const float DefaultMaxCompressorRestartPressure = 135; // Max value to be inserted if .eng parameters are corrected
        protected const float DefaultMainResVolume = 0.78f; // Value to be inserted if .eng parameters are corrected
        protected const float DefaultMaxMainResPressure = 140; // Max value to be inserted if .eng parameters are corrected

        public EnumArray<CabView, CabViewType> CabViews { get; private set; } = new EnumArray<CabView, CabViewType>();
        public CabView3D CabView3D;

        public MSTSNotchController SteamHeatController = new MSTSNotchController(0, 1, 0.1f);

        public MSTSNotchController ThrottleController;
        public ScriptedBrakeController TrainBrakeController { get; private set; }
        public ScriptedBrakeController EngineBrakeController { get; private set; }
        public ScriptedBrakeController BrakemanBrakeController { get; private set; }
        public ValveState EngineBrakeState = ValveState.Lap;
        public MSTSNotchController DynamicBrakeController;
        public MSTSNotchController GearBoxController;
        public MSTSNotchController DistributedPowerThrottleController;
        public MSTSNotchController DistributedPowerDynamicBrakeController;

        private int previousGearBoxNotch;
        private int previousChangedGearBoxNotch;

        public float EngineBrakeIntervention = -1;
        public float TrainBrakeIntervention = -1;
        public float ThrottleIntervention = -1;
        public float DynamicBrakeIntervention = -1;
        protected float PreviousDynamicBrakeIntervention = -1;
        protected bool PreviousFullDynamicBrakingOrder;

        public TractionMotorType TractionMotorType { get; private set; } = TractionMotorType.DC;


        public ILocomotivePowerSupply LocomotivePowerSupply => PowerSupply as ILocomotivePowerSupply;
        public ScriptedTrainControlSystem TrainControlSystem;

        private protected readonly LocomotiveBrakeInformation locomotiveBrakeInfo;
        private protected readonly LocomotiveForceInformation locomotiveForceInfo;
        public DetailInfoBase LocomotiveBrakeInfo => locomotiveBrakeInfo;
        public DetailInfoBase LocomotiveForceInfo => locomotiveForceInfo;

        public Axle LocomotiveAxle { get; protected set; }
        private IIRFilter currentFilter;
        private IIRFilter adhesionFilter;
        private double saveAdhesionFilter;
        private double adhesionConditions;

        public float FilteredMotiveForceN;

        public double CommandStartTime;

        public double LastBrakeSoundTime;

        public float PowerReduction;

        // Cruise Control
        public CruiseControl CruiseControl { get; private set; }
        //       public MultiPositionController MultiPositionController;
        public Collection<MultiPositionController> MultiPositionControllers { get; private set; }

        public TrainCategory SelectedTrainType { get; private set; } = TrainCategory.Passenger;

        public void ChangeTrainTypePaxCargo()
        {
            SelectedTrainType = SelectedTrainType.Next();
        }

        public new MidpointDirection Direction
        {
            //TODO: following code lines have been modified to flip trainset physics in order to get viewing direction coincident with loco direction when using rear cab.
            // To achieve the same result with other means, without flipping trainset physics, the code lines probably should be changed
            get => (Train.IsActualPlayerTrain) ? Flipped ^ UsingRearCab ? (MidpointDirection)((int)Train.MUDirection * -1) : Train.MUDirection : base.Direction;
            set => Train.MUDirection = Flipped ^ UsingRearCab ? (MidpointDirection)((int)value * -1) : value;
        }

        protected MSTSLocomotive(string wagPath)
            : base(wagPath)
        {
            //  BrakePipeChargingRatePSIpS = Simulator.Settings.BrakePipeChargingRate;

            BrakeCutsPowerAtBrakeCylinderPressurePSI = 4.0f;

            LocomotiveAxle = new Axle(AxleDriveType.ForceDriven);
            currentFilter = new IIRFilter(IIRFilterType.Butterworth, Frequency.Angular.HzToRad(0.5), 0.001);
            adhesionFilter = new IIRFilter(IIRFilterType.Butterworth, Frequency.Angular.HzToRad(1.0), 0.001);

            TrainBrakeController = new ScriptedTrainBrakeController(this);
            EngineBrakeController = new ScriptedEngineBrakeController(this);
            BrakemanBrakeController = new ScriptedBrakeController(this);
            MultiPositionControllers = new Collection<MultiPositionController>();
            ThrottleController = new MSTSNotchController();
            DynamicBrakeController = new MSTSNotchController();
            TrainControlSystem = new ScriptedTrainControlSystem(this);
            locomotiveForceInfo = new LocomotiveForceInformation(this);
            locomotiveBrakeInfo = new LocomotiveBrakeInformation(this);
        }

        /// <summary>
        /// This initializer is called when we haven't loaded this type of car before
        /// and must read it new from the wag file.
        /// </summary>
        public override void LoadFromWagFile(string wagFilePath)
        {
            base.LoadFromWagFile(wagFilePath);

            // Assumes that CabViewList[0] is the front cab
            // and that CabViewList[1] is the rear cab, if present.
            // Could be extended to more than 2 cabs.
            if (CVFFileName != null)
            {
                CabView cabView = BuildCabView(WagFilePath, CVFFileName);
                if (cabView != null)
                {
                    CabViews[cabView.CabViewType] = cabView;
                    var reverseCVFFileName = Path.Combine(
                        Path.GetDirectoryName(CVFFileName), // Some CVF paths begin with "..\..\", so Path.GetDirectoryName() is needed.
                        Path.GetFileNameWithoutExtension(CVFFileName) + "_rv.cvf"
                    );
                    cabView = BuildCabView(WagFilePath, reverseCVFFileName);
                    if (null != cabView)
                        CabViews[cabView.CabViewType] = cabView;
                    // only a rear cabview, insert a void one at first place to maintain fast indexing
                    else if (CabViews[CabViewType.Front] == null)
                    {
                        UsingRearCab = true;
                        CabViews[CabViewType.Front] = CabViews[CabViewType.Rear];
                        CabViews[CabViewType.Front].CabViewType = CabViewType.Front;
                    }
                }
                CabView3D = BuildCab3DView();
                if (CabViews[CabViewType.Front] == null && CabViews[CabViewType.Rear] == null && CabView3D == null)
                    Trace.TraceWarning("{0} locomotive's CabView references non-existent {1}", wagFilePath, CVFFileName);
            }

            DrvWheelWeightKg = InitialDrvWheelWeightKg;

            // If DrvWheelWeight is not in ENG file, then set drivewheel weight the same as locomotive mass

            if (DrvWheelWeightKg == 0) // if DrvWheelWeightKg not in ENG file.
            {
                DrvWheelWeightKg = MassKG; // set Drive wheel weight to total wagon mass if not in ENG file
                InitialDrvWheelWeightKg = MassKG; // // set Initial Drive wheel weight as well, as it is used as a reference
            }

            CorrectBrakingParams();
            CheckCoherence();
            GetPressureUnit();

            MoveParamsToAxle();
        }

        protected void CheckCoherence()
        {
            if (!TrainBrakeController.IsValid())
                TrainBrakeController = new ScriptedTrainBrakeController(this); //create a blank one

            if (!EngineBrakeController.IsValid())
                EngineBrakeController = null;

            if (!BrakemanBrakeController.IsValid())
                BrakemanBrakeController = null;

            if (ThrottleController == null)
            {
                //If no controller so far, we create a default one
                ThrottleController = new MSTSNotchController();
                ThrottleController.StepSize = 0.1f;
            }
            DistributedPowerThrottleController = (MSTSNotchController)ThrottleController.Clone();

            // need to test for Dynamic brake problem on 3DTS and SLI
            if (DynamicBrakeController.IsValid())
            {
                if (DynamicBrakeController.NotchCount() <= 3)
                {
                    HasSmoothStruc = true;
                }
                if (DynamicBrakeController.NotchCount() > 3)
                    DistributedPowerDynamicBrakeController = (MSTSNotchController)DynamicBrakeController.Clone();
                else
                    DistributedPowerDynamicBrakeController = BuildDPDynamicBrakeController();
            }
            else
            {
                DynamicBrakeController = null;
                DistributedPowerDynamicBrakeController = null;
            }

            if (DynamicBrakeForceCurves == null && MaxDynamicBrakeForceN > 0)
            {
                DynamicBrakeForceCurves = new Interpolator2D(2);
                Interpolator interp = new Interpolator(2);
                interp[0] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[0] = interp;
                interp = new Interpolator(7);
                interp[0] = 0;
                interp[DynamicBrakeSpeed1MpS] = 0;
                interp[DynamicBrakeSpeed2MpS] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed3MpS] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4MpS] = DynamicBrakeRatioAtSpeed4 * MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4MpS + 0.5f] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[1] = interp;
            }
        }

        protected MSTSNotchController BuildDPDynamicBrakeController()
        {
            var dpDynController = new MSTSNotchController();
            CabView cabView = null;
            CabViewMultiStateDisplayControl msDisplay = null;
            cabView = CabView3D != null ? CabView3D : CabViews[CabViewType.Front] ?? CabViews[CabViewType.Rear];
            if (cabView != null)
            {
                msDisplay = cabView.CVFFile.CabViewControls.OfType<CabViewMultiStateDisplayControl>().Where(
                    control => (control.ControlType.CabViewControlType == CabViewControlType.Dynamic_Brake_Display || control.ControlType.CabViewControlType == CabViewControlType.Cph_Display)).FirstOrDefault();
                if (msDisplay != null)
                {
                    if (msDisplay.ControlType.CabViewControlType == CabViewControlType.Dynamic_Brake_Display)
                    {
                        foreach (var switchval in msDisplay.Values)
                            dpDynController.AddNotch((float)switchval);
                    }
                    else
                    {
                        foreach (var switchval in msDisplay.Values)
                        {
                            if (switchval < CombinedControlSplitPosition)
                                continue;
                            dpDynController.AddNotch((float)(switchval - CombinedControlSplitPosition) / (1 - CombinedControlSplitPosition));
                        }
                    }
                }
            }
            if (cabView == null || msDisplay == null)
            // Use default Dash9 arrangement if no display is found
            {
                var switchval = 0f;
                while (switchval <= 1)
                {
                    if (switchval == 0.99f)
                        switchval = 1;
                    dpDynController.AddNotch(switchval);
                    switchval += 0.11f;
                }
            }


            return dpDynController;
        }


        protected void GetPressureUnit()
        {
            switch (simulator.Settings.PressureUnit)
            {
                default:
                case PressureUnit.Automatic:
                    CabView cabView = CabViews.Where(c => c != null).FirstOrDefault();
                    if (cabView != null)
                    {
                        Dictionary<CabViewControlType, BrakeSystemComponent> brakeSystemComponents = new Dictionary<CabViewControlType, BrakeSystemComponent>
                        {
                            { CabViewControlType.Main_Res, BrakeSystemComponent.MainReservoir },
                            { CabViewControlType.Eq_Res, BrakeSystemComponent.EqualizingReservoir },
                            { CabViewControlType.Brake_Cyl, BrakeSystemComponent.BrakeCylinder },
                            { CabViewControlType.Brake_Pipe, BrakeSystemComponent.BrakePipe }
                        };

                        Dictionary<CabViewControlUnit, Pressure.Unit> pressureUnits = new Dictionary<CabViewControlUnit, Pressure.Unit>
                        {
                            { CabViewControlUnit.KiloPascals, Pressure.Unit.KPa },
                            { CabViewControlUnit.Bar, Pressure.Unit.Bar },
                            { CabViewControlUnit.Psi, Pressure.Unit.PSI },
                            { CabViewControlUnit.Inches_Of_Mercury, Pressure.Unit.InHg },
                            { CabViewControlUnit.Kgs_Per_Square_Cm, Pressure.Unit.KgfpCm2 }
                       };

                        CabViewControls cvcList = cabView.CVFFile.CabViewControls;
                        foreach (CabViewControl cvc in cvcList)
                        {
                            if (brakeSystemComponents.TryGetValue(cvc.ControlType.CabViewControlType, out BrakeSystemComponent component)
                                && pressureUnits.TryGetValue(cvc.ControlUnit, out Pressure.Unit unit))
                            {
                                BrakeSystemPressureUnits[component] = unit;
                            }
                        }
                    }

                    // Manual rules :
                    BrakeSystemPressureUnits[BrakeSystemComponent.MainPipe] = BrakeSystemPressureUnits[BrakeSystemComponent.MainReservoir]; // Main Pipe is supplied by Main Reservoir
                    BrakeSystemPressureUnits[BrakeSystemComponent.AuxiliaryReservoir] = BrakeSystemPressureUnits[BrakeSystemComponent.BrakePipe]; // Auxiliary Reservoir is supplied by Brake Pipe (in single pipe brakes)
                    BrakeSystemPressureUnits[BrakeSystemComponent.EmergencyReservoir] = BrakeSystemPressureUnits[BrakeSystemComponent.BrakePipe]; // Emergency Reservoir is supplied by Brake Pipe

                    foreach (BrakeSystemComponent component in EnumExtension.GetValues<BrakeSystemComponent>())
                    {
                        if (BrakeSystemPressureUnits[component] == Pressure.Unit.None)
                            BrakeSystemPressureUnits[component] = (simulator.Route.MilepostUnitsMetric ? Pressure.Unit.Bar : Pressure.Unit.PSI);
                    }
                    break;

                case PressureUnit.Bar:
                    foreach (BrakeSystemComponent component in EnumExtension.GetValues<BrakeSystemComponent>())
                    {
                        BrakeSystemPressureUnits[component] = Pressure.Unit.Bar;
                    }
                    break;

                case PressureUnit.Psi:
                    foreach (BrakeSystemComponent component in EnumExtension.GetValues<BrakeSystemComponent>())
                    {
                        BrakeSystemPressureUnits[component] = Pressure.Unit.PSI;
                    }
                    break;

                case PressureUnit.InHg:
                    foreach (BrakeSystemComponent component in EnumExtension.GetValues<BrakeSystemComponent>())
                    {
                        BrakeSystemPressureUnits[component] = Pressure.Unit.InHg;
                    }
                    break;

                case PressureUnit.Kgfcm2:
                    foreach (BrakeSystemComponent component in EnumExtension.GetValues<BrakeSystemComponent>())
                    {
                        BrakeSystemPressureUnits[component] = Pressure.Unit.KgfpCm2;
                    }
                    break;
            }

            // The main pressure unit is the one that is the most present in the brake system
            MainPressureUnit = BrakeSystemPressureUnits.GroupBy(x => x).OrderByDescending(x => x.Count()).First().Key;
        }

        protected CabView BuildCabView(string wagFilePath, string cvfFileName)
        {
            var viewPointList = new List<ViewPoint>();
            var extendedCVF = new ExtendedCVF();

            string basePath = Path.Combine(Path.GetDirectoryName(wagFilePath), "CABVIEW");
            if (!File.Exists(Path.Combine(basePath, cvfFileName)))
                return null;

            var cvfFile = new CabViewFile(basePath, cvfFileName);
            var viewPoint = new ViewPoint();
            if (cvfFile.Locations.Count <= 0)
                return null; //check for Protrain's dummy cab
            // Set up camera locations for the cab views
            for (int i = 0; i < cvfFile.Locations.Count; ++i)
            {
                if (i >= cvfFile.Locations.Count || i >= cvfFile.Directions.Count)
                {
                    Trace.TraceWarning("Skipped cab view camera {1} missing Position and Direction in {0}", cvfFileName, i);
                    break;
                }
                viewPoint = new ViewPoint(cvfFile.Locations[i]);
                viewPoint.StartDirection = cvfFile.Directions[i];
                viewPoint.RotationLimit = new Vector3(0, 0, 0);  // cab views have a fixed head position
                viewPointList.Add(viewPoint);
            }
            CabViewType cabViewType = viewPointList[0].StartDirection.Y >= 90 && viewPointList[0].StartDirection.Y <= 270
                || viewPointList[0].StartDirection.Y <= -90 && viewPointList[0].StartDirection.Y >= -270 ? CabViewType.Rear : CabViewType.Front;
            var wag = this as MSTSWagon;
            var wagFolderSlash = Path.GetDirectoryName(wag.WagFilePath) + @"\";
            string shapeFilePath;
            bool boundingLimitsFound = false;
            ShapeDescriptorFile shapeFile = new ShapeDescriptorFile();
            if (wag.FreightShapeFileName != null)
            {
                shapeFilePath = wagFolderSlash + wag.FreightShapeFileName;
                if (shapeFilePath != null && File.Exists(shapeFilePath + "d"))
                {
                    shapeFile = new ShapeDescriptorFile(shapeFilePath + "d");
                    if (shapeFile.Shape.EsdBoundingBox != null)
                        boundingLimitsFound = true;
                }
            }
            if (!boundingLimitsFound)
            {
                shapeFilePath = wagFolderSlash + wag.MainShapeFileName;
                if (shapeFilePath != null && File.Exists(shapeFilePath + "d"))
                {
                    shapeFile = new ShapeDescriptorFile(shapeFilePath + "d");
                    if (shapeFile.Shape.EsdBoundingBox != null)
                        boundingLimitsFound = true;
                }
            }

            if (this is not MSTSSteamLocomotive)
            {
                extendedCVF.Initialize(Path.Combine(basePath, cvfFileName));
            }
            return new CabView(cvfFile, viewPointList, extendedCVF, cabViewType);
        }

        protected CabView3D BuildCab3DView()
        {
            if (Cab3DShapeFileName == null)
                return null;

            var extendedCVF = new ExtendedCVF();

            var cab3dBasePath = Path.Combine(Path.GetDirectoryName(WagFilePath), "CABVIEW3D");
            var shapeFilePath = Path.Combine(cab3dBasePath, Cab3DShapeFileName);
            if (!File.Exists(shapeFilePath))
                return null;

            string cvfFileName = Path.ChangeExtension(Cab3DShapeFileName, "cvf");
            if (!File.Exists(Path.Combine(cab3dBasePath, cvfFileName)))
            {
                cvfFileName = CVFFileName;
                if (!File.Exists(Path.Combine(cab3dBasePath, cvfFileName)))
                {
                    cab3dBasePath = Path.Combine(Path.GetDirectoryName(WagFilePath), "CABVIEW");
                    if (!File.Exists(Path.Combine(cab3dBasePath, cvfFileName)))
                        return null;
                }
            }
            var cvfFile = new CabViewFile(cab3dBasePath, cvfFileName);
            if (this is not MSTSSteamLocomotive)
            {
                extendedCVF.Initialize(Path.Combine(cab3dBasePath, cvfFileName));
            }

            float cabViewAngle = CabViewpoints?[0].StartDirection.Y ?? 0;
            CabViewType cabViewType = (cabViewAngle >= 90 && cabViewAngle <= 270) || (cabViewAngle <= -90 && cabViewAngle >= -270) ? CabViewType.Rear : CabViewType.Front;

            // only one cabview, and it looks rear; insert a void one at first place to maintain fast indexing
            if (CabViewpoints?.Count == 1 && cabViewType == CabViewType.Rear)
                CabViewpoints.Insert(0, new PassengerViewPoint());

            return new CabView3D(cvfFile, CabViewpoints, extendedCVF, cabViewType, shapeFilePath);
        }

        /// <summary>
        /// Parse the wag file parameters required for the simulator and viewer classes
        /// </summary>
        public override void Parse(string lowercasetoken, STFReader stf)
        {
            switch (lowercasetoken)
            {
                case "engine(sound":
                    CabSoundFileName = stf.ReadStringBlock(null);
                    break;
                case "engine(cabview":
                    CVFFileName = stf.ReadStringBlock(null);
                    break;
                case "engine(maxpower":
                    MaxPowerW = stf.ReadFloatBlock(STFReader.Units.Power, null);
                    break;
                case "engine(maxforce":
                    MaxForceN = stf.ReadFloatBlock(STFReader.Units.Force, null);
                    break;
                case "engine(maxcurrent":
                    MaxCurrentA = stf.ReadFloatBlock(STFReader.Units.Current, null);
                    break;
                case "engine(maxcontinuousforce":
                    MaxContinuousForceN = stf.ReadFloatBlock(STFReader.Units.Force, null);
                    break;
                case "engine(ortsspeedofmaxcontinuousforce":
                    SpeedOfMaxContinuousForceMpS = stf.ReadFloatBlock(STFReader.Units.Speed, null);
                    break;
                case "engine(dieselenginespeedofmaxtractiveeffort":
                    MSTSSpeedOfMaxContinuousForceMpS = stf.ReadFloatBlock(STFReader.Units.Speed, null);
                    break;
                case "engine(maxvelocity":
                    MaxSpeedMpS = stf.ReadFloatBlock(STFReader.Units.Speed, null);
                    break;
                case "engine(ortsunloadingspeed":
                    UnloadingSpeedMpS = stf.ReadFloatBlock(STFReader.Units.Speed, null);
                    break;
                case "engine(ortsslipcontrolsystem":
                    stf.MustMatch("(");
                    string slipControlType = stf.ReadString();
                    if (EnumExtension.GetValue(slipControlType, out SlipControlType slipControlTypeResult))
                        SlipControlSystem = slipControlTypeResult;
                    else
                        STFException.TraceWarning(stf, "Skipped unknown slip control system " + slipControlType);
                    break;
                case "engine(type":
                    stf.MustMatch("(");
                    string engineType = stf.ReadString();
                    if (EnumExtension.GetValue(engineType, out EngineType engineTypeResult))
                        EngineType = engineTypeResult;
                    else
                        STFException.TraceWarning(stf, "Skipped unknown engine type " + engineType);
                    break;
                case "engine(ortstractionmotortype":
                    stf.MustMatch("(");
                    string tractionMotorType = stf.ReadString();
                    if (EnumExtension.GetValue(tractionMotorType, out TractionMotorType electricMotorTypeResult))
                        TractionMotorType = electricMotorTypeResult;
                    else
                        STFException.TraceWarning(stf, "Skipped unknown traction motor type " + tractionMotorType);
                    break;
                case "engine(enginecontrollers(throttle":
                    ThrottleController = new MSTSNotchController(stf);
                    break;
                case "engine(enginecontrollers(regulator":
                    ThrottleController = new MSTSNotchController(stf);
                    break;
                case "engine(enginecontrollers(brake_dynamic":
                    DynamicBrakeController.Parse(stf);
                    break;

                case "engine(ortslocomotivedrivewheelonlybraking":
                    var wheelbraking = stf.ReadIntBlock(null);
                    if (wheelbraking == 1)
                    {
                        DriveWheelOnlyBrakes = true;
                    }
                    break;
                case "engine(trainbrakescontrollermaxsystempressure":
                case "engine(ortstrainbrakescontrollermaxoverchargepressure":
                case "engine(trainbrakescontrollermaxreleaserate":
                case "engine(trainbrakescontrollermaxquickreleaserate":
                case "engine(ortstrainbrakescontrolleroverchargeeliminationrate":
                case "engine(trainbrakescontrollermaxapplicationrate":
                case "engine(trainbrakescontrolleremergencyapplicationrate":
                case "engine(trainbrakescontrollerfullservicepressuredrop":
                case "engine(trainbrakescontrollerminpressurereduction":
                case "engine(ortstrainbrakescontrollerslowapplicationrate":
                case "engine(ortstrainbrakecontroller":
                case "engine(enginecontrollers(brake_train":
                    TrainBrakeController.Parse(lowercasetoken, stf);
                    TrainBrakeFitted = true;
                    break;
                case "engine(enginecontrollers(ortsfastvacuumexhauster":
                    FastVacuumExhausterFitted = true;
                    break;
                case "engine(enginebrakescontrollermaxsystempressure":
                case "engine(enginebrakescontrollermaxreleaserate":
                case "engine(enginebrakescontrollermaxquickreleaserate":
                case "engine(enginebrakescontrollermaxapplicationrate":
                case "engine(enginebrakescontrolleremergencyapplicationrate":
                case "engine(enginebrakescontrollerfullservicepressuredrop":
                case "engine(enginebrakescontrollerminpressurereduction":
                case "engine(ortsenginebrakescontrollerslowapplicationrate":
                case "engine(enginecontrollers(brake_engine":
                case "engine(ortsenginebrakecontroller":
                    EngineBrakeController.Parse(lowercasetoken, stf);
                    EngineBrakeFitted = true;
                    break;
                case "engine(enginecontrollers(brake_brakeman":
                    BrakemanBrakeController.Parse(lowercasetoken, stf);
                    BrakemanBrakeFitted = true;
                    break;
                case "engine(ortstraincontrolsystem":
                case "engine(ortstraincontrolsystemsound":
                case "engine(ortstraincontrolsystemparameters":
                case "engine(vigilancemonitor":
                case "engine(emergencystopmonitor":
                case "engine(awsmonitor":
                case "engine(overspeedmonitor":
                    VigilanceMonitor = true;
                    TrainControlSystem.Parse(lowercasetoken, stf);
                    break;
                case "engine(enginecontrollers(combined_control":
                    ParseCombData(lowercasetoken, stf);
                    break;
                case "engine(airbrakesmainresvolume":
                    MainResVolumeM3 = (float)Size.Volume.FromFt3(stf.ReadFloatBlock(STFReader.Units.VolumeDefaultFT3, null));
                    break;
                case "engine(airbrakesmainmaxairpressure":
                    MainResPressurePSI = MaxMainResPressurePSI = stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break;
                case "engine(airbrakemaxmainrespipepressure":
                    MaximumMainReservoirPipePressurePSI = stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break;
                case "engine(airbrakescompressorrestartpressure":
                    CompressorRestartPressurePSI = stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break;
                case "engine(airbrakesaircompressorpowerrating":
                    CompressorChargingRateM3pS = (float)Size.Volume.FromFt3(stf.ReadFloatBlock(STFReader.Units.VolumeDefaultFT3, null));
                    break;
                case "engine(airbrakesiscompressorelectricormechanical":
                    CompressorIsMechanical = stf.ReadIntBlock(null) == 1;
                    break;
                case "engine(trainpipeleakrate":
                    TrainBrakePipeLeakPSIorInHgpS = stf.ReadFloatBlock(STFReader.Units.PressureRateDefaultPSIpS, null);
                    break;
                case "engine(vacuumbrakesvacuumpumpresistance":
                    VacuumPumpResistanceN = stf.ReadFloatBlock(STFReader.Units.Force, null);
                    break;
                case "engine(ortsvacuumbrakesmainresvolume":
                    VacuumBrakesMainResVolumeM3 = (float)Size.Volume.FromFt3(stf.ReadFloatBlock(STFReader.Units.VolumeDefaultFT3, null));
                    break;
                case "engine(ortsvacuumbrakesmainresmaxvacuum":
                    VacuumBrakesMainResMaxVacuumPSIAorInHg = (float)Const.OneAtmospherePSI - stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break; // convert to PSIA for vacuum brakes
                case "engine(ortsvacuumbrakesexhausterrestartvacuum":
                    VacuumBrakesExhausterRestartVacuumPSIAorInHg = (float)Const.OneAtmospherePSI - stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break; // convert to PSIA for vacuum brakes
                case "engine(ortsvacuumbrakesmainreschargingrate":
                    VacuumBrakesMainResChargingRatePSIAorInHgpS = stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break;

                case "engine(ortsmainreschargingrate":
                    MainResChargingRatePSIpS = stf.ReadFloatBlock(STFReader.Units.PressureRateDefaultPSIpS, null);
                    break;
                case "engine(ortsenginebrakereleaserate":
                    EngineBrakeReleaseRatePSIpS = stf.ReadFloatBlock(STFReader.Units.PressureRateDefaultPSIpS, null);
                    break;
                case "engine(ortsenginebrakeapplicationrate":
                    EngineBrakeApplyRatePSIpS = stf.ReadFloatBlock(STFReader.Units.PressureRateDefaultPSIpS, null);
                    break;
                case "engine(ortsbrakepipetimefactor":
                    BrakePipeTimeFactorS = stf.ReadFloatBlock(STFReader.Units.Time, null);
                    break;
                case "engine(ortsbrakeservicetimefactor":
                    BrakeServiceTimeFactorPSIpS = stf.ReadFloatBlock(STFReader.Units.Time, null);
                    break;
                case "engine(ortsbrakeemergencytimefactor":
                    BrakeEmergencyTimeFactorPSIpS = stf.ReadFloatBlock(STFReader.Units.Time, null);
                    break;
                case "engine(ortsbrakepipechargingrate":
                    BrakePipeChargingRatePSIorInHgpS = stf.ReadFloatBlock(STFReader.Units.PressureRateDefaultPSIpS, null);
                    break;
                case "engine(ortsbrakepipequickchargingrate":
                    BrakePipeQuickChargingRatePSIpS = stf.ReadFloatBlock(STFReader.Units.PressureRateDefaultPSIpS, null);
                    break;
                case "engine(ortsbrakepipedischargetimemult":
                    BrakePipeDischargeTimeFactor = stf.ReadFloatBlock(STFReader.Units.None, null);
                    break;
                case "engine(ortsmaxtractiveforcecurves":
                    TractiveForceCurves = stf.CreateInterpolator2D(false);
                    TractiveForceCurves.CheckForNegativeValues();
                    break;
                case "engine(ortstractioncharacteristics":
                    TractiveForceCurves = stf.CreateInterpolator2D(true);
                    break;
                case "engine(ortsdynamicbrakeforcecurves":
                    DynamicBrakeForceCurves = stf.CreateInterpolator2D(false);
                    break;
                case "engine(ortscontinuousforcetimefactor":
                    ContinuousForceTimeFactor = stf.ReadFloatBlock(STFReader.Units.None, null);
                    break;
                case "engine(orts(ortssanderspeedeffectupto":
                    SanderSpeedEffectUpToMpS = stf.ReadFloatBlock(STFReader.Units.Speed, null);
                    break;
                case "engine(orts(ortsemergencycausespowerdown":
                    EmergencyCausesPowerDown = stf.ReadBoolBlock(false);
                    break;
                case "engine(orts(ortsemergencycausesthrottledown":
                    EmergencyCausesThrottleDown = stf.ReadBoolBlock(false);
                    break;
                case "engine(orts(ortsemergencyengageshorn":
                    EmergencyEngagesHorn = stf.ReadBoolBlock(false);
                    break;
                case "engine(orts(ortswheelslipcausesthrottledown":
                    WheelslipCausesThrottleDown = stf.ReadBoolBlock(false);
                    break;
                case "engine(dynamicbrakesminusablespeed":
                    DynamicBrakeSpeed1MpS = stf.ReadFloatBlock(STFReader.Units.SpeedDefaultMPH, null);
                    break;
                case "engine(dynamicbrakesfadingspeed":
                    DynamicBrakeSpeed2MpS = stf.ReadFloatBlock(STFReader.Units.SpeedDefaultMPH, null);
                    break;
                case "engine(dynamicbrakesmaximumeffectivespeed":
                    DynamicBrakeSpeed3MpS = stf.ReadFloatBlock(STFReader.Units.SpeedDefaultMPH, null);
                    break;
                case "engine(dynamicbrakesmaximumspeedforfadeout":
                    DynamicBrakeSpeed4MpS = stf.ReadFloatBlock(STFReader.Units.SpeedDefaultMPH, null);
                    break;
                case "engine(dynamicbrakeseffectatmaximumfadeout":
                    DynamicBrakeRatioAtSpeed4 = stf.ReadFloatBlock(STFReader.Units.None, null);
                    break;
                case "engine(dynamicbrakesmaximumforce":
                    MaxDynamicBrakeForceN = stf.ReadFloatBlock(STFReader.Units.Force, null);
                    break;
                case "engine(dynamicbrakehasautobailoff":
                case "engine(ortsdynamicbrakeshasautobailoff":
                    DynamicBrakeAutoBailOff = stf.ReadBoolBlock(true);
                    break;
                case "engine(dynamicbrakesdelaytimebeforeengaging":
                    DynamicBrakeDelayS = stf.ReadFloatBlock(STFReader.Units.Time, null);
                    break;
                case "engine(dynamicbrakesresistorcurrentlimit":
                    DynamicBrakeMaxCurrentA = stf.ReadFloatBlock(STFReader.Units.Current, null);
                    break;
                case "engine(numwheels":
                    locoNumDrvWheels = stf.ReadFloatBlock(STFReader.Units.None, 4.0f);
                    if (locoNumDrvWheels < 1)
                        STFException.TraceWarning(stf, "Engine:NumWheels is less than 1, parts of the simulation may not function correctly");
                    break;
                case "engine(ortsnumberdriveaxles":
                    locoNumDrvAxles = stf.ReadIntBlock(null);
                    if (locoNumDrvAxles < 1)
                        STFException.TraceWarning(stf, "Engine:ORTSNumberDriveAxles is less than 1, parts of the simulation may not function correctly");
                    break;
                case "engine(antislip":
                    AntiSlip = stf.ReadBoolBlock(false);
                    break;
                case "engine(ortsdrivewheelweight":
                    InitialDrvWheelWeightKg = stf.ReadFloatBlock(STFReader.Units.Mass, null);
                    break;
                case "engine(engineoperatingprocedures":
                    EngineOperatingProcedures = stf.ReadStringBlock("");
                    break;
                case "engine(headout":
                    HeadOutViewpoints ??= new List<ViewPoint>();
                    HeadOutViewpoints.Add(new ViewPoint(stf.ReadVector3Block(STFReader.Units.Distance, Vector3.Zero)));
                    HeadOutViewpoints.Add(new ViewPoint(HeadOutViewpoints[0], true));
                    break;
                case "engine(sanding":
                    SanderSpeedOfMpS = stf.ReadFloatBlock(STFReader.Units.Speed, 30.0f);
                    break;
                case "engine(ortsdoesvacuumbrakecutpower":
                    DoesVacuumBrakeCutPower = stf.ReadBoolBlock(false);
                    break;
                case "engine(ortstracksandersandconsumption":
                    TrackSanderSandConsumptionM3pS = stf.ReadFloatBlock(STFReader.Units.Volume, null);
                    break;
                case "engine(ortstracksanderairconsumption":
                    TrackSanderAirComsumptionM3pS = stf.ReadFloatBlock(STFReader.Units.Volume, null);
                    break;
                case "engine(doesbrakecutpower":
                    DoesBrakeCutPower = stf.ReadBoolBlock(false);
                    break;
                case "engine(brakecutspoweratbrakecylinderpressure":
                    BrakeCutsPowerAtBrakeCylinderPressurePSI = stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break;
                case "engine(ortsbrakecutspoweratbrakepipepressure":
                    BrakeCutsPowerAtBrakePipePressurePSI = stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break;
                case "engine(ortsbrakerestorespoweratbrakepipepressure":
                    BrakeRestoresPowerAtBrakePipePressurePSI = stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break;
                case "engine(doeshorntriggerbell":
                    DoesHornTriggerBell = stf.ReadBoolBlock(false);
                    break;
                case "engine(brakesenginecontrollers":
                    foreach (var brakesenginecontrollers in stf.ReadStringBlock("").ToLower().Replace(" ", "").Split(','))
                    {
                        if (EngineType == EngineType.Electric || EngineType == EngineType.Diesel)
                        {
                            switch (brakesenginecontrollers)
                            {
                                case "blended":
                                    DynamicBrakeBlendingEnabled = true;
                                    break;
                                case "dynamic":
                                    DynamicBrakeAvailable = true;
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                    break;

                case "engine(brakestrainbraketype":
                    foreach (var brakestrainbraketype in stf.ReadStringBlock("").ToLower().Replace(" ", "").Split(','))
                    {
                        switch (brakestrainbraketype)
                        {
                            case "vacuum_single_pipe_eq":
                                VacuumBrakeEQFitted = true;
                                break;
                            default:
                                break;
                        }
                    }
                    break;

                case "engine(brakesenginebraketype":
                    foreach (var brakesenginebraketype in stf.ReadStringBlock("").ToLower().Replace(" ", "").Split(','))
                    {
                        switch (brakesenginebraketype)
                        {
                            case "steam_brake":
                                SteamEngineBrakeFitted = true;
                                break;
                            default:
                                break;
                        }
                    }
                    break;
                case "engine(ortsdynamicblendingoverride":
                    DynamicBrakeBlendingOverride = stf.ReadBoolBlock(false);
                    break;
                case "engine(ortsdynamicblendingforcematch":
                    DynamicBrakeBlendingForceMatch = stf.ReadBoolBlock(false);
                    break;
                case "engine(vacuumbrakeshasvacuumpump":
                    VacuumPumpFitted = stf.ReadBoolBlock(false);
                    break;
                case "engine(enginecontrollers(ortssteamheat":
                    SteamHeatController.Parse(stf);
                    break;
                case "engine(name":
                    stf.MustMatch("(");
                    LocomotiveName = stf.ReadString();
                    break;
                case "engine(maxsteamheatingpressure":
                    MaxSteamHeatPressurePSI = stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break;
                case "engine(ortsonlinecabradio":
                    OnLineCabRadio = stf.ReadBoolBlock(false);
                    break;
                case "engine(ortsonlinecabradiourl":
                    OnLineCabRadioURL = stf.ReadString();
                    break;
                case "engine(vacuumbrakesminboilerpressuremaxvacuum":
                    MaxVaccuumMaxPressurePSI = stf.ReadFloatBlock(STFReader.Units.PressureDefaultPSI, null);
                    break;
                case "engine(enginecontrollers(waterscoop":
                    HasWaterScoop = true;
                    break;
                case "engine(ortswaterscoopfillelevation":
                    WaterScoopFillElevationM = stf.ReadFloatBlock(STFReader.Units.Distance, 0.0f);
                    break;
                case "engine(ortswaterscoopdepth":
                    WaterScoopDepthM = stf.ReadFloatBlock(STFReader.Units.Distance, 0.0f);
                    break;
                case "engine(ortswaterscoopwidth":
                    WaterScoopWidthM = stf.ReadFloatBlock(STFReader.Units.Distance, 0.0f);
                    break;
                case "engine(ortsmaxtracksanderboxcapacity":
                    MaxTrackSandBoxCapacityM3 = stf.ReadFloatBlock(STFReader.Units.Volume, null);
                    break;
                case "engine(ortsmaxtracksandersandconsumption":
                    TrackSanderSandConsumptionM3pS = stf.ReadFloatBlock(STFReader.Units.Volume, null);
                    break;
                case "engine(ortsmaxtracksanderairconsumption":
                    TrackSanderAirComsumptionM3pS = stf.ReadFloatBlock(STFReader.Units.Volume, null);
                    break;
                case "engine(ortscruisecontrol":
                    SetupCruiseControl(stf);
                    break;
                case "engine(ortsmultipositioncontroller":
                    SetupMultiPositionController(stf);
                    break;
                default:
                    base.Parse(lowercasetoken, stf);
                    break;
            }
        }

        /// <summary>
        /// This initializer is called when we are making a new copy of a car already
        /// loaded in memory.  We use this one to speed up loading by eliminating the
        /// need to parse the wag file multiple times.
        /// </summary>
        public override void Copy(MSTSWagon source)
        {
            if (source is not MSTSLocomotive sourceLocomotive)
                throw new InvalidCastException($"Source is not of type {nameof(MSTSLocomotive)}");

            base.Copy(source);  // each derived level initializes its own variables

            CabSoundFileName = sourceLocomotive.CabSoundFileName;
            CVFFileName = sourceLocomotive.CVFFileName;
            CabViews = sourceLocomotive.CabViews;
            CabView3D = sourceLocomotive.CabView3D;
            MaxPowerW = sourceLocomotive.MaxPowerW;
            MaxForceN = sourceLocomotive.MaxForceN;
            MaxCurrentA = sourceLocomotive.MaxCurrentA;
            MaxSpeedMpS = sourceLocomotive.MaxSpeedMpS;
            UnloadingSpeedMpS = sourceLocomotive.UnloadingSpeedMpS;
            SlipControlSystem = sourceLocomotive.SlipControlSystem;
            EngineType = sourceLocomotive.EngineType;
            TractionMotorType = sourceLocomotive.TractionMotorType;
            TractiveForceCurves = sourceLocomotive.TractiveForceCurves;
            MaxContinuousForceN = sourceLocomotive.MaxContinuousForceN;
            SpeedOfMaxContinuousForceMpS = sourceLocomotive.SpeedOfMaxContinuousForceMpS;
            MSTSSpeedOfMaxContinuousForceMpS = sourceLocomotive.MSTSSpeedOfMaxContinuousForceMpS;
            ContinuousForceTimeFactor = sourceLocomotive.ContinuousForceTimeFactor;
            DynamicBrakeForceCurves = sourceLocomotive.DynamicBrakeForceCurves;
            DynamicBrakeAutoBailOff = sourceLocomotive.DynamicBrakeAutoBailOff;
            DynamicBrakeMaxCurrentA = sourceLocomotive.DynamicBrakeMaxCurrentA;
            CombinedControlType = sourceLocomotive.CombinedControlType;
            CombinedControlSplitPosition = sourceLocomotive.CombinedControlSplitPosition;
            DynamicBrakeDelayS = sourceLocomotive.DynamicBrakeDelayS;
            MaxDynamicBrakeForceN = sourceLocomotive.MaxDynamicBrakeForceN;
            HasSmoothStruc = sourceLocomotive.HasSmoothStruc;
            locoNumDrvAxles = sourceLocomotive.locoNumDrvAxles;
            locoNumDrvWheels = sourceLocomotive.locoNumDrvWheels;
            AntiSlip = sourceLocomotive.AntiSlip;
            VacuumPumpFitted = sourceLocomotive.VacuumPumpFitted;
            FastVacuumExhausterFitted = sourceLocomotive.FastVacuumExhausterFitted;
            DrvWheelWeightKg = sourceLocomotive.DrvWheelWeightKg;
            InitialDrvWheelWeightKg = sourceLocomotive.InitialDrvWheelWeightKg;
            SanderSpeedEffectUpToMpS = sourceLocomotive.SanderSpeedEffectUpToMpS;
            SanderSpeedOfMpS = sourceLocomotive.SanderSpeedOfMpS;
            MaxTrackSandBoxCapacityM3 = sourceLocomotive.MaxTrackSandBoxCapacityM3;
            TrackSanderSandConsumptionM3pS = sourceLocomotive.TrackSanderSandConsumptionM3pS;
            TrackSanderAirComsumptionM3pS = sourceLocomotive.TrackSanderAirComsumptionM3pS;
            PowerOnDelayS = sourceLocomotive.PowerOnDelayS;
            DoesHornTriggerBell = sourceLocomotive.DoesHornTriggerBell;
            MaxSteamHeatPressurePSI = sourceLocomotive.MaxSteamHeatPressurePSI;
            VacuumPumpResistanceN = sourceLocomotive.VacuumPumpResistanceN;
            VacuumBrakesMainResVolumeM3 = sourceLocomotive.VacuumBrakesMainResVolumeM3;
            VacuumBrakesMainResMaxVacuumPSIAorInHg = sourceLocomotive.VacuumBrakesMainResMaxVacuumPSIAorInHg;
            VacuumBrakesExhausterRestartVacuumPSIAorInHg = sourceLocomotive.VacuumBrakesExhausterRestartVacuumPSIAorInHg;
            VacuumBrakesMainResChargingRatePSIAorInHgpS = sourceLocomotive.VacuumBrakesMainResChargingRatePSIAorInHgpS;

            EmergencyCausesPowerDown = sourceLocomotive.EmergencyCausesPowerDown;
            EmergencyCausesThrottleDown = sourceLocomotive.EmergencyCausesThrottleDown;
            EmergencyEngagesHorn = sourceLocomotive.EmergencyEngagesHorn;
            WheelslipCausesThrottleDown = sourceLocomotive.WheelslipCausesThrottleDown;

            CompressorIsMechanical = sourceLocomotive.CompressorIsMechanical;
            CompressorRestartPressurePSI = sourceLocomotive.CompressorRestartPressurePSI;
            TrainBrakePipeLeakPSIorInHgpS = sourceLocomotive.TrainBrakePipeLeakPSIorInHgpS;
            MaxMainResPressurePSI = sourceLocomotive.MaxMainResPressurePSI;
            MainResPressurePSI = sourceLocomotive.MaxMainResPressurePSI;
            MaximumMainReservoirPipePressurePSI = sourceLocomotive.MaximumMainReservoirPipePressurePSI;
            MainResVolumeM3 = sourceLocomotive.MainResVolumeM3;
            MainResChargingRatePSIpS = sourceLocomotive.MainResChargingRatePSIpS;
            BrakePipeDischargeTimeFactor = sourceLocomotive.BrakePipeDischargeTimeFactor;
            DriveWheelOnlyBrakes = sourceLocomotive.DriveWheelOnlyBrakes;

            DynamicBrakeBlended = sourceLocomotive.DynamicBrakeBlended;
            DynamicBrakeBlendingEnabled = sourceLocomotive.DynamicBrakeBlendingEnabled;
            DynamicBrakeAvailable = sourceLocomotive.DynamicBrakeAvailable;
            airPipeSystem = sourceLocomotive.airPipeSystem;
            DynamicBrakeCommandStartTime = sourceLocomotive.DynamicBrakeCommandStartTime;
            DynamicBrakeBlendingOverride = sourceLocomotive.DynamicBrakeBlendingOverride;
            DynamicBrakeBlendingForceMatch = sourceLocomotive.DynamicBrakeBlendingForceMatch;

            MainPressureUnit = sourceLocomotive.MainPressureUnit;
            foreach (BrakeSystemComponent component in EnumExtension.GetValues<BrakeSystemComponent>())
                BrakeSystemPressureUnits[component] = sourceLocomotive.BrakeSystemPressureUnits[component];

            ThrottleController = (MSTSNotchController)sourceLocomotive.ThrottleController.Clone();
            SteamHeatController = (MSTSNotchController)sourceLocomotive.SteamHeatController.Clone();
            TrainBrakeController = ScriptedBrakeController.From(TrainBrakeController, this);
            EngineBrakeController = ScriptedBrakeController.From(EngineBrakeController, this);
            BrakemanBrakeController = ScriptedBrakeController.From(BrakemanBrakeController, this);
            DynamicBrakeController = sourceLocomotive.DynamicBrakeController != null ? (MSTSNotchController)sourceLocomotive.DynamicBrakeController.Clone() : null;
            DistributedPowerThrottleController = (MSTSNotchController)ThrottleController.Clone();
            if (DynamicBrakeController != null)
            {
                if (DynamicBrakeController.NotchCount() > 3)
                    DistributedPowerDynamicBrakeController = (MSTSNotchController)DynamicBrakeController.Clone();
                else
                    DistributedPowerDynamicBrakeController = BuildDPDynamicBrakeController();
            }
            else
                DistributedPowerDynamicBrakeController = null;

            LocomotivePowerSupply.Copy(sourceLocomotive.LocomotivePowerSupply);
            TrainControlSystem.Copy(sourceLocomotive.TrainControlSystem);
            LocomotiveName = sourceLocomotive.LocomotiveName;
            MaxVaccuumMaxPressurePSI = sourceLocomotive.MaxVaccuumMaxPressurePSI;
            VacuumBrakeEQFitted = sourceLocomotive.VacuumBrakeEQFitted;
            TrainBrakeFitted = sourceLocomotive.TrainBrakeFitted;
            EngineBrakeFitted = sourceLocomotive.EngineBrakeFitted;
            BrakemanBrakeFitted = sourceLocomotive.BrakemanBrakeFitted;
            SteamEngineBrakeFitted = sourceLocomotive.SteamEngineBrakeFitted;
            HasWaterScoop = sourceLocomotive.HasWaterScoop;
            WaterScoopFillElevationM = sourceLocomotive.WaterScoopFillElevationM;
            WaterScoopDepthM = sourceLocomotive.WaterScoopDepthM;
            WaterScoopWidthM = sourceLocomotive.WaterScoopWidthM;
            MoveParamsToAxle();
            if (sourceLocomotive.CruiseControl != null)
                CruiseControl = new CruiseControl(sourceLocomotive.CruiseControl, this);
            MultiPositionControllers = CloneMultiPositionController(sourceLocomotive);
        }

        /// <summary>
        /// We are moving parameters from locomotive to axle. 
        /// </summary>
        public void MoveParamsToAxle()
        {
            if (LocomotiveAxle != null)
            {
                LocomotiveAxle.SlipWarningTresholdPercent = SlipWarningThresholdPercent;
                LocomotiveAxle.AdhesionK = AdhesionK;
            }
        }

        public override async ValueTask<TrainCarSaveState> Snapshot()
        {
            TrainCarSaveState saveState = await base.Snapshot().ConfigureAwait(false);

            saveState.LocomotiveSaveState = new LocomotiveSaveState()
            {
                Bell = Bell,
                Sander = Sander,
                Wiper = Wiper,
                VacuumExhauster = VacuumExhausterPressed,
                OdometerVisible = OdometerVisible,
                OdometerCountingForward = odometerCountingForwards,
                OdometerCountingUp = odometerCountingUp,
                OdometerResetPosition = odometerResetPositionM,
                MainReservoirPressure = MainResPressurePSI,
                CompressorActive = CompressorIsOn,
                VacuumMainReservoirVacuum = VacuumMainResVacuumPSIAorInHg,
                VacuumExhausterActive = VacuumExhausterIsOn,
                TrainBrakePipeLeak = TrainBrakePipeLeakPSIorInHgpS,
                AverageForce = AverageForceN,
                AxleSpeed = LocomotiveAxle.AxleSpeedMpS,
                CabLight = CabLightOn,
                RearCab = UsingRearCab,
                CalculatedCarHeaterSteamUsage = CalculatedCarHeaterSteamUsageLBpS,
                ThrottleController = ThrottleController == null ? null : await ThrottleController.Snapshot().ConfigureAwait(false),
                TrainBrakeController = TrainBrakeController == null ? null : await TrainBrakeController.Snapshot().ConfigureAwait(false),
                EngineBrakeController = EngineBrakeController == null ? null : await EngineBrakeController.Snapshot().ConfigureAwait(false),
                BrakemanBrakeController = BrakemanBrakeController == null ? null : await BrakemanBrakeController.Snapshot().ConfigureAwait(false),
                DynamicBrakeController = DynamicBrakeController == null ? null : await DynamicBrakeController.Snapshot().ConfigureAwait(false),
                SteamHeatController = SteamHeatController == null ? null : await SteamHeatController.Snapshot().ConfigureAwait(false),
                PowerReduction = PowerReduction,
                ScoopBroken = ScoopIsBroken,
                WaterScoopDown = WaterScoopDown,
                CurrentTrackSandBoxCapacity = CurrentTrackSandBoxCapacityM3,
                AdhesionFilter = saveAdhesionFilter,
                GenericItem1 = GenericItem1,
                GenericItem2 = GenericItem2,
                RemoteControlGroup = RemoteControlGroup,
                DistributedPowerUnitId = DistributedPowerUnitId,
                PreviousGearBoxNotch = previousGearBoxNotch,
                PreviousChangedGearBoxNotch = previousChangedGearBoxNotch,
                CurrentLocomotiveSteamHeatBoilerWaterCapacity = CurrentLocomotiveSteamHeatBoilerWaterCapacityL,
                TrainControlSystemSaveState = TrainControlSystem == null ? null : await TrainControlSystem.Snapshot().ConfigureAwait(false),

                AxleSaveState = await LocomotiveAxle.Snapshot().ConfigureAwait(false),
                CruiseControlSaveState = CruiseControl == null ? null : await CruiseControl.Snapshot().ConfigureAwait(false),
                PowerSupplySaveState = LocomotivePowerSupply == null ? null : await LocomotivePowerSupply.Snapshot().ConfigureAwait(false),
            };

            return saveState;
        }

        public override async ValueTask Restore([NotNull] TrainCarSaveState saveState)
        {
            await base.Restore(saveState).ConfigureAwait(false);

            ArgumentNullException.ThrowIfNull(saveState.LocomotiveSaveState, nameof(saveState.LocomotiveSaveState));

            LocomotiveSaveState locomotiveSaveState = saveState.LocomotiveSaveState;

            if (locomotiveSaveState.Bell)
                SignalEvent(TrainEvent.BellOn);
            if (locomotiveSaveState.Sander)
                SignalEvent(TrainEvent.SanderOn);
            if (locomotiveSaveState.VacuumExhauster)
                SignalEvent(TrainEvent.VacuumExhausterOn);
            if (locomotiveSaveState.Wiper)
                SignalEvent(TrainEvent.WiperOn);

            odometerResetPositionM = (float)locomotiveSaveState.OdometerResetPosition;
            odometerCountingUp = locomotiveSaveState.OdometerCountingUp;
            odometerCountingForwards = locomotiveSaveState.OdometerCountingForward;
            OdometerVisible = locomotiveSaveState.OdometerVisible;
            MainResPressurePSI = locomotiveSaveState.MainReservoirPressure;
            CompressorIsOn = locomotiveSaveState.CompressorActive;
            VacuumMainResVacuumPSIAorInHg = locomotiveSaveState.VacuumMainReservoirVacuum;
            VacuumExhausterIsOn = locomotiveSaveState.VacuumExhausterActive;
            TrainBrakePipeLeakPSIorInHgpS = locomotiveSaveState.TrainBrakePipeLeak;
            AverageForceN = locomotiveSaveState.AverageForce;
            float axleSpeedMpS = locomotiveSaveState.AxleSpeed;
            CabLightOn = locomotiveSaveState.CabLight;
            UsingRearCab = locomotiveSaveState.RearCab;
            CalculatedCarHeaterSteamUsageLBpS = (float)locomotiveSaveState.CalculatedCarHeaterSteamUsage;
            if (locomotiveSaveState.ThrottleController != null)
                await ThrottleController.Restore(locomotiveSaveState.ThrottleController).ConfigureAwait(false);
            if (locomotiveSaveState.TrainBrakeController != null)
                await TrainBrakeController.Restore(locomotiveSaveState.TrainBrakeController).ConfigureAwait(false);
            if (locomotiveSaveState.EngineBrakeController != null)
                await EngineBrakeController.Restore(locomotiveSaveState.EngineBrakeController).ConfigureAwait(false);
            if (locomotiveSaveState.BrakemanBrakeController != null)
                await BrakemanBrakeController.Restore(locomotiveSaveState.BrakemanBrakeController).ConfigureAwait(false);
            if (locomotiveSaveState.DynamicBrakeController != null)
                await DynamicBrakeController.Restore(locomotiveSaveState.DynamicBrakeController).ConfigureAwait(false);
            if (locomotiveSaveState.SteamHeatController != null)
                await SteamHeatController.Restore(locomotiveSaveState.SteamHeatController).ConfigureAwait(false);
            PowerReduction = locomotiveSaveState.PowerReduction;
            ScoopIsBroken = locomotiveSaveState.ScoopBroken;
            IsWaterScoopDown = locomotiveSaveState.WaterScoopDown;
            CurrentTrackSandBoxCapacityM3 = locomotiveSaveState.CurrentTrackSandBoxCapacity;

            saveAdhesionFilter = locomotiveSaveState.AdhesionFilter;

            adhesionFilter.Reset(saveAdhesionFilter);

            GenericItem1 = locomotiveSaveState.GenericItem1;
            GenericItem2 = locomotiveSaveState.GenericItem2;
            RemoteControlGroup = locomotiveSaveState.RemoteControlGroup;
            DistributedPowerUnitId = locomotiveSaveState.DistributedPowerUnitId;
            previousGearBoxNotch = locomotiveSaveState.PreviousGearBoxNotch;
            previousChangedGearBoxNotch = locomotiveSaveState.PreviousChangedGearBoxNotch;
            CurrentLocomotiveSteamHeatBoilerWaterCapacityL = locomotiveSaveState.CurrentLocomotiveSteamHeatBoilerWaterCapacity;

            if (null != LocomotivePowerSupply)
                await LocomotivePowerSupply.Restore(locomotiveSaveState.PowerSupplySaveState).ConfigureAwait(false);
            await TrainControlSystem.Restore(locomotiveSaveState.TrainControlSystemSaveState).ConfigureAwait(false);

            LocomotiveAxle = new Axle();
            await LocomotiveAxle.Restore(locomotiveSaveState.AxleSaveState).ConfigureAwait(false);
            MoveParamsToAxle();
            LocomotiveAxle.Reset(simulator.GameTime, axleSpeedMpS);
            if (null != CruiseControl)
                await CruiseControl.Restore(locomotiveSaveState.CruiseControlSaveState).ConfigureAwait(false);
        }

        public bool IsLeadLocomotive()
        {
            return Train.LeadLocomotive == this;
        }

        protected void ParseCombData(string lowercasetoken, STFReader stf)
        {
            var throttle = false;
            var train = false;
            var dynamic = false;
            var independent = false;

            stf.MustMatch("(");
            var minValue = stf.ReadFloat(STFReader.Units.None, 0);
            var maxValue = stf.ReadFloat(STFReader.Units.None, 1);
            var split = stf.ReadFloat(STFReader.Units.None, 0.5f);
            var defaultValue = stf.ReadFloat(STFReader.Units.None, 0.5f);

            string s;
            while ((s = stf.ReadItem()) != ")")
            {
                throttle |= s == "throttle";
                train |= s == "train";
                dynamic |= s == "dynamic";
                independent |= s == "independent";
            }

            CombinedControlSplitPosition = (split - minValue) / (maxValue - minValue);

            if (throttle && dynamic && train)
                CombinedControlType = CombinedControl.ThrottleDynamicAir;
            else if (throttle && train)
                CombinedControlType = CombinedControl.ThrottleAir;
            else if (throttle && dynamic)
                CombinedControlType = CombinedControl.ThrottleDynamic;
            else if (dynamic && train)
                CombinedControlType = CombinedControl.DynamicAir;

            if (train && !TrainBrakeController.IsValid())
                TrainBrakeController = new ScriptedBrakeController(this);
            if (dynamic && !DynamicBrakeController.IsValid())
                DynamicBrakeController = new MSTSNotchController(0, 1, .05f);
            if (dynamic)
                DynamicBrake = true;
        }

        /// <summary>
        /// Sets controler settings from other engine for cab switch
        /// </summary>
        /// <param name="source"></param>
        public override void CopyControllerSettings(TrainCar source)
        {
            base.CopyControllerSettings(source);
            if (ThrottleController != null)
                ThrottleController.SetValue(source.ThrottlePercent / 100);
            if (DynamicBrakeController != null)
                DynamicBrakeController.SetValue(source.DynamicBrakePercent / 100);
            if (TrainBrakeController != null)
                TrainBrakeController.SetValue(((MSTSLocomotive)source).TrainBrakeController.CurrentValue);
            if (EngineBrakeController != null)
                EngineBrakeController.SetValue(0);
            if (BrakemanBrakeController != null)
                BrakemanBrakeController.SetValue(0);
        }

        /// <summary>
        /// Called just after the InitializeFromWagFile
        /// </summary>
        public override void Initialize()
        {

            TrainBrakeController.Initialize();
            EngineBrakeController.Initialize();
            BrakemanBrakeController.Initialize();
            LocomotivePowerSupply?.Initialize();
            TrainControlSystem.Initialize();
            CruiseControl?.Initialize();
            foreach (MultiPositionController multiPositionController in MultiPositionControllers)
            {
                multiPositionController.Initialize();
            }
            IsSteamHeatFitted = MaxSteamHeatPressurePSI != 0;

            SteamHeatPressureToTemperaturePSItoF = SteamTable.SteamHeatPressureToTemperatureInterpolatorPSItoF();
            SteamDensityPSItoLBpFT3 = SteamTable.SteamDensityInterpolatorPSItoLBpFT3();
            SteamHeatPSItoBTUpLB = SteamTable.SteamHeatInterpolatorPSItoBTUpLB();

            // Check to see if water scoop elements have been configured
            if (WaterScoopFillElevationM == 0)
            {
                WaterScoopFillElevationM = 2.7432f; // Set to default of 9 ft
            }

            if (WaterScoopDepthM == 0)
            {
                WaterScoopDepthM = 0.0889f; // Set to default of 3.5 ins
            }

            if (WaterScoopWidthM == 0)
            {
                WaterScoopWidthM = 0.3048f; // Set to default of 1 ft
            }

            // Check if current sander has been set
            if (CurrentTrackSandBoxCapacityM3 == 0)
            {
                CurrentTrackSandBoxCapacityM3 = MaxTrackSandBoxCapacityM3;
            }

            // Ensure Drive Axles is set with a default value if user doesn't supply an OR value in ENG file
            if (locoNumDrvAxles == 0)
            {
                if (locoNumDrvWheels != 0 && locoNumDrvWheels < 6)
                {
                    locoNumDrvAxles = (int)locoNumDrvWheels;
                }
                else
                {
                    locoNumDrvAxles = 4; // Set 4 axles as default
                }

                if (simulator.Settings.VerboseConfigurationMessages)
                {
                    Trace.TraceInformation("Number of Locomotive Drive Axles set to default value of {0}", locoNumDrvAxles);
                }
            }
            if (TractionMotorType == TractionMotorType.AC)
            {
                InductionMotor motor = new InductionMotor(LocomotiveAxle, this);
            }


            // Calculate minimum speed to pickup water
            const float Aconst = 2;
            WaterScoopMinSpeedMpS = (float)Size.Length.FromFt(Math.Sqrt(Aconst * GravitationalAccelerationFtpSpS * Size.Length.ToFt(WaterScoopFillElevationM)));


            if (MaxMainResPressurePSI == 0)
            {
                MaxMainResPressurePSI = 130;
            }

            MainResPressurePSI = MaxMainResPressurePSI;

            if (MainResVolumeM3 == 0)
            {
                MainResVolumeM3 = 0.3f;
            }

            // Initialise Brake Pipe Charging Rate
            if (BrakePipeChargingRatePSIorInHgpS == 0) // Check to see if BrakePipeChargingRate has been set in the ENG file.
            {
                // Set Default BrakePipe Charging Rate depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakePipeChargingRatePSIorInHgpS = 0.32f; // Vacuum brakes
                }
                else
                {
                    BrakePipeChargingRatePSIorInHgpS = simulator.Settings.BrakePipeChargingRate; // Air brakes
                }
            }
            // Initialise Brake Pipe Quick Charging Rate
            if (BrakePipeQuickChargingRatePSIpS == 0)
                BrakePipeQuickChargingRatePSIpS = BrakePipeChargingRatePSIorInHgpS;

            // Initialise Exhauster Charging rate in diesel, control cars and electric locomotives. The equivalent ejector charging rates are set in the steam locomotive.
            if (this is MSTSDieselLocomotive || this is MSTSElectricLocomotive || this is MSTSControlTrailerCar)
            {
                ExhausterHighSBPChargingRatePSIorInHgpS = BrakePipeChargingRatePSIorInHgpS;
                ExhausterLowSBPChargingRatePSIorInHgpS = BrakePipeChargingRatePSIorInHgpS / 5.0f; // Low speed exhauster setting is 1/5 of high speed
            }
            else
            {
                // Default to zero if not used.
                ExhausterHighSBPChargingRatePSIorInHgpS = 0.0f;
                ExhausterLowSBPChargingRatePSIorInHgpS = 0.0f;
            }

            // Initialise BrakePipeDischargeTimeFactor
            if (BrakePipeDischargeTimeFactor == 0)
            {
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakePipeDischargeTimeFactor = 1.5f; // Vacuum brakes
                }
                else
                {
                    BrakePipeDischargeTimeFactor = 1.5f; // Air brakes
                }
            }

            // Initialise the resistance of the vacuum pump
            if (VacuumPumpResistanceN == 0)
            {
                VacuumPumpResistanceN = 120.0f;
            }

            // Initialise Brake Emergency Time Factor
            if (BrakeEmergencyTimeFactorPSIpS == 0) // Check to see if BrakeEmergencyTimeFactorS has been set in the ENG file.
            {
                // Set Default Brake Emergency Time Factor depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakeEmergencyTimeFactorPSIpS = 1.0f; // Vacuum brakes
                }
                else
                {
                    BrakeEmergencyTimeFactorPSIpS = 0.1f; // Air brakes
                }
            }

            // Initialise Brake Service Time Factor
            if (BrakeServiceTimeFactorPSIpS == 0) // Check to see if BrakeServiceTimeFactorS has been set in the ENG file.
            {
                // Set Default Brake Service Time Factor depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakeServiceTimeFactorPSIpS = 10.0f; // Vacuum brakes
                }
                else
                {
                    BrakeServiceTimeFactorPSIpS = 1.009f; // Air brakes
                }
            }

            // MaximumMainReservoirPipePressurePSI is only used in twin pipe system, and should have a value
            if ((BrakeSystem is AirTwinPipe))
            {

                // for airtwinpipe system, make sure that a value is set for it
                if (MaximumMainReservoirPipePressurePSI == 0)
                {
                    MaximumMainReservoirPipePressurePSI = MaxMainResPressurePSI;
                    if (simulator.Settings.VerboseConfigurationMessages)
                    {
                        Trace.TraceInformation("AirBrakeMaxMainResPipePressure not set in ENG file, set to default pressure of {0}.", FormatStrings.FormatPressure(MaximumMainReservoirPipePressurePSI, Pressure.Unit.PSI, MainPressureUnit, true));
                    }

                }
            }
            else if ((BrakeSystem is AirSinglePipe) && MaximumMainReservoirPipePressurePSI != 0)
            {

                // if value not equal to MaxMainResPressurePSI then reset (could already be at this value due to "copying" of locomotive)
                if (MaximumMainReservoirPipePressurePSI != MaxMainResPressurePSI)
                {
                    // for a airsinglepipe system, AirBrakeMaxMainResPipePressure should be left out of ENG file, and it should be set the same as MaxMainResPressurePSI
                    MaximumMainReservoirPipePressurePSI = MaxMainResPressurePSI;
                    if (simulator.Settings.VerboseConfigurationMessages)
                    {
                        Trace.TraceInformation("AirBrakeMaxMainResPipePressure is set in ENG file, but should not be normally used for AirSinglePipe system, reset to default pressure of {0}. Consider removing AirBrakeMaxMainResPipePressure parameter from ENG file", FormatStrings.FormatPressure(MaximumMainReservoirPipePressurePSI, Pressure.Unit.PSI, MainPressureUnit, true));
                    }
                }
            }
            else
            {
                // normal default setting. This should be the normal case for airsinglepipe systems
                MaximumMainReservoirPipePressurePSI = MaxMainResPressurePSI;
            }

            // Check TrainBrakesControllerMaxSystemPressure parameter for "correct" value 
            // This is only done for vacuum brakes as the UoM can be confusing - it defaults to psi due to way parameter is read, and if units are entered then a InHG value can be incorrectly converted.
            if ((BrakeSystem is VacuumSinglePipe))
            {
                if (TrainBrakeController.MaxPressurePSI == 21 || TrainBrakeController.MaxPressurePSI == 25) // If 21 or 25 has been entered assume that it is 21InHg or 25InHg, and convert it to the correct psi equivalent
                {
                    float TempMaxPressure = TrainBrakeController.MaxPressurePSI;

                    // Convert assumed inHg value to psi
                    TrainBrakeController.MaxPressurePSI = (float)Pressure.Atmospheric.ToPSI(Pressure.Atmospheric.FromInHg(TrainBrakeController.MaxPressurePSI));

                    if (simulator.Settings.VerboseConfigurationMessages)
                    {
                        Trace.TraceInformation("TrainBrakeController.MaxPressurePSI is assumed to be {0} Inhg, - confirmed as a value of {1} InHg", TempMaxPressure, Pressure.Atmospheric.ToInHg(Pressure.Atmospheric.FromPSI(TrainBrakeController.MaxPressurePSI)));
                    }

                }
                else if (TrainBrakeController.MaxPressurePSI < 7 || TrainBrakeController.MaxPressurePSI > 13) // Outside an acceptable range (Eqiv = 15InHg to 25InHg), then convert to a fixed default
                {
                    if (simulator.Settings.VerboseConfigurationMessages)
                    {
                        Trace.TraceInformation("TrainBrakeController.MaxPressurePSI being incorrectly read as {0} Inhg, - set to a default value of {1} InHg", TrainBrakeController.MaxPressurePSI, Pressure.Atmospheric.ToInHg(Pressure.Atmospheric.FromPSI(Pressure.Atmospheric.ToPSI(Pressure.Atmospheric.FromInHg(21.0f)))));
                    }
                    TrainBrakeController.MaxPressurePSI = (float)Pressure.Atmospheric.ToPSI(Pressure.Atmospheric.FromInHg(21.0f));
                }

            }

            if (DoesBrakeCutPower && BrakeCutsPowerAtBrakePipePressurePSI > BrakeRestoresPowerAtBrakePipePressurePSI)
            {
                BrakeCutsPowerAtBrakePipePressurePSI = BrakeRestoresPowerAtBrakePipePressurePSI - 1.0f;

                if (simulator.Settings.VerboseConfigurationMessages)
                {
                    Trace.TraceInformation("BrakeCutsPowerAtBrakePipePressure is greater then BrakeRestoresPowerAtBrakePipePressurePSI, and has been set to value of {0} InHg", Pressure.Atmospheric.ToInHg(Pressure.Atmospheric.FromPSI(BrakeCutsPowerAtBrakePipePressurePSI)));
                }
            }

            if (DoesBrakeCutPower && (BrakeSystem is VacuumSinglePipe) && (BrakeRestoresPowerAtBrakePipePressurePSI == 0 || BrakeRestoresPowerAtBrakePipePressurePSI > Const.OneAtmospherePSI))
            {
                BrakeRestoresPowerAtBrakePipePressurePSI = (float)Pressure.Atmospheric.ToPSI(Pressure.Atmospheric.FromInHg(15.0f)); // Power can be restored once brake pipe rises above 15 InHg

                if (simulator.Settings.VerboseConfigurationMessages)
                {
                    Trace.TraceInformation("BrakeRestoresPowerAtBrakePipePressure appears out of limits, and has been set to value of {0} InHg", Pressure.Atmospheric.ToInHg(Pressure.Atmospheric.FromPSI(BrakeRestoresPowerAtBrakePipePressurePSI)));
                }
            }

            // Initialise Brake Time Factor
            if (BrakePipeTimeFactorS == 0) // Check to see if BrakePipeTimeFactorS has been set in the ENG file.
            {
                // Set Default Brake Pipe Time Factor depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakePipeTimeFactorS = 0.02f; // Vacuum brakes
                }
                else
                {
                    BrakePipeTimeFactorS = 0.0015f; // Air brakes
                }
            }

            // Initialise Train Pipe Leak Rate
            if (TrainBrakePipeLeakPSIorInHgpS == 0) // Check to see if TrainBrakePipeLeakPSIorInHgpS has been set in the ENG file.
            {
                // Set Default Train Brake Pipe Leak depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                // Default currently set to zero - means that by default function is off, and a value must be entered into the ENG file to get it to work
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    TrainBrakePipeLeakPSIorInHgpS = 0.0f; // Vacuum brakes
                }
                else
                {
                    TrainBrakePipeLeakPSIorInHgpS = 0.0f; // Air brakes
                }
            }

            base.Initialize();
            if (DynamicBrakeBlendingEnabled)
                airPipeSystem = BrakeSystem as AirSinglePipe;

        }

        /// <summary>
        /// Make instance of Cruise Control and Initialize it
        /// </summary>
        private void SetupCruiseControl(STFReader stf)
        {
            CruiseControl = new CruiseControl(this);
            CruiseControl.Parse(stf);
        }

        /// <summary>
        /// Make instance of multi position controller
        /// </summary>
        private void SetupMultiPositionController(STFReader stf)
        {
            MultiPositionController multiPositionController = new MultiPositionController(this);
            multiPositionController.Parse(stf);
            MultiPositionControllers.Add(multiPositionController);
        }

        private Collection<MultiPositionController> CloneMultiPositionController(MSTSLocomotive locomotive)
        {
            Collection<MultiPositionController> multiPositionControllers = new Collection<MultiPositionController>();
            foreach (MultiPositionController mpc in MultiPositionControllers)
            {
                multiPositionControllers.Add(new MultiPositionController(mpc, locomotive));
            }
            return multiPositionControllers;
        }

        /// <summary>
        /// Set starting conditions  when initial speed > 0 
        /// </summary>
        /// 
        public override void InitializeMoving()
        {
            base.InitializeMoving();
            LocomotiveAxle.Reset(simulator.GameTime, SpeedMpS);
            adhesionFilter.Reset(0.5f);
            AverageForceN = MaxForceN * Train.MUThrottlePercent / 100;
            float maxPowerW = MaxPowerW * Train.MUThrottlePercent * Train.MUThrottlePercent / 10000;
            if (AverageForceN * SpeedMpS > maxPowerW)
                AverageForceN = maxPowerW / SpeedMpS;
            LocomotivePowerSupply?.InitializeMoving();
            if (Train.IsActualPlayerTrain)
            {
                TrainControlSystem.InitializeMoving();
                TrainBrakeController.InitializeMoving();
                BrakeSystem.LocoInitializeMoving();
                EngineBrakeController?.InitializeMoving();
            }
        }

        //================================================================================================//
        /// <summary>
        /// Correct braking parameters if needed or required 
        /// </summary>
        /// 
        protected void CorrectBrakingParams()
        {
            if (simulator.Settings.CorrectQuestionableBrakingParams || simulator.Settings.SimpleControlPhysics)
            {
                if (!(BrakeSystem is EPBrakeSystem) && !(BrakeSystem is VacuumSinglePipe) && !(BrakeSystem is AirTwinPipe))
                {
                    if (CompressorRestartPressurePSI - TrainBrakeController.MaxPressurePSI < DefaultCompressorRestartToMaxSysPressureDiff - 10)
                    {
                        CompressorRestartPressurePSI = Math.Max(CompressorRestartPressurePSI, Math.Min(TrainBrakeController.MaxPressurePSI + DefaultCompressorRestartToMaxSysPressureDiff, DefaultMaxCompressorRestartPressure));
                        MainResPressurePSI = MaxMainResPressurePSI = Math.Max(MaxMainResPressurePSI, Math.Min(CompressorRestartPressurePSI + DefaultMaxMainResToCompressorRestartPressureDiff, DefaultMaxMainResPressure));

                    }
                    if (MainResVolumeM3 < 0.3f && MassKG > 20000)
                        MainResVolumeM3 = DefaultMainResVolume;

                    // correct questionable MaxCylPressurePSI
                    BrakeSystem.CorrectMaxCylPressurePSI(this);
                }
                if (MainResChargingRatePSIpS <= 0)
                {
                    MainResChargingRatePSIpS = (float)Math.Max(0.5, (CompressorChargingRateM3pS * Pressure.Atmospheric.ToPSI(1)) / MainResVolumeM3);
                }
            }
            else if (MainResChargingRatePSIpS <= 0)
                MainResChargingRatePSIpS = 0.4f;

            // Corrections for dynamic braking parameters

            if (this is MSTSElectricLocomotive && DynamicBrakeDelayS > 4)
                DynamicBrakeDelayS = 2; // Electric locomotives have short engaging delays
            if (DynamicBrakeSpeed2MpS > 0 && DynamicBrakeSpeed3MpS > 0 && DynamicBrakeSpeed2MpS > DynamicBrakeSpeed3MpS)
            {
                // also exchanging DynamicBrakesMaximumEffectiveSpeed with DynamicBrakesFadingSpeed is a frequent error that upsets operation of
                // dynamic brakes
                var temp = DynamicBrakeSpeed2MpS;
                DynamicBrakeSpeed2MpS = DynamicBrakeSpeed3MpS;
                DynamicBrakeSpeed3MpS = temp;
            }
            if (simulator.Settings.CorrectQuestionableBrakingParams)
            {
                if (MaxDynamicBrakeForceN > 0 && MaxContinuousForceN > 0 &&
                (MaxDynamicBrakeForceN / MaxContinuousForceN < 0.3f && MaxDynamicBrakeForceN == 20000))
                    MaxDynamicBrakeForceN = Math.Min(MaxContinuousForceN * 0.5f, 150000); // 20000 is suggested as standard value in the MSTS documentation, but in general it is a too low value
            }
        }

        /// <summary>
        /// Dynamic brake blending 
        /// </summary>
        public void DynamicBrakeBlending(double elapsedClockSeconds)
        {
            if (Math.Abs(SpeedMpS) > DynamicBrakeSpeed1MpS && airPipeSystem != null && ((airPipeSystem is EPBrakeSystem && Train.BrakeSystem.BrakeLine4Pressure > 0f) || airPipeSystem.BrakeLine1PressurePSI < TrainBrakeController.MaxPressurePSI - 1f)
                && ThrottleController.CurrentValue == 0f && !(DynamicBrakeController != null && DynamicBrakeBlendingOverride && DynamicBrakeController.CurrentValue > 0f)
                /* && (!DynamicBrakeBlendingLeverOverride && DynamicBrakeController != null && DynamicBrakeIntervention < DynamicBrakeController.CurrentValue)*/)
            {
                float threshold = DynamicBrakeBlendingForceMatch ? 100f : 0.01f;
                float maxCylPressurePSI = airPipeSystem.MaxCylPressurePSI;
                double targetDynamicBrakePercent = airPipeSystem is EPBrakeSystem ? Train.BrakeSystem.BrakeLine4Pressure : Math.Min(((TrainBrakeController.MaxPressurePSI - airPipeSystem.BrakeLine1PressurePSI) * airPipeSystem.AuxCylVolumeRatio) / maxCylPressurePSI, 1f);
                //DynamicBrakeIntervention = Math.Min(((TrainBrakeController.CurrentValue - DynamicBrakeBlendingStart) / (DynamicBrakeBlendingStop - DynamicBrakeBlendingStart)), 1f);

                if (!DynamicBrakeBlended)
                {
                    DynamicBrakeBlended = true;
                    if (DynamicBrakeController != null)
                        DynamicBrakeIntervention = DynamicBrakeController.CurrentValue;
                    else
                        DynamicBrakeIntervention = 0;
                    DynamicBrakeCommandStartTime = simulator.ClockTime;
                }
                if (DynamicBrake)
                {
                    double diff = DynamicBrakeBlendingForceMatch ? targetDynamicBrakePercent * MaxBrakeForceN - DynamicBrakeForceN : targetDynamicBrakePercent - DynamicBrakeIntervention;
                    if (diff > threshold && DynamicBrakeIntervention <= 1)
                        DynamicBrakeIntervention = (float)Math.Min(DynamicBrakeIntervention + elapsedClockSeconds * (airPipeSystem.MaxApplicationRatePSIpS / maxCylPressurePSI), 1.0f);
                    else if (diff < -threshold)
                        DynamicBrakeIntervention -= (float)elapsedClockSeconds * (airPipeSystem.MaxReleaseRatePSIpS / maxCylPressurePSI);
                }
                if (DynamicBrakeController != null)
                    DynamicBrakeIntervention = Math.Max(DynamicBrakeIntervention, DynamicBrakeController.CurrentValue);
            }
            else if (DynamicBrakeBlended)
            {
                DynamicBrakeIntervention = -1;
                DynamicBrakeBlended = false;
            }
        }

        /// <summary>
        /// This function updates periodically the states and physical variables of the locomotive's subsystems.
        /// </summary>
        public override void Update(double elapsedClockSeconds)
        {
            // A control car typically doesn't have its own compressor and relies on the attached power car. However OR uses the lead locomotive as the reference car for compressor calculations.
            // Hence whilst users are encouraged to leave these parameters out of the ENG file, they need to be setup for OR to work correctly.
            // Some parameters need to be split across the unpowered and powered car for correct timing and volume calculations.
            // This setup loop is only processed the first time that update is run.
            if (EngineType == EngineType.Control && !controlTrailerBrakeSystemSet)
            {
                FindControlActiveLocomotive();

                if (ControlActiveLocomotive != null)
                {
                    // Split reservoir volume across the power car and the active locomotive
                    MainResVolumeM3 = ControlActiveLocomotive.MainResVolumeM3 / 2;
                    ControlActiveLocomotive.MainResVolumeM3 = MainResVolumeM3;

                    MaxMainResPressurePSI = ControlActiveLocomotive.MaxMainResPressurePSI;
                    MainResPressurePSI = MaxMainResPressurePSI;
                    ControlActiveLocomotive.MainResPressurePSI = MainResPressurePSI;
                    controlTrailerBrakeSystemSet = true; // Ensure this loop is only processes the first time update routine run
                    MaximumMainReservoirPipePressurePSI = ControlActiveLocomotive.MaximumMainReservoirPipePressurePSI;
                    CompressorRestartPressurePSI = ControlActiveLocomotive.CompressorRestartPressurePSI;
                    MainResChargingRatePSIpS = ControlActiveLocomotive.MainResChargingRatePSIpS;
                    BrakePipeChargingRatePSIorInHgpS = ControlActiveLocomotive.BrakePipeChargingRatePSIorInHgpS;
                    TrainBrakePipeLeakPSIorInHgpS = ControlActiveLocomotive.TrainBrakePipeLeakPSIorInHgpS;
                }
            }

            if (this is MSTSDieselLocomotive dieselLocomotive)
            {
                // Pass Gearbox commands
                // Note - at the moment there is only one GearBox Controller created, but a gearbox for each diesel engine is created. 
                // This code keeps all gearboxes in the locomotive aligned with the first engine and gearbox.
                if (dieselLocomotive.DieselTransmissionType == DieselTransmissionType.Mechanic && GearBoxController.NotchIndex != previousChangedGearBoxNotch)
                {
                    // don't change the first engine as this is the reference for all the others
                    for (int i = 1; i < dieselLocomotive.DieselEngines.Count; i++)
                    {
                        dieselLocomotive.DieselEngines[i].GearBox.CurrentGearIndex = dieselLocomotive.DieselEngines[0].GearBox.CurrentGearIndex;
                    }
                    previousChangedGearBoxNotch = GearBoxController.NotchIndex; // reset loop until next gear change

                    if (IsLeadLocomotive())
                    {
                        // The lead locomotive passes gearbox commands position to other locomotives in train, don't treat the player locomotive in this fashion.
                        foreach (MSTSDieselLocomotive locomotive in Train.Cars.OfType<MSTSDieselLocomotive>())
                        {
                            if (locomotive != this && locomotive.DieselTransmissionType == DieselTransmissionType.Mechanic && GearBoxController.NotchIndex != previousChangedGearBoxNotch && !locomotive.IsLeadLocomotive())
                            {
                                locomotive.DieselEngines[0].GearBox.CurrentGearIndex = dieselLocomotive.DieselEngines[0].GearBox.CurrentGearIndex;
                                locomotive.GearBoxController.NotchIndex = dieselLocomotive.DieselEngines[0].GearBox.CurrentGearIndex + 1;
                                locomotive.GearboxGearIndex = dieselLocomotive.DieselEngines[0].GearBox.CurrentGearIndex + 1;
                                locomotive.GearBoxController.SetValue(dieselLocomotive.GearBoxController.NotchIndex);

                                simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Increase, locomotive.GearBoxController.NotchIndex);
                                locomotive.AlerterReset(TCSEvent.GearBoxChanged);
                                locomotive.SignalGearBoxChangeEvents();
                            }
                        }
                    }
                }
            }

            TrainControlSystem.Update(elapsedClockSeconds);

            LocomotivePowerSupply?.Update(elapsedClockSeconds);
            UpdateControllers(elapsedClockSeconds);

            // Train Heading - only check the lead locomotive otherwise flipped locomotives further in consist will overwrite the train direction
            if (IsLeadLocomotive())
            {
                float heading = (float)Math.Atan2(WorldPosition.XNAMatrix.M13, WorldPosition.XNAMatrix.M11);
                float trainLocoDirectionDeg = MathHelper.ToDegrees(heading);

                if (Flipped)
                {
                    trainLocoDirectionDeg += 180.0f; // Reverse direction of train
                }
                Train.PhysicsTrainLocoDirectionDeg = (trainLocoDirectionDeg + 360) % 360;
            }

            if (IsSteamHeatFitted)
            {
                UpdateCarSteamHeat(elapsedClockSeconds);
            }

            if (!AdvancedAdhesionModel)  // Advanced adhesion model turned off.
                AbsWheelSpeedMpS = AbsSpeedMpS;


            // Cruise Control
            CruiseControl?.Update(elapsedClockSeconds);
            // TODO  this is a wild simplification for electric and diesel electric
            UpdateTractiveForce(elapsedClockSeconds, ThrottlePercent / 100f, AbsSpeedMpS, AbsWheelSpeedMpS);

            foreach (MultiPositionController mpc in MultiPositionControllers)
                mpc.Update(elapsedClockSeconds);

            ApplyDirectionToTractiveForce();

            // Calculate the total motive force for the locomotive - ie TractiveForce (driving force) + Dynamic Braking force.
            // Note typically only one of the above will only ever be non-zero at the one time.
            // For flipped locomotives the force is "flipped" elsewhere, whereas dynamic brake force is "flipped" below by the direction of the speed.
            MotiveForceN = TractiveForceN;

            if (DynamicBrakePercent > 0 && DynamicBrakeForceCurves != null && AbsSpeedMpS > 0)
            {
                float f = (float)DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, AbsTractionSpeedMpS);
                if (f > 0 && LocomotivePowerSupply.DynamicBrakeAvailable)
                {
                    DynamicBrakeForceN = f * (1 - PowerReduction);
                    MotiveForceN -= (SpeedMpS > 0 ? 1 : SpeedMpS < 0 ? -1 : Direction == MidpointDirection.Reverse ? -1 : 1) * DynamicBrakeForceN;
                }
                else
                {
                    DynamicBrakeForceN = 0f;
                }
            }
            else
                DynamicBrakeForceN = 0; // Set dynamic brake force to zero if in Notch 0 position


            UpdateFrictionCoefficient(elapsedClockSeconds); // Find the current coefficient of friction depending upon the weather

            UpdateWaterTroughRefill(elapsedClockSeconds, AbsSpeedMpS); // Update refill from trough

            switch (this.Train.TrainType)
            {
                case TrainType.Ai:
                case TrainType.AiPlayerHosting:
                    if (RemoteControlGroup != RemoteControlGroup.Unconnected)
                    {
                        if (!LocomotivePowerSupply.MainPowerSupplyOn)
                        {
                            Train.SignalEvent(PowerSupplyEvent.RaisePantograph, 1);

                            if (this is MSTSDieselLocomotive)
                            {
                                foreach (DieselEngine de in (this as MSTSDieselLocomotive).DieselEngines)
                                {
                                    if (de.State != DieselEngineState.Running)
                                        de.Initialize();
                                }
                            }
                        }
                        if (this is MSTSDieselLocomotive)
                        {
                            foreach (DieselEngine de in (this as MSTSDieselLocomotive).DieselEngines)
                            {
                                if (de.GearBox != null)
                                    de.GearBox.GearBoxOperation = GearBoxOperation.Automatic;
                            }
                        }
                    }

                    AntiSlip = true; // Always set AI trains to AntiSlip
                    SimpleAdhesion();   // Simple adhesion model used for AI trains
                    if (Train.IsActualPlayerTrain)
                        FilteredMotiveForceN = (float)currentFilter.Filter(MotiveForceN, elapsedClockSeconds);
                    WheelSpeedMpS = Flipped ? -AbsSpeedMpS : AbsSpeedMpS;            //make the wheels go round
                    break;
                case TrainType.Static:
                case TrainType.PlayerIntended:
                    break;
                case TrainType.Player:
                case TrainType.AiPlayerDriven:
                case TrainType.Remote:
                    // For notched throttle controls (e.g. Dash 9 found on Marias Pass) UpdateValue is always 0.0
                    if (ThrottleController.UpdateValue != 0.0)
                    {
                        simulator.Confirmer.UpdateWithPerCent(
                            this is MSTSSteamLocomotive ? CabControl.Regulator : CabControl.Throttle,
                            ThrottleController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            ThrottleController.CurrentValue * 100);
                    }
                    if (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0 && DynamicBrake)
                    {
                        simulator.Confirmer.UpdateWithPerCent(
                            CabControl.DynamicBrake,
                            DynamicBrakeController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            DynamicBrakeController.CurrentValue * 100);
                    }

                    // SimpleControlPhysics and if locomotive is a control car advanced adhesion will be "disabled".
                    if (simulator.Settings.UseAdvancedAdhesion && !simulator.Settings.SimpleControlPhysics && EngineType != EngineType.Control)
                    {
                        AdvancedAdhesion(elapsedClockSeconds); // Use advanced adhesion model
                        AdvancedAdhesionModel = true;  // Set flag to advise advanced adhesion model is in use
                    }
                    else
                    {
                        SimpleAdhesion();  // Use simple adhesion model
                        AdvancedAdhesionModel = false; // Set flag to advise simple adhesion model is in use
                    }

                    UpdateTrackSander(elapsedClockSeconds);

                    if (this is MSTSDieselLocomotive || this is MSTSElectricLocomotive)  // Antislip and throttle down should only work on diesel or electric locomotives.
                    {

                        // If wheel slip waring activated, and antislip is set in ENG file then reduce throttle setting to a value below warning power
                        if (WheelSlipWarning && AntiSlip)
                        {
                            ThrottleController.SetValue(PreviousThrottleSetting);
                        }


                        PreviousThrottleSetting = (ThrottlePercent / 100.0f) - 0.005f;
                        PreviousThrottleSetting = MathHelper.Clamp(PreviousThrottleSetting, 0.0f, 1.0f); // Prevents parameter going outside of bounds 

                        // If wheels slip and WheelslipCausesThrottleDown is set in engine file reduce throttle to 0 setting
                        if (WheelslipCausesThrottleDown && base.WheelSlip)
                            ThrottleController.SetValue(0.0f);
                    }

                    //Force to display
                    FilteredMotiveForceN = (float)currentFilter.Filter(MotiveForceN, elapsedClockSeconds);
                    break;
                default:
                    break;
            }

            // always set AntiSlip for AI trains
            if (Train.TrainType == TrainType.Ai || Train.TrainType == TrainType.AiPlayerHosting)
            {
                AntiSlip = true;
            }

            // If the train is vacuumed braked then no need to update the compressor, but udate the ejector instead
            if (BrakeSystem is VacuumSinglePipe)
            {

                if (VacuumBrakeEQFitted) // Only update exhauster/main reservoir on locomotives fitted ith an EQ reservoir
                {
                    UpdateVacuumExhauster(elapsedClockSeconds);
                }
                else
                {
                    UpdateSteamEjector(elapsedClockSeconds);
                }

            }
            else // if (EngineType != EngineTypes.Control) // TODO - Control trailers would not have compressors, but if they do then need to be linked to power supply requirements
            {
                UpdateCompressor(elapsedClockSeconds);
            }

            UpdateHornAndBell(elapsedClockSeconds);

            UpdateSoundVariables(elapsedClockSeconds);
            PrevMotiveForceN = MotiveForceN;
            base.Update(elapsedClockSeconds);

            locomotiveBrakeInfo.Update(null);
            locomotiveForceInfo.Update(null);
        } // End Method Update

        /// <summary>
        /// This function updates periodically the steam heating in wagons.
        /// </summary>
        protected virtual void UpdateCarSteamHeat(double elapsedClockSeconds)
        {
        }

        /// <summary>
        /// This function updates periodically the states and physical variables of the locomotive's controllers.
        /// </summary>
        protected virtual void UpdateControllers(double elapsedClockSeconds)
        {

            SteamHeatController.Update(elapsedClockSeconds);
            if (IsPlayerTrain)
            {
                if (SteamHeatController.UpdateValue > 0.0)
                    simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeat, CabSetting.Increase, SteamHeatController.CurrentValue * 100);
                if (SteamHeatController.UpdateValue < 0.0)
                    simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeat, CabSetting.Decrease, SteamHeatController.CurrentValue * 100);
            }

            TrainBrakeController.Update(elapsedClockSeconds);
            if (TrainBrakeController.UpdateValue > 0.0)
            {
                simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatus());
            }

            if (TrainBrakeController.UpdateValue < 0.0)
            {
                simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatus());
            }

            if (EngineBrakeController != null)
            {
                EngineBrakeController.Update(elapsedClockSeconds);
                if (EngineBrakeController.UpdateValue > 0.0)
                {
                    simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
                }
                if (EngineBrakeController.UpdateValue < 0.0)
                {
                    simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Decrease, GetEngineBrakeStatus());
                }
            }

            if (BrakemanBrakeController != null)
            {
                BrakemanBrakeController.Update(elapsedClockSeconds);
                if (BrakemanBrakeController.UpdateValue > 0.0)
                {
                    simulator.Confirmer.Update(CabControl.BrakemanBrake, CabSetting.Increase, GetBrakemanBrakeStatus());
                }
                if (BrakemanBrakeController.UpdateValue < 0.0)
                {
                    simulator.Confirmer.Update(CabControl.BrakemanBrake, CabSetting.Decrease, GetBrakemanBrakeStatus());
                }
            }

            DynamicBrakeBlending(elapsedClockSeconds);
            if (DynamicBrakeController != null && DynamicBrakeController.CommandStartTime > DynamicBrakeCommandStartTime) // use the latest command time
                DynamicBrakeCommandStartTime = DynamicBrakeController.CommandStartTime;

            if ((DynamicBrakeController != null || DynamicBrakeBlendingEnabled || DynamicBrakeAvailable) && (DynamicBrakePercent >= 0 || IsLeadLocomotive() && DynamicBrakeIntervention >= 0))
            {
                if (!DynamicBrake)
                {
                    if (DynamicBrakeCommandStartTime + DynamicBrakeDelayS < simulator.ClockTime /*|| (DynamicBrakeController != null && DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)*/)
                    {
                        DynamicBrake = true; // Engage
                        if (IsLeadLocomotive() && DynamicBrakeController != null)
                            simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                    }
                    else if (IsLeadLocomotive())
                        simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
                }
                else if (this.IsLeadLocomotive())
                {
                    if (DynamicBrakeController != null)
                    {
                        DynamicBrakeController.Update(elapsedClockSeconds);
                        DynamicBrakePercent = (DynamicBrakeIntervention < 0 ? DynamicBrakeController.CurrentValue : DynamicBrakeIntervention) * 100f;
                        LocalDynamicBrakePercent = (DynamicBrakeIntervention < 0 ? DynamicBrakeController.CurrentValue : DynamicBrakeIntervention) * 100f;
                    }
                    else
                    {
                        DynamicBrakePercent = Math.Max(DynamicBrakeIntervention * 100f, 0f);
                        LocalDynamicBrakePercent = Math.Max(DynamicBrakeIntervention * 100f, 0f);
                    }

                    if (DynamicBrakeIntervention < 0 && PreviousDynamicBrakeIntervention >= 0 && DynamicBrakePercent == 0)
                    {
                        DynamicBrakePercent = -1;
                        LocalDynamicBrakePercent = -1;
                    }
                    PreviousDynamicBrakeIntervention = DynamicBrakeIntervention;
                    if (PreviousFullDynamicBrakingOrder && !TrainControlSystem.FullDynamicBrakingOrder && DynamicBrakeController.CurrentValue == 0 && DynamicBrakeIntervention < 0)
                    {
                        DynamicBrakePercent = -1;
                        LocalDynamicBrakePercent = -1;
                        DynamicBrake = false;
                    }
                    PreviousFullDynamicBrakingOrder = TrainControlSystem.FullDynamicBrakingOrder;
                }
                else if (DynamicBrakeController != null)
                    DynamicBrakeController.Update(elapsedClockSeconds);
            }
            else if ((DynamicBrakeController != null || DynamicBrakeBlendingEnabled || DynamicBrakeAvailable) && DynamicBrakePercent < 0 && (DynamicBrakeIntervention < 0 || !IsLeadLocomotive()) && DynamicBrake)
            {
                // <CScomment> accordingly to shown documentation dynamic brake delay is required only when engaging
                //           if (DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)
                //           {
                DynamicBrake = false; // Disengage
                DynamicBrakeForceN = 0f; // Reset dynamic brake force
                if (IsLeadLocomotive())
                    simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.Off);
                //           }
                //            else if (IsLeadLocomotive())
                //               Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
            }

            //Currently the ThrottlePercent is global to the entire train
            //So only the lead locomotive updates it, the others only updates the controller (actually useless)
            if (this.IsLeadLocomotive())
            {
                var throttleCurrentNotch = ThrottleController.NotchIndex;
                ThrottleController.Update(elapsedClockSeconds);
                if (ThrottleController.NotchIndex < throttleCurrentNotch && ThrottleController.ToZero)
                    SignalEvent(TrainEvent.ThrottleChange);
                ThrottlePercent = (ThrottleIntervention < 0 ? ThrottleController.CurrentValue : ThrottleIntervention) * 100.0f;
                ConfirmWheelslip(elapsedClockSeconds);
                LocalThrottlePercent = (ThrottleIntervention < 0 ? ThrottleController.CurrentValue : ThrottleIntervention) * 100.0f;
                DistributedPowerThrottleController.Update(elapsedClockSeconds);
                DistributedPowerDynamicBrakeController?.Update(elapsedClockSeconds);
            }
            else
            {
                ThrottleController.Update(elapsedClockSeconds);
            }
        }

        /// <summary>
        /// This function updates periodically the locomotive's motive force.
        /// </summary>
        protected virtual void UpdateTractiveForce(double elapsedClockSeconds, float t, float AbsSpeedMpS, float AbsWheelSpeedMpS)
        {
            // Method to set force and power info
            // An alternative method in the steam locomotive will override this and input force and power info for it.
            if (t > 1)
                t = 1;
            if (LocomotivePowerSupply.MainPowerSupplyOn && Direction != MidpointDirection.N)
            {

                // For the advanced adhesion model, a rudimentary form of slip control is incorporated by using the wheel speed to calculate tractive effort.
                // As wheel speed is increased tractive effort is decreased. Hence wheel slip is "controlled" to a certain extent.
                // This doesn't cover all types of locomotives, for example if DC traction motors and no slip control, then the tractive effort shouldn't be reduced.
                // This won't eliminate slip, but limits its impact. 
                // More modern locomotive have a more sophisticated system that eliminates slip in the majority (if not all circumstances).
                // Simple adhesion control does not have any slip control feature built into it.
                // TODO - a full review of slip/no slip control.
                if (TractionMotorType == TractionMotorType.AC)
                {
                    AbsTractionSpeedMpS = AbsSpeedMpS;
                }
                else
                {
                    if (base.WheelSlip && AdvancedAdhesionModel)
                    {
                        AbsTractionSpeedMpS = AbsWheelSpeedMpS;
                    }
                    else
                    {
                        AbsTractionSpeedMpS = AbsSpeedMpS;
                    }
                }

                if (TractiveForceCurves == null)
                {
                    float maxForceN = MaxForceN * t * (1 - PowerReduction);
                    float maxPowerW = MaxPowerW * t * t * (1 - PowerReduction);

                    if (maxForceN * AbsTractionSpeedMpS > maxPowerW)
                        maxForceN = maxPowerW / AbsTractionSpeedMpS;
                    //if (AbsSpeedMpS > MaxSpeedMpS)
                    //    maxForceN = 0;
                    if (AbsTractionSpeedMpS > MaxSpeedMpS - 0.05f)
                        maxForceN = 20 * (MaxSpeedMpS - AbsTractionSpeedMpS) * maxForceN;
                    if (AbsSpeedMpS > (MaxSpeedMpS))
                        maxForceN = 0;
                    TractiveForceN = maxForceN;
                }
                else
                {
                    TractiveForceN = (float)TractiveForceCurves.Get(t, AbsTractionSpeedMpS) * (1 - PowerReduction);
                    if (TractiveForceN < 0 && !TractiveForceCurves.HasNegativeValues)
                        TractiveForceN = 0;
                }
            }
            else
                TractiveForceN = 0f;

            if (MaxForceN > 0 && MaxContinuousForceN > 0 && PowerReduction < 1)
            {
                TractiveForceN *= 1 - (MaxForceN - MaxContinuousForceN) / (MaxForceN * MaxContinuousForceN) * AverageForceN * (1 - PowerReduction);
                float w = (float)(ContinuousForceTimeFactor - elapsedClockSeconds) / ContinuousForceTimeFactor;
                if (w < 0)
                    w = 0;
                AverageForceN = w * AverageForceN + (1 - w) * TractiveForceN;
            }
        }

        /// <summary>
        /// This function applies a sign to the motive force as a function of the direction of the train.
        /// </summary>
        protected virtual void ApplyDirectionToTractiveForce()
        {
            if (Train.IsPlayerDriven)
            {
                switch (Direction)
                {
                    case MidpointDirection.Forward:
                        //MotiveForceN *= 1;     //Not necessary
                        break;
                    case MidpointDirection.Reverse:
                        TractiveForceN *= -1;
                        break;
                    case MidpointDirection.N:
                    default:
                        TractiveForceN *= 0;
                        break;
                }
            }
            else // for AI locomotives
            {
                switch (Direction)
                {
                    case MidpointDirection.Reverse:
                        TractiveForceN *= -1;
                        break;
                    default:
                        break;
                }
            }// end AI locomotive
        }

        private WheelSlipState wheelslipState = WheelSlipState.None;

        public void ConfirmWheelslip(double elapsedClockSeconds)
        {
            if (elapsedClockSeconds > 0 && simulator.GameTime - LocomotiveAxle.ResetTime > 5)
            {
                if (AdvancedAdhesionModel)
                {
                    // Wheelslip
                    if (base.WheelSlip)
                    {
                        if (wheelslipState != WheelSlipState.Occurring)
                        {
                            wheelslipState = WheelSlipState.Occurring;
                            simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                        }
                    }
                    else
                    {
                        if (WheelSlipWarning)
                        {
                            if (wheelslipState != WheelSlipState.Warning)
                            {
                                wheelslipState = WheelSlipState.Warning;
                                simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Warn1);
                            }
                        }
                        else
                        {
                            if (wheelslipState != WheelSlipState.None)
                            {
                                wheelslipState = WheelSlipState.None;
                                simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                            }
                        }
                    }
                }
                else
                {
                    if (base.WheelSlip && (wheelslipState != WheelSlipState.Occurring))
                    {
                        wheelslipState = WheelSlipState.Occurring;
                        simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                    }
                    if ((!base.WheelSlip) && (wheelslipState != WheelSlipState.None))
                    {
                        wheelslipState = WheelSlipState.None;
                        simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                    }
                }
            }
        }

        /// <summary>
        /// This function updates periodically the state of the steam ejector or vacuum pump on a vacuum braked system.
        /// </summary>
        protected virtual void UpdateSteamEjector(double elapsedClockSeconds)
        {
            // Ejectors are controlled independently for the "straight_vacuum_single_pipe" brake type 
            // Ejectors are controlled by brake control valves in Simple Physics Control
            if (simulator.Settings.SimpleControlPhysics && BrakeSystemType != BrakeSystemType.StraightVacuumSinglePipe)
            // Simple braking - control Ejector automatically based upon the brake control position
            // Stop ejector operation if full vacuum pressure reached
            {
                if ((TrainBrakeController.TrainBrakeControllerState == ControllerState.Release || TrainBrakeController.TrainBrakeControllerState == ControllerState.FullQuickRelease || (TrainBrakeController.TrainBrakeControllerState == ControllerState.VacContServ)) && (this.BrakeSystem.BrakeLine1PressurePSI > Pressure.Vacuum.ToPressure(TrainBrakeController.MaxPressurePSI)))
                {
                    LargeSteamEjectorIsOn = true;  // If brake is set to a release controller, then turn ejector on
                    LargeEjectorSoundOn = true;
                }
                else
                {
                    LargeSteamEjectorIsOn = false; // If brake is not set to a release controller, or full vacuum reached, then turn ejector off
                    LargeEjectorSoundOn = false;
                }
            }
            else if (!LargeEjectorControllerFitted && BrakeSystemType != BrakeSystemType.StraightVacuumSinglePipe) // Use an "automatic" large ejector when using a dreadnought style brake controller - large ejector stays on until moved back to released position
            {
                if (TrainBrakeController.TrainBrakeControllerState == ControllerState.Release)
                {
                    LargeSteamEjectorIsOn = true;  // If brake is set to a release controller, then turn ejector on
                    LargeEjectorSoundOn = true;
                }
                else
                {
                    LargeSteamEjectorIsOn = false; // If brake is not set to a release controller, then turn ejector off
                    if (LargeEjectorSoundOn)
                    {
                        SignalEvent(TrainEvent.LargeEjectorOff);
                        LargeEjectorSoundOn = false;
                    }
                }

            }
            else if (LargeEjectorControllerFitted)// Advanced braking - control ejector based upon using a "manual" large ejector control setting
            {
                if (LargeEjectorFeedFraction > 0.05)
                {
                    LargeSteamEjectorIsOn = true;  // turn ejector on
                    LargeEjectorSoundOn = true;
                }
                else
                {
                    LargeSteamEjectorIsOn = false; // turn ejector off
                    LargeEjectorSoundOn = false;
                }
            }


            if (SmallEjectorControllerFitted && BrakeSystemType != BrakeSystemType.StraightVacuumSinglePipe)
                // Turn small ejector on if controlled from drivers controller
                if (SmallEjectorFeedFraction > 0.05)
                {
                    SmallSteamEjectorIsOn = true;  // turn ejector on
                    SmallEjectorSoundOn = true;
                }
                else if (SmallEjectorControllerFitted)
                {
                    SmallSteamEjectorIsOn = false; // turn ejector off
                    SmallEjectorSoundOn = false;
                }


            // If diesel or electric locomotive, assume vacuum pump (exhauster) is continually running.
            if (!(this is MSTSSteamLocomotive))
            {
                VacuumPumpOperating = true;
            }
        }

        /// <summary>
        /// This function updates periodically the state of the vacuum exhauster on a vacuum braked system with a EQ reservoir.
        /// Resevoir vacuum is maintained in "atmospheric pressure" and converted to vacuum
        /// Vacuum reservoir should normally be maintained at approx 26InHg (4.185 psi)
        /// </summary>
        protected virtual void UpdateVacuumExhauster(double elapsedClockSeconds)
        {
            if (VacuumMainResVacuumPSIAorInHg > VacuumBrakesExhausterRestartVacuumPSIAorInHg && LocomotivePowerSupply.AuxiliaryPowerSupplyState == PowerSupplyState.PowerOn && !VacuumExhausterIsOn)
                SignalEvent(TrainEvent.VacuumExhausterOn);
            else if ((VacuumMainResVacuumPSIAorInHg < VacuumBrakesMainResMaxVacuumPSIAorInHg || LocomotivePowerSupply.AuxiliaryPowerSupplyState != PowerSupplyState.PowerOn) && VacuumExhausterIsOn)
                SignalEvent(TrainEvent.VacuumExhausterOff);

        }

        /// <summary>
        /// This function updates periodically the state of the compressor and charges the main reservoir if the compressor is active.
        /// </summary>
        protected virtual void UpdateCompressor(double elapsedClockSeconds)
        {

            var reservoirChargingRate = MainResChargingRatePSIpS;

            // For a mechanical compressor (typically fitted to a diesel locomotive) the charging rate will be related to the RpM of the diesel engine, and therefore 
            // derated by an amount equivalent to the diesel RpM.
            // All other locomotive types it will be the full charging rate for the reservoir

            // TO DO - For v1.4 this code uses the "electric" compressor code to control the compressor. The only additional feature is the addition of a variable 
            // charging rate based upon the diesel engine rpm. Note that the diesel compressor code operates regardless of whether the engine is running or not. 
            // This needs to be corrected in a future implementation.

            // If mechanical compressor then calculate charging rate based upon engine rpm
            if (CompressorIsMechanical && (EngineType == EngineType.Control || EngineType == EngineType.Diesel))
            {

                // Control car uses the attached active locomotive to set the charging rate
                if (EngineType == EngineType.Control)
                {
                    FindControlActiveLocomotive();

                    if (ControlActiveLocomotive != null)
                    {
                        var activeloco = ControlActiveLocomotive as MSTSDieselLocomotive;

                        // Set charging rate depending upon compressor rpm
                        reservoirChargingRate = (activeloco.DieselEngines[0].RealRPM / activeloco.DieselEngines[0].MaxRPM) * MainResChargingRatePSIpS;
                    }
                }
                else
                {
                    // Powered locomotive use themselves
                    var mstsDieselLocomotive = this as MSTSDieselLocomotive;

                    // Set charging rate depending upon compressor rpm
                    reservoirChargingRate = (mstsDieselLocomotive.DieselEngines[0].RealRPM / mstsDieselLocomotive.DieselEngines[0].MaxRPM) * MainResChargingRatePSIpS;
                }
            }

            // Turn compressor on and off
            if (MainResPressurePSI < CompressorRestartPressurePSI && LocomotivePowerSupply.AuxiliaryPowerSupplyState == PowerSupplyState.PowerOn && !CompressorIsOn)
                SignalEvent(TrainEvent.CompressorOn);
            else if ((MainResPressurePSI >= MaxMainResPressurePSI || LocomotivePowerSupply.AuxiliaryPowerSupplyState != PowerSupplyState.PowerOn) && CompressorIsOn)
                SignalEvent(TrainEvent.CompressorOff);

            if (CompressorIsOn)
                MainResPressurePSI += (float)elapsedClockSeconds * reservoirChargingRate;
        }

        /// <summary>
        /// This function updates periodically the states of the horn/whistle and the bell of the locomotive.
        /// </summary>
        protected virtual void UpdateHornAndBell(double elapsedClockSeconds)
        {
            Horn = ManualHorn || TCSHorn;
            if (Horn && !previousHorn)
            {
                SignalEvent(TrainEvent.HornOn);
                MultiPlayerManager.Broadcast(new TrainEventMessage() { TrainEvent = TrainEvent.HornOn });
            }
            else if (!Horn && previousHorn)
            {
                SignalEvent(TrainEvent.HornOff);
                MultiPlayerManager.Broadcast(new TrainEventMessage() { TrainEvent = TrainEvent.HornOff });
            }

            if (ManualBell)
            {
                BellState = SoundState.Sound;
            }
            else if (DoesHornTriggerBell && Horn)
            {
                BellState = SoundState.ContinuousSound;
            }
            else if (!ManualBell && BellState == SoundState.Sound)
            {
                BellState = SoundState.Stopped;
            }

            Bell = BellState != SoundState.Stopped;
            if (Bell && !previousBell)
            {
                SignalEvent(TrainEvent.BellOn);
                if (Train.TrainType != TrainType.Remote)
                    MultiPlayerManager.Broadcast(new TrainEventMessage() { TrainEvent = TrainEvent.BellOn });
            }
            else if (!Bell && previousBell)
            {
                SignalEvent(TrainEvent.BellOff);
                if (Train.TrainType != TrainType.Remote)
                    MultiPlayerManager.Broadcast(new TrainEventMessage() { TrainEvent = TrainEvent.BellOff });
            }

            previousHorn = Horn;
            previousBell = Bell;
        }

        /// <summary>
        /// This function updates periodically the locomotive's sound variables.
        /// </summary>
        protected virtual void UpdateSoundVariables(double elapsedClockSeconds)
        {
        }

        /// <summary>
        /// Adjusts the MotiveForce to account for adhesion limits
        /// If UseAdvancedAdhesion is true, dynamic adhesion model is computed
        /// If UseAdvancedAdhesion is false, the basic force limits are calculated the same way MSTS calculates them, but
        /// the weather handleing is different and Curtius-Kniffler curves are considered as a static limit
        /// </summary>
        public virtual void AdvancedAdhesion(double elapsedClockSeconds)
        {

            if (locoNumDrvAxles <= 0)
            {
                WheelSpeedMpS = AbsSpeedMpS;
                return;
            }

            if (EngineType == EngineType.Steam && this is MSTSSteamLocomotive steamLocomotive && steamLocomotive.SteamEngineType != SteamEngineType.Geared)
            {
                // Managed in MSTSSteamLocomotive implementation of AdvancedAdhesion
            }
            else
            {
                //Compute axle inertia from parameters if possible
                if (AxleInertiaKgm2 <= 0) // if no axleinertia value supplied in ENG file, calculate axleinertia value.
                {
                    if (locoNumDrvAxles > 0 && DriverWheelRadiusM > 0)
                    {
                        float radiusSquared = DriverWheelRadiusM * DriverWheelRadiusM;
                        float wheelMass = 500 * radiusSquared / (0.5f * 0.5f);
                        AxleInertiaKgm2 = locoNumDrvAxles * wheelMass * radiusSquared + 500;
                    }
                    else
                        AxleInertiaKgm2 = 2000.0f;
                }
                //Limit the inertia to 40000 kgm2
                LocomotiveAxle.InertiaKgm2 = Math.Min(AxleInertiaKgm2, 40000);

                LocomotiveAxle.DampingNs = MassKG / 1000.0f;
                LocomotiveAxle.FrictionN = MassKG / 1000.0f;

                if (LocomotiveAxle.Motor is InductionMotor motor)
                {
                    motor.SlipControl = SlipControlSystem == SlipControlType.Full;
                    motor.TargetForce = MotiveForceN;
                    motor.EngineMaxSpeed = MaxSpeedMpS;
                }
                else
                {
                    if (SlipControlSystem == SlipControlType.Full)
                    {
                        // Simple slip control
                        // Motive force is reduced to the maximum adhesive force
                        // In wheelslip situations, motive force is set to zero
                        MotiveForceN = LocomotiveAxle.IsWheelSlip
                            ? 0
                            : Math.Sign(MotiveForceN) * Math.Min(LocomotiveAxle.AdhesionLimit * LocomotiveAxle.AxleWeightN, Math.Abs(MotiveForceN));
                    }
                }

                LocomotiveAxle.AxleWeightN = 9.81f * DrvWheelWeightKg;  //remains fixed for diesel/electric locomotives, but varies for steam locomotives
            }

            //Set axle model parameters

            // Inputs
            LocomotiveAxle.BrakeRetardForceN = BrakeRetardForceN;
            LocomotiveAxle.DriveForceN = MotiveForceN;              //Total force applied to wheels
            LocomotiveAxle.TrainSpeedMpS = SpeedMpS;                //Set the train speed of the axle mod
            LocomotiveAxle.WheelRadiusM = DriverWheelRadiusM;

            LocomotiveAxle.Update(elapsedClockSeconds); //Main updater of the axle model

            MotiveForceN = LocomotiveAxle.CompensatedAxleForceN;
            if (elapsedClockSeconds > 0)
            {
                base.WheelSlip = LocomotiveAxle.IsWheelSlip;             //Get the wheelslip indicator
                WheelSlipWarning = LocomotiveAxle.IsWheelSlipWarning && SlipControlSystem != SlipControlType.Full;
            }

            // This enables steam locomotives to have different speeds for driven and non-driven wheels.
            if (EngineType == EngineType.Steam && this is MSTSSteamLocomotive steamLocomotive1 && steamLocomotive1.SteamEngineType != SteamEngineType.Geared)
            {
                if (AbsSpeedMpS <= 0.15 && !base.WheelSlip)
                {
                    WheelSpeedSlipMpS = SpeedMpS;
                    WheelSpeedMpS = SpeedMpS;
                }
                else
                {
                    WheelSpeedSlipMpS = LocomotiveAxle.AxleSpeedMpS;
                    WheelSpeedMpS = SpeedMpS;
                }
            }
            else
                WheelSpeedMpS = LocomotiveAxle.AxleSpeedMpS;

        }

        public void SimpleAdhesion()
        {

            // Check if the following few lines are required???
            if (locoNumDrvAxles <= 0)
            {
                WheelSpeedMpS = AbsSpeedMpS;
                return;
            }

            if (locoNumDrvAxles <= 0)
                return;

            //Curtius-Kniffler computation
            // Set to a high level of adhesion to ensure that locomotive rarely slips in dry mode
            float uMax = 1.3f * (7.5f / (AbsSpeedMpS + 44.0f) + 0.161f); // Curtius - Kniffler equation

            float max0 = DrvWheelWeightKg * 9.81f * uMax;  //Ahesion limit in [N]
            float max1;

            if (simulator.WeatherType == WeatherType.Rain || simulator.WeatherType == WeatherType.Snow)
            {
                if (Train.SlipperySpotDistanceM < 0)
                {
                    Train.SlipperySpotLengthM = 10 + 40 * (float)StaticRandom.NextDouble();
                    Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)StaticRandom.NextDouble();
                }
                if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                    max0 *= 0.8f;
                if (simulator.WeatherType == WeatherType.Rain)
                    max0 *= 0.8f;
                else
                    max0 *= 0.7f;
            }
            //float max1 = (Sander ? .95f : Adhesion2) * max0;  //Not used this way
            max1 = MaxForceN;
            //add sander
            if (AbsSpeedMpS < SanderSpeedOfMpS && CurrentTrackSandBoxCapacityM3 > 0.0 && MainResPressurePSI > 80.0)
            {
                if (SanderSpeedEffectUpToMpS > 0.0f)
                {
                    if ((Sander) && (AbsSpeedMpS < SanderSpeedEffectUpToMpS))
                    {
                        switch (simulator.WeatherType)
                        {
                            case WeatherType.Clear:
                                max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.2f;
                                break;
                            case WeatherType.Rain:
                                max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.8f;
                                break;
                            case WeatherType.Snow:
                                max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 2.5f;
                                break;
                        }
                    }
                }
                else
                    if (Sander)
                {
                    switch (simulator.WeatherType)
                    {
                        case WeatherType.Clear:
                            max0 *= 1.2f;
                            break;
                        case WeatherType.Rain:
                            max0 *= 1.8f;
                            break;
                        case WeatherType.Snow:
                            max0 *= 2.5f;
                            break;
                    }
                }
            }

            max1 = max0;

            base.WheelSlip = false;

            if (MotiveForceN > max1)
            {
                base.WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = max1;
                else
                    MotiveForceN = Adhesion1 * max0;        //Lowers the adhesion limit to 20% of its full
            }
            else if (MotiveForceN < -max1)
            {
                base.WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = -max1;
                else
                    MotiveForceN = -Adhesion1 * max0;       //Lowers the adhesion limit to 20% of its full
            }
        }

        /// <summary>
        /// Refills the locomotive from a water trough
        /// </summary>
        public virtual void UpdateWaterTroughRefill(double elapsedClockSeconds, float absSpeedMpS)
        {
            // Check to see whether locomotive is to be refilled over water trough
            if (simulator.PlayerLocomotive == this && IsWaterScoopDown)
            {


                var fraction = GetFilledFraction(PickupType.FuelWater);

                if (!HasWaterScoop)
                {
                    if (!WaterScoopNotFittedFlag)
                    {
                        simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("No water scoop on this loco"));
                        WaterScoopNotFittedFlag = true;
                    }
                    RefillingFromTrough = false;
                }
                else if (ScoopIsBroken)
                {
                    simulator.Confirmer.Message(ConfirmLevel.Error, Simulator.Catalog.GetString("Scoop is broken, can't refill"));
                    RefillingFromTrough = false;
                }
                else if (IsOverJunction())
                {
                    if (!ScoopIsBroken) // Only display message first time scoop is broken
                    {
                        simulator.Confirmer.Message(ConfirmLevel.Error, Simulator.Catalog.GetString("Scoop is broken by junction track"));
                    }
                    ScoopIsBroken = true;
                    RefillingFromTrough = false;
                    SignalEvent(TrainEvent.WaterScoopBroken);
                }
                else if (!IsOverTrough())
                {
                    if (!WaterScoopOverTroughFlag)
                    {
                        simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Scoop is not over trough, can't refill"));
                        WaterScoopOverTroughFlag = true;
                        RefillProcess.OkToRefill = false;
                        RefillProcess.ActivePickupObjectUID = 0;
                    }
                    RefillingFromTrough = false;
                }
                else if (IsTenderRequired == 1 && Direction == MidpointDirection.Reverse) // Locomotives with tenders cannot go in reverse
                {
                    if (!WaterScoopDirectionFlag)
                    {
                        simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetString("Refill: Loco must be moving forward."));
                        WaterScoopDirectionFlag = true;
                    }
                    RefillingFromTrough = false;
                }
                else if (absSpeedMpS < WaterScoopMinSpeedMpS)
                {
                    if (!WaterScoopSlowSpeedFlag)
                    {
                        simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetString("Refill: Loco speed must exceed {0} for water to enter tender.",
                                FormatStrings.FormatSpeedLimit(WaterScoopMinSpeedMpS, simulator.Route.MilepostUnitsMetric)));
                        WaterScoopSlowSpeedFlag = true;
                        RefillProcess.OkToRefill = false;
                        RefillProcess.ActivePickupObjectUID = 0;
                    }
                    RefillingFromTrough = false;
                }
                else if (fraction > 1.0)
                {
                    simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetString("Refill: Water supply now replenished."));
                }
                else
                {
                    MSTSWagon.RefillProcess.OkToRefill = true;
                    MSTSWagon.RefillProcess.ActivePickupObjectUID = -1;
                    RefillingFromTrough = true;
                    WaterScoopOverTroughFlag = false; // Reset flag so that message will come up again
                }

            }
            else if (HasWaterScoop && MSTSWagon.RefillProcess.OkToRefill == true && IsOverTrough())// water scoop has been raised, stop water filling
            {
                MSTSWagon.RefillProcess.OkToRefill = false;
                MSTSWagon.RefillProcess.ActivePickupObjectUID = 0;
                RefillingFromTrough = false;
            }



            // update water scoop
            // Water scoop fill charateristics can be found in - 
            // Calculate water velocity entering pipe: v = SQRT ( loco speed^2 - 2 * gravity * h)
            // Calculate the drag of the water scoop in the water: Drag Force = 0.5 * Drag Coeff * Fluid Density * Reference Area * Velocity

            if (RefillingFromTrough)
            {
                // Calculate water velocity
                const float Aconst = 2;
                const float Bconst = 2.15f;
                double Avalue = (Math.Pow(Speed.MeterPerSecond.ToMpH(absSpeedMpS), 2) * Bconst);
                double Bvalue = Aconst * GravitationalAccelerationFtpSpS * Size.Length.ToFt(WaterScoopFillElevationM);

                if (Avalue > Bvalue)
                {
                    WaterScoopVelocityMpS = (float)Size.Length.FromFt(Math.Sqrt(Avalue - Bvalue));
                }
                else
                {
                    WaterScoopVelocityMpS = 0;
                }

                // calculate volume of water scooped per period
                const float CuFttoGalUK = 6.22884f; // imperial gallons of water in a cubic foot of water
                WaterScoopedQuantityLpS = (float)Size.LiquidVolume.FromGallonUK(Size.Area.ToFt2((WaterScoopDepthM * WaterScoopWidthM)) * Size.Length.ToFt(WaterScoopVelocityMpS) * CuFttoGalUK);
                WaterScoopInputAmountL = WaterScoopedQuantityLpS * (float)elapsedClockSeconds; // Calculate current input quantity

                // Max sure that water level can't exceed maximum tender water level. Assume that water will be vented out of tender if maximum value exceeded. 
                // If filling from water trough this will be done with force
                // The water controller can only be used by one stock item at a time.
                if (EngineType == EngineType.Steam)
                {
                    const float NominalExtraWaterVolumeFactor = 1.0001f;
                    CombinedTenderWaterVolumeUKG += (float)Size.LiquidVolume.ToGallonUK(WaterScoopInputAmountL); // add the amount of water added by scoop
                    WaterScoopTotalWaterL += WaterScoopInputAmountL;
                    CombinedTenderWaterVolumeUKG = MathHelper.Clamp(CombinedTenderWaterVolumeUKG, 0.0f, MaxTotalCombinedWaterVolumeUKG * NominalExtraWaterVolumeFactor);
                }
                else
                {
                    CurrentLocomotiveSteamHeatBoilerWaterCapacityL += WaterScoopInputAmountL; // add water if it is a steam heat boiler
                    CurrentLocomotiveSteamHeatBoilerWaterCapacityL = Math.Clamp(CurrentLocomotiveSteamHeatBoilerWaterCapacityL, 0.0f, maximumSteamHeatBoilerWaterTankCapacityL);
                }

                // Calculate drag force
                float ScoopDragCoeff = 1.05f;
                float ScoopDragAreaM = WaterScoopDepthM * WaterScoopWidthM;
                float ScoopFluidDensityKgpM3 = 998.2f; // Fuild density of water @ 20c
                WaterScoopDragForceN = 0.5f * ScoopDragCoeff * ScoopFluidDensityKgpM3 * ScoopDragAreaM * absSpeedMpS * absSpeedMpS;

                // Turn water scoop sound on
                if (!WaterScoopSoundOn)
                {
                    WaterScoopSoundOn = true;
                    SignalEvent(TrainEvent.WaterScoopDown);
                }
            }
            else // Ensure water scoop values are zero if not taking water.
            {
                WaterScoopDragForceN = 0f;
                WaterScoopedQuantityLpS = 0;
                WaterScoopInputAmountL = 0;
                WaterScoopVelocityMpS = 0;

                if (!IsOverTrough()) // Only reset once train moves off the trough
                {
                    WaterScoopTotalWaterL = 0.0f; // Reset amount of water picked up by water sccop.
                }

                // Turn water scoop sound off
                if (WaterScoopSoundOn)
                {
                    WaterScoopSoundOn = false;
                    SignalEvent(TrainEvent.WaterScoopUp);
                }
            }
        }

        #region Calculate Friction Coefficient
        /// <summary>
        /// Calculates the current coefficient of friction based upon the current weather 
        /// The calculation of Coefficient of Friction appears to provide a wide range of 
        /// variations depending upon a number of factors including the wheel and track 
        /// composition, and whether the track is dry, wet (or lubricated), icy, covered 
        /// in leaf litter, etc.
        /// For the purposes of simulating frcition the following values have been used. 
        /// Some reference documents have suggested that friction can vary between 0.07 
        /// for lubricated or icy track to 0.78 for dry track.
        /// The standard Cutius-Kniffler formula for dry rail is used as a base.
        /// Dry track = 0.33 
        /// 
        /// The following values are indicatitive values only (sourced from Principles and Applications of Tribology).
        /// https://books.google.com.au/books?id=LtYgBQAAQBAJ&pg=PA312&lpg=PA312&dq=Principles+and+Applications+of+Tribology+table+14.1&source=bl&ots=2hfz1WpEsM&sig=ACfU3U3U9y9Lwov9GORLaKCO10SCFHvjhA&hl=en&sa=X&ved=2ahUKEwi82NCF_Yr0AhWNTX0KHcGfB3QQ6AF6BAgMEAM#v=onepage&q=Principles%20and%20Applications%20of%20Tribology%20table%2014.1&f=false
        /// Dry (clean) - 0.25 to 0.3
        /// Dry (sand) - 0.35 to 0.4
        /// Wet track (clean) = 0.18 <=> 0.2
        /// Wet track (sand) = 0.22 <=> 0.25
        /// Dew or fog = 0.09 <=> 0.15
        /// Sleet = 0.15
        /// Sleet (sand) = 0.2
        /// Snow track = 0.1 
        /// Snow track (sand) = 0.15
        /// 
        /// Note Heavy rain will actually wash track clean, and will give a higher value of adhesion then light drizzling rain
        /// </summary>
        public virtual void UpdateFrictionCoefficient(double elapsedClockSeconds)
        {
            float BaseuMax = (float)(CurtiusKnifflerA / (Speed.MeterPerSecond.ToKpH(AbsSpeedMpS) + CurtiusKnifflerB) + CurtiusKnifflerC); // Base Curtius - Kniffler equation - u = 0.33, all other values are scaled off this formula
            float SandingFrictionCoefficientFactor = 1.0f;

            //Set the friction coeff due to weather - uses the vlaues set in the precipitation module to determine whether clear, rain or snow.

            // Adjust clear weather for precipitation presence, ie base value between 60% and 80% 
            // note lowest friction will be for drizzle (light) rain; friction will increase for precipitation higher than drizzle rail
            if (!simulator.GamePaused)
            {
                var fogBaseFrictionCoefficientFactor = 1.0f;
                var pricBaseFrictionCoefficientFactor = 1.0f;
                float pric = simulator.Weather.PrecipitationIntensity * 1000;
                // precipitation will calculate a base coefficient value between 60% (light rain) and 90% (heavy rain) - this will be a factor that is used to adjust the base value 
                // assume linear value between upper and lower precipitation values. Limits are set in the weather module, ie Rain = 0.01ppm (10) and Snow = 0.005ppm (5)
                float precGrad = (0.2f - 0) / (10f - 5f);

                if (pric <= 1.0f)
                {
                    pricBaseFrictionCoefficientFactor = 1.0f;
                }
                else if (pric > 0)
                {
                    pricBaseFrictionCoefficientFactor = Math.Min((pric - 5f) * precGrad + 0.6f, 0.9f);
                    // should give a value between 0.6 and 0.9
                }

                // Adjust adhesion for impact of fog - default = 20000m = 20km
                float fog = simulator.Weather.FogVisibilityDistance;
                if (fog < 20000) // as fog thickens then decrease adhesion
                {
                    fogBaseFrictionCoefficientFactor = Math.Min((fog * 2.75e-4f + 0.6f), 1.0f); // If fog is less then 2km then it will impact friction, decrease adhesion to 60% (same as light rain transition)
                }

                BaseFrictionCoefficientFactor = Math.Min(fogBaseFrictionCoefficientFactor, pricBaseFrictionCoefficientFactor);
            }

            // Random slippery track
            if (Train.SlipperySpotDistanceM < 0)
            {
                Train.SlipperySpotLengthM = 10 + 40 * (float)StaticRandom.NextDouble();
                Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)StaticRandom.NextDouble();
            }
            if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
            {
                if (BaseFrictionCoefficientFactor > 0.6 && BaseFrictionCoefficientFactor < 0.8)
                {
                    BaseFrictionCoefficientFactor = 0.6f;
                }
                else
                {
                    BaseFrictionCoefficientFactor = 0.8f;
                }
            }

            BaseFrictionCoefficientFactor = MathHelper.Clamp(BaseFrictionCoefficientFactor, 0.5f, 1.0f);

            // Snow covered track
            if (simulator.WeatherType == WeatherType.Snow)
            {
                if (AbsSpeedMpS < SanderSpeedOfMpS && CurrentTrackSandBoxCapacityM3 > 0.0 && MainResPressurePSI > 80.0 && (AbsSpeedMpS > 0))
                {
                    if (SanderSpeedEffectUpToMpS > 0.0f)
                    {
                        if ((Sander) && (AbsSpeedMpS < SanderSpeedEffectUpToMpS))
                        {
                            SandingFrictionCoefficientFactor = (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.50f;
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor;

                        }
                    }
                    else
                    {
                        if (Sander)  // If sander is on, and train speed is greater then zero, then put sand on the track
                        {
                            SandingFrictionCoefficientFactor = 1.50f;
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor; // Sanding track adds approx 150% adhesion (best case)
                        }
                    }
                }
                else if (Sander && CurrentTrackSandBoxCapacityM3 > 0.0 && MainResPressurePSI > 80.0)
                {
                    SandingFrictionCoefficientFactor = 1.50f;
                    BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor; // Sanding track adds approx 150% adhesion (best case)
                }
            }
            else if (simulator.WeatherType == WeatherType.Rain)
            {
                if (AbsSpeedMpS < SanderSpeedOfMpS && CurrentTrackSandBoxCapacityM3 > 0.0 && MainResPressurePSI > 80.0 && (AbsSpeedMpS > 0))
                {
                    if (SanderSpeedEffectUpToMpS > 0.0f)
                    {
                        if ((Sander) && (AbsSpeedMpS < SanderSpeedEffectUpToMpS))
                        {
                            SandingFrictionCoefficientFactor = (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.25f;
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor;

                        }
                    }
                    else
                    {
                        if (Sander)  // If sander is on, and train speed is greater then zero, then put sand on the track
                        {
                            SandingFrictionCoefficientFactor = 1.25f;
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor; // Sanding track adds approx 125% adhesion (best case)
                        }
                    }
                }
                else if (Sander && CurrentTrackSandBoxCapacityM3 > 0.0 && MainResPressurePSI > 80.0)
                {
                    SandingFrictionCoefficientFactor = 1.25f;
                    BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor; // Sanding track adds approx 125% adhesion (best case)
                }
            }
            else // dry weather
            {
                if (AbsSpeedMpS < SanderSpeedOfMpS && CurrentTrackSandBoxCapacityM3 > 0.0 && MainResPressurePSI > 80.0 && (AbsSpeedMpS > 0))
                {
                    if (SanderSpeedEffectUpToMpS > 0.0f)
                    {
                        if ((Sander) && (AbsSpeedMpS < SanderSpeedEffectUpToMpS))
                        {
                            SandingFrictionCoefficientFactor = (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.40f;
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor;
                        }
                    }
                    else
                    {
                        if (Sander)  // If sander is on, and train speed is greater then zero, then put sand on the track
                        {
                            SandingFrictionCoefficientFactor = 1.40f;
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor; // Sanding track adds approx 140% adhesion (best case)
                        }
                    }
                }
                else if (Sander && CurrentTrackSandBoxCapacityM3 > 0.0 && MainResPressurePSI > 80.0)
                {
                    SandingFrictionCoefficientFactor = 1.40f;
                    BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor; // Sanding track adds approx 140% adhesion (best case)
                }

            }

            // For wagons use base Curtius-Kniffler adhesion factor - u = 0.33
            float WagonCurtius_KnifflerA = 7.5f;
            float WagonCurtius_KnifflerB = 44.0f;
            float WagonCurtius_KnifflerC = 0.161f;

            float WagonBaseuMax = (float)(WagonCurtius_KnifflerA / (Speed.MeterPerSecond.ToKpH(AbsSpeedMpS) + WagonCurtius_KnifflerB) + WagonCurtius_KnifflerC);
            Train.WagonCoefficientFriction = WagonBaseuMax * BaseFrictionCoefficientFactor;  // Find friction coefficient factor for wagons based upon environmental conditions
            WagonCoefficientFrictionHUD = Train.WagonCoefficientFriction; // Save value for HUD display

            if (EngineType == EngineType.Steam && SteamDrvWheelWeightLbs < 10000 && simulator.WeatherType == WeatherType.Clear)
            {
                BaseFrictionCoefficientFactor *= 0.75f;  // Dry track - static friction for vehicles with wheel weights less then 10,000lbs - u = 0.25

            }

            var AdhesionMultiplier = simulator.Settings.AdhesionFactor / 100.0f; // Convert to a factor where 100% = no change to adhesion
            var AdhesionRandom = (float)(simulator.Settings.AdhesionFactorChange * 0.01f * 2f * (StaticRandom.NextDouble() - 0.5f));

            Train.LocomotiveCoefficientFriction = BaseuMax * BaseFrictionCoefficientFactor * AdhesionMultiplier;  // Find friction coefficient factor for locomotive
            Train.LocomotiveCoefficientFriction = MathHelper.Clamp(Train.LocomotiveCoefficientFriction, 0.05f, 0.8f); // Ensure friction coefficient never exceeds a "reasonable" value

            // Set adhesion conditions for diesel, electric or steam geared locomotives
            if (elapsedClockSeconds > 0)
            {
                saveAdhesionFilter = adhesionFilter.Filter(BaseFrictionCoefficientFactor + AdhesionRandom, elapsedClockSeconds);
                adhesionConditions = Math.Clamp(AdhesionMultiplier * saveAdhesionFilter, 0.05f, 2.5f);
                LocomotiveAxle.AdhesionLimit = (float)(adhesionConditions * BaseuMax);
            }

            // Set adhesion conditions for other steam locomotives
            if (this is MSTSSteamLocomotive steamLocomotive3 && steamLocomotive3.SteamEngineType != SteamEngineType.Geared)  // ToDo explore adhesion factors
            {
                LocomotiveCoefficientFrictionHUD = Train.LocomotiveCoefficientFriction; // Set display value for HUD - steam
            }
            else
            {
                LocomotiveCoefficientFrictionHUD = BaseuMax * LocomotiveAxle.AdhesionLimit; // Set display value for HUD - diesel
            }

        }

        #endregion


        public void UpdateTrackSander(double elapsedClockSeconds)
        {
            // updates track sander in terms of sand usage and impact on air compressor
            // The following assumptions have been made:
            //

            if (Sander)  // If sander is on adjust parameters
            {
                if (CurrentTrackSandBoxCapacityM3 > 0.0) // if sand still in sandbox then sanding is available
                {
                    // Calculate consumption of sand, and drop in sand box level
                    float ActualSandConsumptionM3pS = (float)(Time.Second.FromH(TrackSanderSandConsumptionM3pS) * elapsedClockSeconds);
                    CurrentTrackSandBoxCapacityM3 -= ActualSandConsumptionM3pS;
                    CurrentTrackSandBoxCapacityM3 = MathHelper.Clamp(CurrentTrackSandBoxCapacityM3, 0.0f, MaxTrackSandBoxCapacityM3);
                    if (CurrentTrackSandBoxCapacityM3 == 0.0)
                    {
                        simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Sand supply has been exhausted"));
                    }
                }

                // Calculate air consumption and change in main air reservoir pressure
                float ActualAirConsumptionM3pS = (float)(Time.Second.FromM(TrackSanderAirComsumptionM3pS) * elapsedClockSeconds);
                float SanderPressureDiffPSI = ActualAirConsumptionM3pS / (float)Size.Volume.ToFt3(MainResVolumeM3);
                MainResPressurePSI -= SanderPressureDiffPSI;
                MainResPressurePSI = MathHelper.Clamp(MainResPressurePSI, 0.001f, MaxMainResPressurePSI);
            }

        }

        #region Reverser
        public void SetDirection(MidpointDirection direction)
        {
            if (Direction != direction && ThrottlePercent < 1)
            {
                Direction = direction;
                switch (direction)
                {
                    case MidpointDirection.Reverse:
                        SignalEvent(TrainEvent.ReverserToForwardBackward);
                        break;
                    case MidpointDirection.N:
                        SignalEvent(TrainEvent.ReverserToNeutral);
                        break;
                    case MidpointDirection.Forward:
                        SignalEvent(TrainEvent.ReverserToForwardBackward);
                        break;
                }
                // passes event also to other locomotives
                foreach (TrainCar car in Train.Cars)
                {
                    //                    if (loco != null && car != this && loco.AcceptMUSignals)
                    if (car is MSTSLocomotive loco && car != this && loco.RemoteControlGroup != RemoteControlGroup.Unconnected)
                        switch (direction)
                        {
                            case MidpointDirection.Reverse:
                                loco.SignalEvent(TrainEvent.ReverserToForwardBackward);
                                break;
                            case MidpointDirection.N:
                                loco.SignalEvent(TrainEvent.ReverserToNeutral);
                                break;
                            case MidpointDirection.Forward:
                                loco.SignalEvent(TrainEvent.ReverserToForwardBackward);
                                break;
                        }

                }
                SignalEvent(TrainEvent.ReverserChange);
                if (direction == MidpointDirection.Forward)
                    Train.MUReverserPercent = 100;
                else
                    Train.MUReverserPercent = -100;
            }

        }

        public virtual void StartReverseIncrease(float? target)
        {
            AlerterReset(TCSEvent.ReverserChanged);
            if (this.IsLeadLocomotive())
            {
                {
                    switch (Direction)
                    {
                        case MidpointDirection.Reverse:
                            SetDirection(MidpointDirection.N);
                            simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Neutral);
                            break;
                        case MidpointDirection.N:
                            SetDirection(MidpointDirection.Forward);
                            simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.On);
                            break;
                        case MidpointDirection.Forward:
                            SetDirection(MidpointDirection.Forward);
                            simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.On);
                            break;
                    }
                }
            }
        }

        public virtual void StartReverseDecrease(float? target)
        {
            AlerterReset(TCSEvent.ReverserChanged);
            if (this.IsLeadLocomotive())
            {
                {
                    switch (Direction)
                    {
                        case MidpointDirection.Reverse:
                            SetDirection(MidpointDirection.Reverse);
                            simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Off);
                            break;
                        case MidpointDirection.N:
                            SetDirection(MidpointDirection.Reverse);
                            simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Off);
                            break;
                        case MidpointDirection.Forward:
                            SetDirection(MidpointDirection.N);
                            simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Neutral);
                            break;
                    }
                }
            }
        }
        #endregion

        #region ThrottleController
        public void StartThrottleIncrease(float? target)
        {
            if (CruiseControl != null && target != null)
            {
                if (CruiseControl.DisableCruiseControlOnThrottleAndZeroSpeed && AbsSpeedMpS == 0 && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto)
                {
                    if (CruiseControl.ZeroSelectedSpeedWhenPassingToThrottleMode)
                        CruiseControl.SetSpeed(0);
                    CruiseControl.SpeedRegulatorMode = SpeedRegulatorMode.Manual;
                }
                if (CruiseControl.DisableCruiseControlOnThrottleAndZeroForce && CruiseControl.SelectedMaxAccelerationPercent == 0 && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto)
                {
                    if (CruiseControl.ZeroSelectedSpeedWhenPassingToThrottleMode)
                        CruiseControl.SetSpeed(0);
                    CruiseControl.SpeedRegulatorMode = SpeedRegulatorMode.Manual;
                }
                if (CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.UseThrottleAsSpeedSelector)
                {
                    CruiseControl.SpeedRegulatorSelectedSpeedStartIncrease();
                    return;
                }
                if (CruiseControl.DisableCruiseControlOnThrottleAndZeroForceAndZeroSpeed && CruiseControl.SelectedSpeedMpS == 0 &&
                    CruiseControl.SelectedMaxAccelerationPercent == 0 && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto)
                {
                    if (CruiseControl.ZeroSelectedSpeedWhenPassingToThrottleMode)
                        CruiseControl.SetSpeed(0);
                    CruiseControl.SpeedRegulatorMode = SpeedRegulatorMode.Manual;
                }
            }
            if (ThrottleController.CurrentValue >= ThrottleController.MaximumValue)
                return;

            if (target != null)
                ThrottleController.StartIncrease(target);
            else
                _ = new NotchedThrottleCommand(simulator.Log, true);

            SignalEvent(TrainEvent.ThrottleChange);
            AlerterReset(TCSEvent.ThrottleChanged);
            CommandStartTime = simulator.ClockTime;
        }

        public void StartThrottleIncrease()
        {
            if (CruiseControl?.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.SelectedMaxAccelerationPercent != 0
                && CruiseControl.HasIndependentThrottleDynamicBrakeLever)
                return;
            if ((CruiseControl?.SelectedMaxAccelerationPercent == 0 && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto) &&
                (CruiseControl.DisableCruiseControlOnThrottleAndZeroForce || CruiseControl.DisableCruiseControlOnThrottleAndZeroForceAndZeroSpeed && CruiseControl.SelectedSpeedMpS == 0))
            {
                if (CruiseControl.ZeroSelectedSpeedWhenPassingToThrottleMode)
                    CruiseControl.SetSpeed(0);
                if (ThrottleController.CurrentValue == 0)
                {
                    CruiseControl.SpeedRegulatorMode = SpeedRegulatorMode.Manual;
                }
                CruiseControl.SkipThrottleDisplay = false;
            }
            MultiPositionController mpc = MultiPositionControllers.Where(x => x.ControllerBinding == CruiseControllerBinding.Throttle).FirstOrDefault();
            if (mpc != null)
            {
                if (!mpc.StateChanged)
                {
                    mpc.StateChanged = true;
                    mpc.DoMovement(Movement.Forward);
                }
                return;
            }
            if (CruiseControl != null && (CombinedControlType == CombinedControl.None || CruiseControl.UseThrottleInCombinedControl))
            {
                if (CruiseControl.UseThrottleAsForceSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && !CruiseControl.DynamicBrakePriority)
                {
                    CruiseControl.SpeedRegulatorMaxForceStartIncrease();
                    return;
                }
                else
                {
                    if (CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && !CruiseControl.DynamicBrakePriority)
                    {
                        if (!CruiseControl.UseThrottleAsSpeedSelector)
                            return;
                    }
                }
            }
            //bool checkBraking = true;
            //if (CruiseControl != null)
            //{
            //    if (CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.UseThrottleAsSpeedSelector)
            //    {
            //        checkBraking = false;
            //    }
            //}
            if (DynamicBrakeController != null && DynamicBrakeController.CurrentValue >= 0 && (DynamicBrakePercent >= 0 || !(DynamicBrakePercent == -1 && !DynamicBrake || DynamicBrakePercent >= 0 && DynamicBrake)))
            {
                if (!(CombinedControlType == CombinedControl.ThrottleDynamic
                    || CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0))
                {
                    simulator.Confirmer.Warning(CabControl.Throttle, CabSetting.Warn1);
                    return;
                }
            }

            if (CombinedControlType == CombinedControl.ThrottleDynamic && DynamicBrake)
                StartDynamicBrakeDecrease(null);
            else if (CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0)
                StartTrainBrakeDecrease(null);
            else
                StartThrottleIncrease(ThrottleController.SmoothMax());
        }

        public void StopThrottleIncrease()
        {
            MultiPositionController mpc = MultiPositionControllers.Where(x => x.ControllerBinding == CruiseControllerBinding.Throttle).FirstOrDefault();
            if (mpc != null)
            {
                if (mpc.StateChanged)
                {
                    mpc.StateChanged = false;
                    mpc.DoMovement(Movement.Neutral);
                }
                return;
            }
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsForceSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto &&
                    !(CruiseControl.UseThrottleInCombinedControl && CruiseControl.DynamicBrakePriority))
                {
                    CruiseControl.SpeedRegulatorMaxForceStopIncrease();
                    return;
                }
                else
                {
                    if (CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.UseThrottleAsSpeedSelector && CruiseControl.SelectedSpeedMpS > 0)
                    {
                        CruiseControl.SpeedRegulatorSelectedSpeedStopIncrease();
                        return;
                    }
                }
            }
            AlerterReset(TCSEvent.ThrottleChanged);
            ThrottleController.StopIncrease();

            if (CombinedControlType == CombinedControl.ThrottleDynamic)
                StopDynamicBrakeDecrease();
            else if (CombinedControlType == CombinedControl.ThrottleAir)
                StopTrainBrakeDecrease();
            else if (ThrottleController.SmoothMax() != null)
                _ = new ContinuousThrottleCommand(simulator.Log, true, ThrottleController.CurrentValue, CommandStartTime);
        }

        public void StartThrottleDecrease(float? target)
        {
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsSpeedSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.SelectedSpeedMpS > 0)
                {
                    CruiseControl.SpeedRegulatorSelectedSpeedStartDecrease();
                    return;
                }
            }
            if (ThrottleController.CurrentValue <= ThrottleController.MinimumValue)
                return;

            if (target != null)
                ThrottleController.StartDecrease(target);
            else
                _ = new NotchedThrottleCommand(simulator.Log, false);

            SignalEvent(TrainEvent.ThrottleChange);
            AlerterReset(TCSEvent.ThrottleChanged);
            CommandStartTime = simulator.ClockTime;
        }

        public void StartThrottleDecrease()
        {
            if (CruiseControl?.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.SelectedMaxAccelerationPercent != 0
                && CruiseControl.HasIndependentThrottleDynamicBrakeLever)
                return;
            if ((CruiseControl?.SelectedMaxAccelerationPercent == 0 && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto) &&
                (CruiseControl.DisableCruiseControlOnThrottleAndZeroForce || CruiseControl.DisableCruiseControlOnThrottleAndZeroForceAndZeroSpeed && CruiseControl.SelectedSpeedMpS == 0))
            {
                if (CruiseControl.ZeroSelectedSpeedWhenPassingToThrottleMode)
                    CruiseControl.SetSpeed(0);
                if (ThrottleController.CurrentValue == 0)
                {
                    CruiseControl.SpeedRegulatorMode = SpeedRegulatorMode.Manual;
                }
                CruiseControl.SkipThrottleDisplay = false;
            }
            MultiPositionController mpc = MultiPositionControllers.Where(x => x.ControllerBinding == CruiseControllerBinding.Throttle).FirstOrDefault();
            if (mpc != null)
            {
                if (!mpc.StateChanged)
                {
                    mpc.StateChanged = true;
                    mpc.DoMovement(Movement.Backward);
                }
                return;
            }
            if (CruiseControl != null && (CombinedControlType == CombinedControl.None || CruiseControl.UseThrottleInCombinedControl))
            {
                if (CruiseControl.UseThrottleAsForceSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto &&
                    !(CruiseControl.DynamicBrakeCommandHasPriorityOverCruiseControl && (CruiseControl.DynamicBrakePriority ||
                    (CruiseControl.SelectedMaxAccelerationPercent == 0))))
                {
                    CruiseControl.SpeedRegulatorMaxForceStartDecrease();
                    return;
                }
                else
                {
                    if (CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && !CruiseControl.UseThrottleAsSpeedSelector &&
                    !(CruiseControl.DynamicBrakeCommandHasPriorityOverCruiseControl && ThrottleController.CurrentValue <= 0))
                    {
                        return;
                    }
                }
            }
            if (CruiseControl?.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.SelectedSpeedMpS > 0 && CruiseControl.UseThrottleAsSpeedSelector)
            {
                ThrottleController.CurrentValue = 1;
            }
            if (CombinedControlType == CombinedControl.ThrottleDynamic && ThrottleController.CurrentValue <= 0)
                StartDynamicBrakeIncrease(null);
            else if (CombinedControlType == CombinedControl.ThrottleAir && ThrottleController.CurrentValue <= 0)
                StartTrainBrakeIncrease(null);
            else
                StartThrottleDecrease(ThrottleController.SmoothMin());
        }

        public void StopThrottleDecrease()
        {
            MultiPositionController mpc = MultiPositionControllers.Where(x => x.ControllerBinding == CruiseControllerBinding.Throttle).FirstOrDefault();
            if (mpc != null)
            {
                if (mpc.StateChanged)
                {
                    mpc.StateChanged = false;
                    mpc.DoMovement(Movement.Neutral);
                }
                return;
            }
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsSpeedSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.SelectedSpeedMpS > 0)
                {
                    CruiseControl.SpeedRegulatorSelectedSpeedStopDecrease();
                    return;
                }
                else
                {
                    if (CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.SelectedSpeedMpS > 0)
                    {
                        speedSelectorModeDecreasing = false;
                    }
                }
                if (CombinedControlType == CombinedControl.None || CruiseControl.UseThrottleInCombinedControl)
                {
                    if (CruiseControl.UseThrottleAsForceSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto
                        && (CruiseControl.SelectedMaxAccelerationPercent > 0))
                    {
                        CruiseControl.SpeedRegulatorMaxForceStopDecrease();
                        return;
                    }
                }
            }
            AlerterReset(TCSEvent.ThrottleChanged);
            ThrottleController.StopDecrease();

            if (CombinedControlType == CombinedControl.ThrottleDynamic)
                StopDynamicBrakeIncrease();
            else if (CombinedControlType == CombinedControl.ThrottleAir)
                StopTrainBrakeIncrease();
            if (ThrottleController.SmoothMin() != null)
                _ = new ContinuousThrottleCommand(simulator.Log, false, ThrottleController.CurrentValue, CommandStartTime);
        }

        //Steam Heat Controller

        #region Steam heating controller
        public void StartSteamHeatIncrease()
        {
            StartSteamHeatIncrease(null);
        }

        public void StartSteamHeatIncrease(float? target)
        {
            SteamHeatController.CommandStartTime = simulator.ClockTime;
            if (IsPlayerTrain)
                simulator.Confirmer.ConfirmWithPerCent(CabControl.SteamHeat, CabSetting.Increase, SteamHeatController.CurrentValue * 100);
            SteamHeatController.StartIncrease(target);
            SignalEvent(TrainEvent.SteamHeatChange);
        }

        public void StopSteamHeatIncrease()
        {
            SteamHeatController.StopIncrease();
            new ContinuousSteamHeatCommand(simulator.Log, 1, true, SteamHeatController.CurrentValue, SteamHeatController.CommandStartTime);
        }

        public void StartSteamHeatDecrease()
        {
            StartSteamHeatDecrease(null);
        }

        public void StartSteamHeatDecrease(float? target)
        {
            if (IsPlayerTrain)
                simulator.Confirmer.ConfirmWithPerCent(CabControl.SteamHeat, CabSetting.Decrease, SteamHeatController.CurrentValue * 100);
            SteamHeatController.StartDecrease(target);
            SignalEvent(TrainEvent.SteamHeatChange);
        }

        public void StopSteamHeatDecrease()
        {
            SteamHeatController.StopDecrease();
            if (IsPlayerTrain)
                new ContinuousSteamHeatCommand(simulator.Log, 1, false, SteamHeatController.CurrentValue, SteamHeatController.CommandStartTime);
        }

        public void SteamHeatChangeTo(bool increase, float? target)
        {
            if (increase)
            {
                if (target > SteamHeatController.CurrentValue)
                {
                    StartSteamHeatIncrease(target);
                }
            }
            else
            {
                if (target < SteamHeatController.CurrentValue)
                {
                    StartSteamHeatDecrease(target);
                }
            }
        }

        public void SetSteamHeatValue(float value)
        {
            var controller = SteamHeatController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new ContinuousSteamHeatCommand(simulator.Log, 1, change > 0, controller.CurrentValue, simulator.GameTime);
            }
            if (oldValue != controller.IntermediateValue)
                simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeat, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, controller.CurrentValue * 100);
        }

        public void ToggleWaterScoop()
        {
            if (simulator.PlayerLocomotive == this)
            {
                WaterScoopDown = !WaterScoopDown;
                SignalEvent(TrainEvent.WaterScoopRaiseLower);
                if (WaterScoopDown)
                {
                    IsWaterScoopDown = true; // Set flag to potentially fill from water trough
                }
                else
                {
                    IsWaterScoopDown = false;
                    WaterScoopOverTroughFlag = false; // Reset flags so that message will come up again
                    WaterScoopNotFittedFlag = false;
                    WaterScoopSlowSpeedFlag = false;
                    WaterScoopDirectionFlag = false;
                }
                simulator.Confirmer.Confirm(CabControl.WaterScoop, WaterScoopDown ? CabSetting.On : CabSetting.Off);
            }
        }



        #endregion

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        public void ThrottleChangeTo(bool increase, float? target)
        {
            if ((CruiseControl != null && target != 0 && CruiseControl.SelectedMaxAccelerationPercent <= 0
                && ThrottleController.CurrentValue == 0 && DynamicBrakeController.CurrentValue == 0) &&
                (CruiseControl.DisableCruiseControlOnThrottleAndZeroForce || CruiseControl.DisableCruiseControlOnThrottleAndZeroForceAndZeroSpeed && CruiseControl.SelectedSpeedMpS == 0))
            {
                if (CruiseControl.ZeroSelectedSpeedWhenPassingToThrottleMode)
                    CruiseControl.SetSpeed(0);
                CruiseControl.SpeedRegulatorMode = SpeedRegulatorMode.Manual;
            }
            if (increase)
            {
                if (target > ThrottleController.CurrentValue)
                {
                    StartThrottleIncrease(target);
                }
            }
            else
            {
                if (target < ThrottleController.CurrentValue)
                {
                    StartThrottleDecrease(target);
                }
            }
        }

        /// <summary>
        /// Used by commands to make a single adjustment.
        /// </summary>
        public void AdjustNotchedThrottle(bool increase)
        {
            if (increase)
            {
                ThrottleController.StartIncrease();
                ThrottleController.StopIncrease();
            }
            else
            {
                ThrottleController.StartDecrease();
                ThrottleController.StopDecrease();
            }
            simulator.Confirmer.ConfirmWithPerCent(CabControl.Throttle, ThrottleController.CurrentValue * 100);
        }

        public void SetThrottleValue(float value)
        {
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsForceSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto)
                {
                    CruiseControl.SetMaxForcePercent((float)Math.Round(value * 100, 0));
                    if (!CruiseControl.UseThrottleInCombinedControl)
                        ThrottleController.SetValue(value);
                    return;
                }
                if (CruiseControl.UseThrottleAsSpeedSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto)
                {
                    CruiseControl.SetSpeed((float)Math.Round((Speed.MeterPerSecond.ToKpH(MaxSpeedMpS) / 100) * value * 100, 0));
                    return;
                }
            }
            var controller = ThrottleController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                _ = new ContinuousThrottleCommand(simulator.Log, change > 0, controller.CurrentValue, simulator.ClockTime);
                SignalEvent(TrainEvent.ThrottleChange);
                AlerterReset(TCSEvent.ThrottleChanged);
            }
            if (oldValue != controller.IntermediateValue)
                simulator.Confirmer.UpdateWithPerCent(
                    this is MSTSSteamLocomotive ? CabControl.Regulator : CabControl.Throttle,
                    oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease,
                    controller.CurrentValue * 100);
        }

        public void SetThrottlePercent(float percent)
        {
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsForceSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto)
                {
                    CruiseControl.SetMaxForcePercent(percent);
                    if (!CruiseControl.UseThrottleInCombinedControl)
                        ThrottleController.SetPercent(percent);
                    return;
                }
                else
                    ThrottleController.SetPercent(percent);
            }
            else
                ThrottleController.SetPercent(percent);
        }

        public void SetThrottlePercentWithSound(float percent)
        {
            var oldThrottlePercent = ThrottleController.CurrentValue * 100;
            SetThrottlePercent(percent);
            if (Math.Abs(oldThrottlePercent - ThrottleController.CurrentValue * 100) > 2)
                SignalEvent(TrainEvent.ThrottleChange);
        }

        public void ThrottleToZero()
        {
            if (CruiseControl?.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.SelectedMaxAccelerationPercent != 0
                && CruiseControl.HasIndependentThrottleDynamicBrakeLever)
                return;
            if ((CruiseControl?.SelectedMaxAccelerationPercent == 0 && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto) &&
                (CruiseControl.DisableCruiseControlOnThrottleAndZeroForce || CruiseControl.DisableCruiseControlOnThrottleAndZeroForceAndZeroSpeed && CruiseControl.SelectedSpeedMpS == 0))
            {
                if (CruiseControl.ZeroSelectedSpeedWhenPassingToThrottleMode)
                    CruiseControl.SetSpeed(0);
                if (ThrottleController.CurrentValue == 0)
                {
                    CruiseControl.SpeedRegulatorMode = SpeedRegulatorMode.Manual;
                }
                CruiseControl.SkipThrottleDisplay = false;
            }
            if (CruiseControl != null && (CombinedControlType == CombinedControl.None || CruiseControl.UseThrottleInCombinedControl))
            {
                if (CruiseControl.UseThrottleAsForceSelector && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto &&
                    !(CruiseControl.DynamicBrakeCommandHasPriorityOverCruiseControl && CruiseControl.DynamicBrakePriority))
                {
                    CruiseControl.SpeedRegulatorMaxForceStartDecrease();
                    return;
                }
                else
                {
                    if (CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && !CruiseControl.UseThrottleAsSpeedSelector &&
                    !(CruiseControl.DynamicBrakeCommandHasPriorityOverCruiseControl && ThrottleController.CurrentValue <= 0))
                    {
                        return;
                    }
                }
            }
            if (CruiseControl?.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.SelectedSpeedMpS > 0 && CruiseControl.UseThrottleAsSpeedSelector)
            {
                ThrottleController.CurrentValue = 1;
            }
            if (CombinedControlType == CombinedControl.ThrottleDynamic && ThrottleController.CurrentValue <= 0)
                StartDynamicBrakeIncrease(null);
            else if (CombinedControlType == CombinedControl.ThrottleAir && ThrottleController.CurrentValue <= 0)
                StartTrainBrakeIncrease(null);
            else
                StartThrottleToZero(0.0f);
        }

        public void StartThrottleToZero(float? target)
        {
            if (ThrottleController.CurrentValue <= ThrottleController.MinimumValue)
                return;

            ThrottleController.StartDecrease(target, true);
            if (ThrottleController.NotchCount() <= 0)
                SignalEvent(TrainEvent.ThrottleChange);
            AlerterReset(TCSEvent.ThrottleChanged);
            CommandStartTime = simulator.ClockTime;
        }

        /// <summary>
        /// Returns the position of the throttle handle considering 
        /// whether it is used for cruise control or not
        /// </summary>
        /// <param name="intermediateValue">Whather asking for intermediate (for mouse operation) or notched (for displaying) value.</param>
        /// <returns>Combined position into 0-1 range</returns>
        public float GetThrottleHandleValue(float data)
        {
            if (CruiseControl?.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.SelectedMaxAccelerationPercent != 0
                && CruiseControl.HasIndependentThrottleDynamicBrakeLever)
                return ThrottleController.CurrentValue;
            else if (CruiseControl?.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.UseThrottleAsForceSelector)
                return CruiseControl.SelectedMaxAccelerationPercent / 100;
            else if (CruiseControl?.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.UseThrottleAsSpeedSelector)
                return CruiseControl.SelectedSpeedMpS / MaxSpeedMpS;
            else if (CruiseControl == null || CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Manual)
                return data;
            else
                return ThrottleController.CurrentValue;
        }

        #endregion

        #region CombinedHandle
        /// <summary>
        /// Determines which sub-control of combined handle is to be set when receiving a combined value.
        /// Combined value is in 0-1 range, where arrangement is [[1--throttle--0]split[0--dynamic|airbrake--1]].
        /// </summary>
        public void SetCombinedHandleValue(float value)
        {
            bool ccUseCombinedControl = CruiseControl != null && (CruiseControl.UseThrottleAsForceSelector || CruiseControl.UseThrottleAsSpeedSelector) && CruiseControl.UseThrottleInCombinedControl;
            if (CombinedControlType == CombinedControl.ThrottleDynamic && DynamicBrake && !TrainControlSystem.FullDynamicBrakingOrder &&
                !(ccUseCombinedControl && !CruiseControl.DynamicBrakePriority && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto))
            {
                if (DynamicBrakeController.CurrentValue == 0 && value < CombinedControlSplitPosition)
                    DynamicBrakeChangeActiveState(false);
                else if (DynamicBrakePercent > -1)
                    SetDynamicBrakeValue((MathHelper.Clamp(value, CombinedControlSplitPosition, 1) - CombinedControlSplitPosition) / (1 - CombinedControlSplitPosition));
            }
            else if (CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0)
            {
                SetTrainBrakeValue((MathHelper.Clamp(value, CombinedControlSplitPosition, 1) - CombinedControlSplitPosition) / (1 - CombinedControlSplitPosition));
            }
            else
            {
                bool canBrake = ThrottleController.CurrentValue == 0;
                if (ccUseCombinedControl && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto)
                    canBrake = (CruiseControl.UseThrottleAsForceSelector && CruiseControl.SelectedMaxAccelerationPercent == 0) || (CruiseControl.UseThrottleAsSpeedSelector && CruiseControl.SelectedSpeedMpS == 0);
                if (CombinedControlType == CombinedControl.ThrottleDynamic && canBrake && value > CombinedControlSplitPosition)
                {
                    DynamicBrakeChangeActiveState(true);
                    if (CruiseControl != null && CruiseControl.DynamicBrakeCommandHasPriorityOverCruiseControl)
                        CruiseControl.DynamicBrakePriority = true;
                }
                else if (CombinedControlType == CombinedControl.ThrottleAir && canBrake && value > CombinedControlSplitPosition)
                    SetTrainBrakeValue((MathHelper.Clamp(value, CombinedControlSplitPosition, 1) - CombinedControlSplitPosition) / (1 - CombinedControlSplitPosition));
                else if (DynamicBrakePercent < 0 || TrainControlSystem.FullDynamicBrakingOrder ||
                    (CruiseControl != null && !CruiseControl.DynamicBrakePriority && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto))
                {
                    SetThrottleValue(1 - MathHelper.Clamp(value, 0, CombinedControlSplitPosition) / CombinedControlSplitPosition);
                }
            }
        }

        /// <summary>
        /// Determines which sub-control of combined handle is active (based on its type), 
        /// and returns the overall position considering the split position. 
        /// </summary>
        /// <param name="intermediateValue">Whather asking for intermediate (for mouse operation) or notched (for displaying) value.</param>
        /// <returns>Combined position into 0-1 range, where arrangement is [[1--throttle--0]split[0--dynamic|airbrake--1]]</returns>
        public float GetCombinedHandleValue(bool intermediateValue)
        {
            if (CruiseControl?.SpeedRegulatorMode == SpeedRegulatorMode.Auto)
            {
                if (CruiseControl.SelectedMaxAccelerationPercent != 0 && CruiseControl.HasIndependentThrottleDynamicBrakeLever)
                    return CombinedControlSplitPosition;
                if (CruiseControl.UseThrottleAsForceSelector && CruiseControl.UseThrottleInCombinedControl && !CruiseControl.DynamicBrakePriority
                    && CombinedControlType == CombinedControl.ThrottleDynamic)
                    return CombinedControlSplitPosition * (1 - (CruiseControl.SelectedMaxAccelerationPercent / 100));
                if (CruiseControl.UseThrottleAsSpeedSelector && CruiseControl.UseThrottleInCombinedControl)
                {
                    if (!CruiseControl.DynamicBrakePriority && CombinedControlType == CombinedControl.ThrottleDynamic
                        || !CruiseControl.TrainBrakePriority && CombinedControlType == CombinedControl.ThrottleAir)
                        return CombinedControlSplitPosition * (1 - (CruiseControl.SelectedSpeedMpS / MaxSpeedMpS));
                }
            }

            if (CombinedControlType == CombinedControl.ThrottleDynamic && DynamicBrake && !TrainControlSystem.FullDynamicBrakingOrder)
            {
                if (CruiseControl != null)
                {
                    if (CruiseControl.SkipThrottleDisplay && !CruiseControl.DynamicBrakeCommandHasPriorityOverCruiseControl)
                    {
                        return CombinedControlSplitPosition;
                    }
                    else
                    {
                        return CombinedControlSplitPosition + (1 - CombinedControlSplitPosition) * (intermediateValue ? DynamicBrakeController.IntermediateValue : DynamicBrakeController.CurrentValue);
                    }
                }
                else
                {
                    return CombinedControlSplitPosition + (1 - CombinedControlSplitPosition) * (intermediateValue ? DynamicBrakeController.IntermediateValue : DynamicBrakeController.CurrentValue);
                }
            }
            else if (CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0)
                return CombinedControlSplitPosition + (1 - CombinedControlSplitPosition) * (intermediateValue ? TrainBrakeController.IntermediateValue : TrainBrakeController.CurrentValue);
            else if (CruiseControl == null)
                return CombinedControlSplitPosition * (1 - (intermediateValue ? ThrottleController.IntermediateValue : ThrottleController.CurrentValue));
            else if (CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Manual)
                return CombinedControlSplitPosition * (1 - (intermediateValue ? ThrottleController.IntermediateValue : ThrottleController.CurrentValue));
            else if (CruiseControl.UseThrottleAsSpeedSelector)
                return CombinedControlSplitPosition * (1 - (CruiseControl.SelectedSpeedMpS / MaxSpeedMpS));
            else if (CruiseControl.UseThrottleAsForceSelector && CruiseControl.UseThrottleInCombinedControl)
                return CombinedControlSplitPosition * (1 - (CruiseControl.SelectedMaxAccelerationPercent / 100));
            else
                return CombinedControlSplitPosition;
        }
        #endregion

        #region GearBoxController
        public virtual void ChangeGearUp()
        {

        }

        public virtual void StartGearBoxIncrease()
        {
            if (GearBoxController != null)
            {
                if (this is MSTSDieselLocomotive dieselloco)
                {
                    if (dieselloco.DieselTransmissionType == DieselTransmissionType.Mechanic)
                    {
                        if (dieselloco.DieselEngines[0].GearBox.GearBoxType != GearBoxType.C)
                        {
                            GearBoxController.StartIncrease();
                            simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Increase, GearBoxController.NotchIndex);
                            AlerterReset(TCSEvent.GearBoxChanged);
                            SignalGearBoxChangeEvents();
                            dieselloco.DieselEngines[0].GearBox.ClutchOn = false;
                            dieselloco.DieselEngines[0].GearBox.ManualGearChange = true;

                        }
                        else
                        {

                            if (ThrottlePercent == 0)
                            {
                                GearBoxController.StartIncrease();
                                simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Increase, dieselloco.DieselEngines[0].GearBox.GearIndication);
                                AlerterReset(TCSEvent.GearBoxChanged);
                                SignalGearBoxChangeEvents();
                                dieselloco.DieselEngines[0].GearBox.ClutchOn = false;
                            }
                            else
                            {
                                simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Throttle must be reduced to Idle before gear change can happen."));
                            }
                        }
                    }
                    else  // Legacy operation
                    {
                        GearBoxController.StartIncrease();
                        simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Increase, GearBoxController.NotchIndex);
                        AlerterReset(TCSEvent.GearBoxChanged);
                        SignalGearBoxChangeEvents();
                    }
                }
            }
            ChangeGearUp();
        }

        public virtual void StopGearBoxIncrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StopIncrease();
            }
        }

        public virtual void ChangeGearDown()
        {

        }

        public virtual void StartGearBoxDecrease()
        {
            if (GearBoxController != null)
            {
                if (this is MSTSDieselLocomotive dieselloco)
                {
                    if (dieselloco.DieselTransmissionType == DieselTransmissionType.Mechanic)
                    {

                        if (dieselloco.DieselEngines[0].GearBox.GearBoxType != GearBoxType.C)
                        {
                            GearBoxController.StartDecrease();
                            simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Decrease, GearBoxController.NotchIndex);
                            AlerterReset(TCSEvent.GearBoxChanged);
                            SignalGearBoxChangeEvents();
                            dieselloco.DieselEngines[0].GearBox.ClutchOn = false;
                            dieselloco.DieselEngines[0].GearBox.ManualGearChange = true;
                        }
                        else
                        {
                            if (ThrottlePercent == 0)
                            {
                                GearBoxController.StartDecrease();
                                simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Decrease, dieselloco.DieselEngines[0].GearBox.GearIndication);
                                AlerterReset(TCSEvent.GearBoxChanged);
                                SignalGearBoxChangeEvents();
                                dieselloco.DieselEngines[0].GearBox.ClutchOn = false;
                            }
                            else
                            {
                                simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Throttle must be reduced to Idle before gear change can happen."));
                            }
                        }
                    }
                    else // Legacy operation
                    {
                        GearBoxController.StartDecrease();
                        simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Decrease, GearBoxController.NotchIndex);
                        AlerterReset(TCSEvent.GearBoxChanged);
                        SignalGearBoxChangeEvents();

                    }
                }
            }
            ChangeGearDown();
        }

        public virtual void StopGearBoxDecrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StopDecrease();
            }
        }

        /// <summary>
        /// Trigger sound events when the gearbox increases or decreases.
        /// </summary>
        private void SignalGearBoxChangeEvents()
        {
            // Only activate sound event if notch has actually changed
            if (GearBoxController.NotchIndex != previousGearBoxNotch)
            {
                switch (GearBoxController.NotchIndex)
                {
                    case 0:
                        SignalEvent(TrainEvent.GearPosition0);
                        break;
                    case 1:
                        SignalEvent(TrainEvent.GearPosition1);
                        break;
                    case 2:
                        SignalEvent(TrainEvent.GearPosition2);
                        break;
                    case 3:
                        SignalEvent(TrainEvent.GearPosition3);
                        break;
                    case 4:
                        SignalEvent(TrainEvent.GearPosition4);
                        break;
                    case 5:
                        SignalEvent(TrainEvent.GearPosition5);
                        break;
                    case 6:
                        SignalEvent(TrainEvent.GearPosition6);
                        break;
                    case 7:
                        SignalEvent(TrainEvent.GearPosition7);
                        break;
                    default:
                        SignalEvent(TrainEvent.GearPosition8);
                        break;
                }
                previousGearBoxNotch = GearBoxController.NotchIndex; // Update previous value for next time around
            }
        }

        public void SetGearBoxValue(float value) // control for cabview
        {
            var controller = GearBoxController;
            var oldValue = controller.CurrentValue;
            var change = controller.SetValue(value);
            var dieselloco = this as MSTSDieselLocomotive;
            if (change != 0)
            {
                //new GearBoxCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                SignalEvent(change > 0 ? TrainEvent.GearUp : TrainEvent.GearDown);
                AlerterReset(TCSEvent.GearBoxChanged);
            }

            if (controller.CurrentValue > oldValue)
            {
                simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Increase, GearBoxController.NotchIndex);
                if (dieselloco != null)
                    dieselloco.DieselEngines[0].GearBox.ManualGearUp = true;

            }
            else if (controller.CurrentValue < oldValue)
            {
                simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Decrease, GearBoxController.NotchIndex);
                if (dieselloco != null)
                    dieselloco.DieselEngines[0].GearBox.ManualGearDown = true;
            }
        }
        #endregion

        #region TrainBrakeController
        public void StartTrainBrakeIncrease()
        {
            StartTrainBrakeIncrease(null);
        }

        public void StartTrainBrakeIncrease(float? target)
        {
            if (CombinedControlType == CombinedControl.ThrottleAir)
                ThrottleController.SetValue(0);

            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StartIncrease(target);
            TrainBrakeController.CommandStartTime = simulator.ClockTime;
            if (CruiseControl != null && CruiseControl.TrainBrakeCommandHasPriorityOverCruiseControl)
            {
                CruiseControl.TrainBrakePriority = true;
            }
            simulator.Confirmer.Confirm(CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatus());
            SignalEvent(TrainEvent.TrainBrakeChange);
        }

        public void StopTrainBrakeIncrease()
        {
            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StopIncrease();
            new TrainBrakeCommand(simulator.Log, true, TrainBrakeController.CurrentValue, TrainBrakeController.CommandStartTime);
        }

        public void StartTrainBrakeZero()
        {
            StartTrainBrakeDecrease(0, true);
        }

        public void StartTrainBrakeDecrease()
        {
            StartTrainBrakeDecrease(null);
        }

        public void StartTrainBrakeDecrease(float? target, bool toZero = false)
        {
            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StartDecrease(target, toZero);
            TrainBrakeController.CommandStartTime = simulator.ClockTime;
            simulator.Confirmer.Confirm(CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatus());
            SignalEvent(TrainEvent.TrainBrakeChange);
        }

        public void StopTrainBrakeDecrease()
        {
            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StopDecrease();
            _ = new TrainBrakeCommand(simulator.Log, false, TrainBrakeController.CurrentValue, TrainBrakeController.CommandStartTime);
        }

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        /// <param name="increase"></param>
        /// <param name="target"></param>
        public void TrainBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number?
            if (increase)
            {
                if (target > TrainBrakeController.CurrentValue)
                {
                    StartTrainBrakeIncrease(target);
                }
            }
            else
            {
                if (target < TrainBrakeController.CurrentValue)
                {
                    StartTrainBrakeDecrease(target);
                }
            }
        }

        public string GetTrainBrakeStatus()
        {
            string s = (TrainBrakeController as INameValueInformationProvider).DetailInfo["Status"];

            TrainCar lastCar = Train.Cars[^1];
            if (lastCar == this)
                lastCar = Train.Cars[0];
            s += BrakeSystem.GetFullStatus(lastCar.BrakeSystem, BrakeSystemPressureUnits);
            return s;
        }

        public void SetTrainBrakeValue(float value)
        {
            var controller = TrainBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                _ = new TrainBrakeCommand(simulator.Log, change > 0, controller.CurrentValue, simulator.ClockTime);
                if (change > 0 && CruiseControl != null && CruiseControl.TrainBrakeCommandHasPriorityOverCruiseControl)
                    CruiseControl.TrainBrakePriority = true;
                SignalEvent(TrainEvent.TrainBrakeChange);
                AlerterReset(TCSEvent.TrainBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                simulator.Confirmer.Update(CabControl.TrainBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, GetTrainBrakeStatus());
        }

        public void SetTrainBrakePercent(float percent)
        {
            // Insure we have TrainBrakeController ; some vehicles do not
            // such as Hy-rail truck
            // if (HasTrainBrake)
            if (TrainBrakeController.IsValid())
                TrainBrakeController.SetPercent(percent);
        }
        #endregion

        #region EngineBrakeController
        public void StartEngineBrakeIncrease()
        {
            StartEngineBrakeIncrease(null);
        }

        public void StartEngineBrakeIncrease(float? target)
        {
            AlerterReset(TCSEvent.EngineBrakeChanged);
            if (EngineBrakeController == null)
                return;

            if (CruiseControl != null)
                CruiseControl.EngineBrakePriority = true;
            EngineBrakeController.StartIncrease(target);
            simulator.Confirmer.Confirm(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
            SignalEvent(TrainEvent.EngineBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopEngineBrakeIncrease()
        {
            if (EngineBrakeController == null)
                return;

            AlerterReset(TCSEvent.EngineBrakeChanged);
            EngineBrakeController.StopIncrease();
            _ = new EngineBrakeCommand(simulator.Log, true, EngineBrakeController.CurrentValue, EngineBrakeController.CommandStartTime);
        }

        public void StartEngineBrakeDecrease()
        {
            StartEngineBrakeDecrease(null);
        }

        public void StartEngineBrakeDecrease(float? target)
        {
            if (EngineBrakeController == null)
                return;

            AlerterReset(TCSEvent.EngineBrakeChanged);
            EngineBrakeController.StartDecrease(target);
            EngineBrakeController.CommandStartTime = simulator.ClockTime; // Remember when the command was issued
            simulator.Confirmer.Confirm(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
            SignalEvent(TrainEvent.EngineBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopEngineBrakeDecrease()
        {
            if (EngineBrakeController == null)
                return;

            AlerterReset(TCSEvent.EngineBrakeChanged);
            EngineBrakeController.StopDecrease();
            new EngineBrakeCommand(simulator.Log, false, EngineBrakeController.CurrentValue, EngineBrakeController.CommandStartTime);
        }

        public void EngineBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (increase)
            {
                if (target > EngineBrakeController.CurrentValue)
                {
                    StartEngineBrakeIncrease(target);
                }
            }
            else
            {
                if (target < EngineBrakeController.CurrentValue)
                {
                    StartEngineBrakeDecrease(target);
                }
            }
        }

        public void SetEngineBrakeValue(float value)
        {
            var controller = EngineBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new EngineBrakeCommand(simulator.Log, change > 0, controller.CurrentValue, simulator.ClockTime);
                SignalEvent(TrainEvent.EngineBrakeChange);
                AlerterReset(TCSEvent.EngineBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                simulator.Confirmer.Update(CabControl.EngineBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, GetEngineBrakeStatus());
        }

        public void SetEngineBrakePercent(float percent)
        {
            if (EngineBrakeController == null)
                return;
            EngineBrakeController.SetPercent(percent);
        }

        public string GetEngineBrakeStatus()
        {
            if (EngineBrakeController == null)
                return null;
            // If brake type is only a state, and no numerical fraction application is displayed in the HUD, then display Brake Cylinder (BC) pressure
            if (float.IsNaN(EngineBrakeController.ControllerValue)) // Test to see if a brake state only is present without a fraction of application, if no value, display BC pressure
            {
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    if (SteamEngineBrakeFitted)
                    {
                        const float percentageConversion = 100;
                        return $"{EngineBrakeController.GetStatus()} {percentageConversion * EngineBrakeController.CurrentValue}%";  // Display for steam brake
                    }
                    else
                    {
                        return $"{EngineBrakeController.GetStatus()} BC {FormatStrings.FormatPressure(Pressure.Vacuum.FromPressure(Train.HUDLocomotiveBrakeCylinderPSI), Pressure.Unit.InHg, Pressure.Unit.InHg, true)}";
                    }
                }
                else
                {
                    return $"{EngineBrakeController.GetStatus()} BC {FormatStrings.FormatPressure(Train.HUDLocomotiveBrakeCylinderPSI, Pressure.Unit.PSI, MainPressureUnit, true)} {(BailOff ? " BailOff" : "")}";
                }

                // Fraction not found so display BC                
            }
            else
            {
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    return $"{EngineBrakeController.GetStatus()}";  // Fraction found so don't display BC
                }
                else
                {
                    return $"{EngineBrakeController.GetStatus()}{(BailOff ? " BailOff" : "")}";  // Fraction found so don't display BC
                }
            }
        }
        #endregion

        #region BrakemanBrakeController
        public void StartBrakemanBrakeIncrease()
        {
            StartBrakemanBrakeIncrease(null);
        }

        public void StartBrakemanBrakeIncrease(float? target)
        {
            AlerterReset(TCSEvent.BrakemanBrakeChanged);
            if (BrakemanBrakeController == null)
                return;

            BrakemanBrakeController.StartIncrease(target);
            simulator.Confirmer.Confirm(CabControl.BrakemanBrake, CabSetting.Increase, GetBrakemanBrakeStatus());
            //            SignalEvent(Event.EngineBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopBrakemanBrakeIncrease()
        {
            if (BrakemanBrakeController == null)
                return;

            //   AlerterReset(TCSEvent.BrakemanBrakeChanged);
            BrakemanBrakeController.StopIncrease();
            new BrakemanBrakeCommand(simulator.Log, true, BrakemanBrakeController.CurrentValue, BrakemanBrakeController.CommandStartTime);
        }

        public void StartBrakemanBrakeDecrease()
        {
            StartBrakemanBrakeDecrease(null);
        }

        public void StartBrakemanBrakeDecrease(float? target)
        {
            if (BrakemanBrakeController == null)
                return;

            AlerterReset(TCSEvent.BrakemanBrakeChanged);
            BrakemanBrakeController.StartDecrease(target);
            BrakemanBrakeController.CommandStartTime = simulator.ClockTime; // Remember when the command was issued
            simulator.Confirmer.Confirm(CabControl.BrakemanBrake, CabSetting.Increase, GetBrakemanBrakeStatus());
            //   SignalEvent(Event.BrakemanBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopBrakemanBrakeDecrease()
        {
            if (BrakemanBrakeController == null)
                return;

            AlerterReset(TCSEvent.BrakemanBrakeChanged);
            BrakemanBrakeController.StopDecrease();
            new BrakemanBrakeCommand(simulator.Log, false, BrakemanBrakeController.CurrentValue, BrakemanBrakeController.CommandStartTime);
        }

        public void BrakemanBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (increase)
            {
                if (target > BrakemanBrakeController.CurrentValue)
                {
                    StartBrakemanBrakeIncrease(target);
                }
            }
            else
            {
                if (target < BrakemanBrakeController.CurrentValue)
                {
                    StartBrakemanBrakeDecrease(target);
                }
            }
        }

        public void SetBrakemanBrakeValue(float value)
        {
            var controller = BrakemanBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                _ = new BrakemanBrakeCommand(simulator.Log, change > 0, controller.CurrentValue, simulator.ClockTime);
                //   SignalEvent(Event.BrakemanBrakeChange);
                AlerterReset(TCSEvent.BrakemanBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                simulator.Confirmer.Update(CabControl.BrakemanBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, GetBrakemanBrakeStatus());
        }

        public void SetBrakemanBrakePercent(float percent)
        {
            if (BrakemanBrakeController == null)
                return;
            BrakemanBrakeController.SetPercent(percent);
        }

        public string GetBrakemanBrakeStatus()
        {
            if (BrakemanBrakeController == null)
                return null;
            return $"{BrakemanBrakeController.GetStatus()}";
        }

        #endregion

        #region DynamicBrakeController
        public void StartDynamicBrakeIncrease()
        {
            StartDynamicBrakeIncrease(null);
        }

        public void StartDynamicBrakeIncrease(float? target)
        {
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (CruiseControl != null && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && (CruiseControl.DynamicBrakeCommandHasPriorityOverCruiseControl ||
                CruiseControl.DisableCruiseControlOnThrottleAndZeroForce && CruiseControl.SelectedMaxAccelerationPercent == 0))
            {
                ThrottlePercent = 0;
                CruiseControl.DynamicBrakePriority = true;
            }
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent < 0)
            {
                DynamicBrakeChangeActiveState(true);
            }
            else if (DynamicBrake)
            {
                SignalEvent(TrainEvent.DynamicBrakeChange);
                DynamicBrakeController.StartIncrease(target);
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeIncrease();
                    simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public void StopDynamicBrakeIncrease()
        {
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (CanUseDynamicBrake())
            {
                DynamicBrakeController.StopIncrease();
                _ = new DynamicBrakeCommand(simulator.Log, true, DynamicBrakeController.CurrentValue, DynamicBrakeController.CommandStartTime);
            }
        }

        public void StartDynamicBrakeDecrease()
        {
            StartDynamicBrakeDecrease(null);
        }

        public void StartDynamicBrakeDecrease(float? target)
        {
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent <= 0)
            {
                DynamicBrakeChangeActiveState(false);
            }
            else if (DynamicBrake)
            {
                SignalEvent(TrainEvent.DynamicBrakeChange);
                DynamicBrakeController.StartDecrease(target);
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeDecrease();
                    simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public void StopDynamicBrakeDecrease()
        {
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (CanUseDynamicBrake())
            {
                DynamicBrakeController.StopDecrease();
                _ = new DynamicBrakeCommand(simulator.Log, false, DynamicBrakeController.CurrentValue, DynamicBrakeController.CommandStartTime);
            }
        }

        public void DynamicBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (increase)
            {
                if (target > DynamicBrakeController.CurrentValue)
                {
                    StartDynamicBrakeIncrease(target);
                }
            }
            else
            {
                if (target < DynamicBrakeController.CurrentValue)
                {
                    StartDynamicBrakeDecrease(target);
                }
            }
        }

        public void SetDynamicBrakeValue(float value)
        {
            if (!DynamicBrake && ThrottleController.CurrentValue == 0 && value > 0.05f)
            {
                DynamicBrakeChangeActiveState(true);
                if (CruiseControl != null && CruiseControl.SpeedRegulatorMode == SpeedRegulatorMode.Auto && CruiseControl.DynamicBrakeCommandHasPriorityOverCruiseControl)
                {
                    CruiseControl.DynamicBrakePriority = true;
                }
            }
            if (DynamicBrake && DynamicBrakeController.CurrentValue == 0 && value < -0.05f)
            {
                DynamicBrakeChangeActiveState(false);
                return;
            }
            if (!DynamicBrake || CruiseControl != null && CruiseControl.UseThrottleAsForceSelector && !CruiseControl.DynamicBrakePriority && !CruiseControl.UseThrottleInCombinedControl)
                return;

            var controller = DynamicBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                _ = new DynamicBrakeCommand(simulator.Log, change > 0, controller.CurrentValue, simulator.ClockTime);
                SignalEvent(TrainEvent.DynamicBrakeChange);
                AlerterReset(TCSEvent.DynamicBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                simulator.Confirmer.UpdateWithPerCent(CabControl.DynamicBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, DynamicBrakeController.CurrentValue * 100);
        }

        public void SetDynamicBrakePercent(float percent)
        {
            if (!CanUseDynamicBrake())
                return;
            DynamicBrakeController.SetPercent(percent);
            DynamicBrakeChangeActiveState(percent >= 0);
        }

        public void SetDynamicBrakePercentWithSound(float percent)
        {
            if (!CanUseDynamicBrake())
                return;
            var oldDynamicBrakePercent = DynamicBrakeController.CurrentValue * 100;
            SetDynamicBrakePercent(percent);
            if (Math.Abs(oldDynamicBrakePercent - DynamicBrakeController.CurrentValue * 100) > 2)
                SignalEvent(TrainEvent.DynamicBrakeChange);
        }

        public void DynamicBrakeChangeActiveState(bool toState)
        {
            if (toState && !DynamicBrake && DynamicBrakePercent < 0)
            {
                DynamicBrakePercent = 0;
                DynamicBrakeController.CommandStartTime = simulator.ClockTime;
                StopDynamicBrakeIncrease();
            }
            else if (!toState && DynamicBrake && DynamicBrakePercent > -1 && DynamicBrakeIntervention < 0)
            {
                SignalEvent(TrainEvent.DynamicBrakeOff);
                DynamicBrakePercent = -1;
                DynamicBrakeController.CommandStartTime = simulator.ClockTime;
                StopDynamicBrakeIncrease();
            }
        }

        protected bool CanUseDynamicBrake()
        {
            return (DynamicBrakeController != null
                && ThrottlePercent == 0);
        }

        public string GetDynamicBrakeStatus()
        {
            if (DynamicBrakeController == null)
                return null;
            if (DynamicBrakePercent < 0)
                return string.Empty;
            return $"{DynamicBrakePercent:F0}%";
        }

        public string GetDistributedPowerDynamicBrakeStatus()
        {
            if (DynamicBrakeController == null)
                return null;
            string dpStatus = this is MSTSDieselLocomotive && Train.DistributedPowerMode == DistributedPowerMode.Brake ? $"({Train.DPDynamicBrakePercent:F0}%)" : string.Empty;
            if (DynamicBrakePercent < 0)
                return dpStatus;
            if (TrainControlSystem.FullDynamicBrakingOrder)
                return $"{DynamicBrakePercent:F0}% {dpStatus}";
            return $"{DynamicBrakeController.GetStatus()} {dpStatus}";
        }
        #endregion

        public override void SignalEvent(PowerSupplyEvent evt)
        {
            LocomotivePowerSupply.HandleEvent(evt);

            base.SignalEvent(evt);
        }

        public override void SignalEvent(PowerSupplyEvent evt, int id)
        {
            LocomotivePowerSupply.HandleEvent(evt, id);

            base.SignalEvent(evt, id);
        }

        public virtual void SetPower(bool toState)
        {
            LocomotivePowerSupply.HandleEvent(toState ? PowerSupplyEvent.QuickPowerOn : PowerSupplyEvent.QuickPowerOff);
        }

        public override void SignalEvent(TCSEvent evt)
        {
            TrainControlSystem.HandleEvent(evt);

            base.SignalEvent(evt);
        }

        internal void ToggleMUCommand(bool ToState)
        {
            RemoteControlGroup = ToState ? RemoteControlGroup.FrontGroupSync : RemoteControlGroup.Unconnected;
        }

        public void SetTrainHandbrake(bool apply)
        {
            if (apply)
            {
                Train.SetHandbrakePercent(100);
                simulator.Confirmer.Confirm(CabControl.Handbrake, CabSetting.On);
            }
            else
            {
                Train.SetHandbrakePercent(0);
                simulator.Confirmer.Confirm(CabControl.Handbrake, CabSetting.Off);
            }
        }

        public void SetTrainRetainers(bool apply)
        {
            Train.SetRetainers(apply);
            simulator.Confirmer.ConfirmWithPerCent(CabControl.Retainers, CabSetting.Increase, Train.BrakeSystem.RetainerPercent, (int)CabSetting.Range1 + (int)Train.BrakeSystem.RetainerSetting);
        }

        public void BrakeHoseConnect(bool apply)
        {
            if (apply)
            {
                Train.ConnectBrakeHoses();
                simulator.Confirmer.Confirm(CabControl.BrakeHose, CabSetting.On);
            }
            else
            {
                Train.DisconnectBrakes();
                simulator.Confirmer.Confirm(CabControl.BrakeHose, CabSetting.Off);
            }
        }

        public void ToggleCabLight()
        {
            if (this is MSTSSteamLocomotive)
                return;

            CabLightOn = !CabLightOn;
            SignalEvent(TrainEvent.CabLightSwitchToggle);
            simulator.Confirmer.Confirm(CabControl.CabLight, CabLightOn ? CabSetting.On : CabSetting.Off);
        }



        public void ToggleCabRadio(bool newState)
        {
            CabRadioOn = newState;
            if (!OnLineCabRadio)
            {
                if (CabRadioOn)
                    SignalEvent(TrainEvent.CabRadioOn); // hook for sound trigger
                else
                    SignalEvent(TrainEvent.CabRadioOff);
            }
            else if (!string.IsNullOrEmpty(OnLineCabRadioURL))
            { }
            if (simulator.PlayerLocomotive == this)
                simulator.Confirmer.Confirm(CabControl.CabRadio, CabRadioOn ? CabSetting.On : CabSetting.Off);
        }

        public void ToggleWipers(bool newState)
        {
            SignalEvent(newState ? TrainEvent.WiperOn : TrainEvent.WiperOff);
        }

        public void SetBailOff(bool bailOff)
        {
            if (bailOff != BailOff)
            {
                BailOff = bailOff;
                simulator.Confirmer.Confirm(CabControl.BailOff, bailOff ? CabSetting.On : CabSetting.Off);
            }
        }

        public virtual void Refuel()
        {
            // Electric locos do nothing. Diesel and steam override this.
        }

        public void OdometerToggle()
        {
            OdometerVisible = !OdometerVisible;
        }

        /// <summary>
        /// Set odometer reference distance to actual travelled distance,
        /// and set measuring direction to the actual direction
        /// </summary>
        public void OdometerReset(bool targetState)
        {
            if (Train == null)
                return;
            if (targetState)
            {
                if (odometerCountingForwards != odometerCountingUp ^ (Direction == MidpointDirection.Reverse))
                {
                    odometerCountingForwards = !odometerCountingForwards;
                }

                odometerResetPositionM = Direction == MidpointDirection.Reverse
                    ? odometerCountingForwards ? Train.DistanceTravelledM - Train.Length : Train.DistanceTravelledM
                    : odometerCountingForwards ? Train.DistanceTravelledM : Train.DistanceTravelledM + Train.Length;

                simulator.Confirmer.Confirm(CabControl.Odometer, CabSetting.On);
            }
            OdometerResetButtonPressed = targetState;
        }

        public void OdometerToggleDirection()
        {
            if (Train == null)
                return;

            odometerCountingUp = !odometerCountingUp;

            simulator.Confirmer.Confirm(CabControl.Odometer, odometerCountingUp ? CabSetting.Increase : CabSetting.Decrease);
        }

        public void GenericItem1Toggle()
        {
            GenericItem1 = !GenericItem1;
            SignalEvent(GenericItem1 ? TrainEvent.GenericItem1On : TrainEvent.GenericItem1Off); // hook for sound trigger
        }

        public void GenericItem2Toggle()
        {
            GenericItem2 = !GenericItem2;
            SignalEvent(GenericItem2 ? TrainEvent.GenericItem2On : TrainEvent.GenericItem2Off); // hook for sound trigger
        }

        public override bool GetCabFlipped()
        {
            return UsingRearCab;
        }

        public void AlerterReset()
        {
            TrainControlSystem.HandleEvent(TCSEvent.AlerterReset);
        }

        public void AlerterReset(TCSEvent evt)
        {
            AlerterReset();
            TrainControlSystem.HandleEvent(evt);
        }

        public void AlerterPressed(bool pressed)
        {
            TrainControlSystem.AlerterPressed(pressed);
        }

        public override void SignalEvent(TrainEvent evt)
        {
            switch (evt)
            {
                case TrainEvent.VigilanceAlarmOn:
                    { AlerterSnd = true; if (simulator.Settings.Alerter) simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.On); break; }
                case TrainEvent.VigilanceAlarmOff:
                    { AlerterSnd = false; if (simulator.Settings.Alerter) simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.Off); break; }
                case TrainEvent.BellOn:
                case TrainEvent.BellOff:
                    if (this == simulator.PlayerLocomotive && simulator.Confirmer != null)
                        simulator.Confirmer.Confirm(CabControl.Bell, Bell ? CabSetting.On : CabSetting.Off);
                    break;
                case TrainEvent.HornOn:
                case TrainEvent.HornOff:
                    if (this == simulator.PlayerLocomotive && simulator.Confirmer != null)
                        simulator.Confirmer.Confirm(this is MSTSSteamLocomotive ? CabControl.Whistle : CabControl.Horn, Horn ? CabSetting.On : CabSetting.Off);
                    break;
                case TrainEvent.SanderOn:
                    {
                        Sander = true;
                        if (IsLeadLocomotive() && this == simulator.PlayerLocomotive)
                            simulator.Confirmer?.Confirm(CabControl.Sander, CabSetting.On);
                        break;
                    }
                case TrainEvent.SanderOff:
                    {
                        Sander = false;
                        if (IsLeadLocomotive() && this == simulator.PlayerLocomotive)
                            simulator.Confirmer?.Confirm(CabControl.Sander, CabSetting.Off);
                        break;
                    }
                case TrainEvent.WiperOn:
                    {
                        Wiper = true;
                        if (this == simulator.PlayerLocomotive)
                            simulator.Confirmer?.Confirm(CabControl.Wipers, CabSetting.On);
                        break;
                    }
                case TrainEvent.WiperOff:
                    {
                        Wiper = false;
                        if (this == simulator.PlayerLocomotive)
                            simulator.Confirmer?.Confirm(CabControl.Wipers, CabSetting.Off);
                        break;
                    }

                // <CJComment> The "H" key doesn't call these SignalEvents yet. </CJComment>
                case TrainEvent.HeadlightOff:
                    { Headlight = HeadLightState.HeadlightOff; break; }
                case TrainEvent.HeadlightDim:
                    { Headlight = HeadLightState.HeadlightDimmed; break; }
                case TrainEvent.HeadlightOn:
                    { Headlight = HeadLightState.HeadlightOn; break; }

                case TrainEvent.CompressorOn:
                    { CompressorIsOn = true; break; }
                case TrainEvent.CompressorOff:
                    { CompressorIsOn = false; break; }

                //Vacuum exhauster event only triggered if vacuum exhauster engine control fitted.
                case TrainEvent.VacuumExhausterOn:
                    { if (FastVacuumExhausterFitted) VacuumExhausterPressed = true; if (this.IsLeadLocomotive() && this == simulator.PlayerLocomotive && simulator.Confirmer != null) simulator.Confirmer.Confirm(CabControl.VacuumExhauster, CabSetting.On); break; }
                case TrainEvent.VacuumExhausterOff:
                    { if (FastVacuumExhausterFitted) VacuumExhausterPressed = false; if (this.IsLeadLocomotive() && this == simulator.PlayerLocomotive && simulator.Confirmer != null) simulator.Confirmer.Confirm(CabControl.VacuumExhauster, CabSetting.Off); break; }

                case TrainEvent.ResetWheelSlip:
                    { LocomotiveAxle.Reset(simulator.GameTime, SpeedMpS); ThrottleController.SetValue(0.0f); break; }
                case TrainEvent.TrainBrakePressureDecrease:
                case TrainEvent.TrainBrakePressureIncrease:
                    {
                        if (Train.TrainType == TrainType.Ai || Train.TrainType == TrainType.AiPlayerHosting)
                        {
                            if (Simulator.Instance.GameTime - LastBrakeSoundTime < 15) // don't repeat sound too often for AI trains (which frequently set brakes on and off)
                            {
                                return;
                            }
                            LastBrakeSoundTime = Simulator.Instance.GameTime;
                        }
                        break;
                    }
            }

            base.SignalEvent(evt);
        }


        public virtual float GetDataOf(CabViewControl cvc)
        {
            float data = 0;
            switch (cvc.ControlType.CabViewControlType)
            {
                case CabViewControlType.Speedometer:
                    {
                        //data = SpeedMpS;
                        if (AdvancedAdhesionModel)
                            data = WheelSpeedMpS;
                        else
                            data = SpeedMpS;

                        if (cvc.ControlUnit == CabViewControlUnit.Km_Per_Hour)
                            data *= 3.6f;
                        else // MPH
                            data *= 2.2369f;
                        data = Math.Abs(data);
                        break;
                    }
                case CabViewControlType.Speed_Projected:
                    {
                        if (Train != null)
                            data = Train.ProjectedSpeedMpS;
                        else
                            data = 0;
                        if (cvc.ControlUnit == CabViewControlUnit.Km_Per_Hour)
                            data *= 3.6f;
                        else // MPH
                            data *= 2.2369f;
                        data = Math.Abs(data);
                        break;
                    }
                case CabViewControlType.Accelerometer:
                    {
                        switch (cvc.ControlUnit)
                        {
                            case CabViewControlUnit.Metres_Sec_Sec:
                                data = this.AccelerationMpSS;
                                break;

                            case CabViewControlUnit.Metres_Sec_Hour:
                                data = this.AccelerationMpSS * 3600.0f;
                                break;

                            case CabViewControlUnit.Km_Hour_Sec:
                                data = this.AccelerationMpSS * 3.6f;
                                break;

                            case CabViewControlUnit.Km_Hour_Hour:
                                data = this.AccelerationMpSS * 3.6f * 3600.0f;
                                break;

                            case CabViewControlUnit.Miles_Hour_Min:
                                data = this.AccelerationMpSS * 2.236936f * 60.0f;
                                break;

                            case CabViewControlUnit.Miles_Hour_Hour:
                                // 
                                data = this.AccelerationMpSS * 2.236936f * 3600.0f;
                                break;

                            default:
                                data = this.AccelerationMpSS;
                                break;

                        }
                        break;
                    }

                case CabViewControlType.Orts_Water_Scoop:
                    data = WaterScoopDown ? 1 : 0;
                    break;

                case CabViewControlType.Steam_Heat:
                    data = SteamHeatController.CurrentValue;
                    break;

                case CabViewControlType.AmMeter: // Current not modelled yet to ammeter shows tractive effort until then.
                case CabViewControlType.AmMeter_Abs:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CabViewGaugeControl && ((CabViewGaugeControl)cvc).Orientation == 0)
                            direction = ((CabViewGaugeControl)cvc).Direction;
                        if (MaxCurrentA == 0)
                            MaxCurrentA = (float)cvc.ScaleRangeMax;
                        if (LocomotiveAxle != null)
                        {
                            data = 0.0f;
                            if (ThrottlePercent > 0)
                            {
                                //float rangeFactor = direction == 0 ? (float)cvc.MaxValue : (float)cvc.MinValue;
                                float rangeFactor = direction == 0 ? MaxCurrentA : (float)cvc.ScaleRangeMin;
                                if (FilteredMotiveForceN != 0)
                                    data = this.FilteredMotiveForceN / MaxForceN * rangeFactor;
                                else
                                    data = this.LocomotiveAxle.DriveForceN / MaxForceN * rangeFactor;
                                data = Math.Abs(data);
                            }
                            if (DynamicBrakePercent > 0 && MaxDynamicBrakeForceN > 0)
                            {
                                float rangeFactor;
                                if (cvc.ControlType.CabViewControlType == CabViewControlType.AmMeter_Abs)
                                {
                                    if (DynamicBrakeMaxCurrentA == 0)
                                        rangeFactor = direction == 0 ? (float)cvc.ScaleRangeMax : (float)cvc.ScaleRangeMin;
                                    else
                                        rangeFactor = direction == 0 ? DynamicBrakeMaxCurrentA : (float)cvc.ScaleRangeMin;
                                }
                                else
                                {
                                    if (DynamicBrakeMaxCurrentA == 0)
                                        rangeFactor = direction == 0 ? (float)cvc.ScaleRangeMin : (float)cvc.ScaleRangeMax;
                                    else
                                        rangeFactor = direction == 0 ? -DynamicBrakeMaxCurrentA : (float)cvc.ScaleRangeMax;
                                }
                                data = DynamicBrakeForceN / MaxDynamicBrakeForceN * rangeFactor;
                            }
                            if (direction == 1)
                                data = -data;
                            if (cvc.ControlType.CabViewControlType == CabViewControlType.AmMeter_Abs)
                                data = Math.Abs(data);
                            break;
                        }
                        data = this.MotiveForceN / MaxForceN * MaxCurrentA;
                        if (cvc.ControlType.CabViewControlType == CabViewControlType.AmMeter_Abs)
                            data = Math.Abs(data);
                        break;
                    }
                case CabViewControlType.Load_Meter:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CabViewGaugeControl && ((CabViewGaugeControl)cvc).Orientation == 0)
                            direction = ((CabViewGaugeControl)cvc).Direction;
                        if (MaxCurrentA == 0)
                            MaxCurrentA = (float)cvc.ScaleRangeMax;
                        if (DynamicBrakeMaxCurrentA == 0)
                            DynamicBrakeMaxCurrentA = (float)cvc.ScaleRangeMin;
                        data = 0.0f;
                        if (ThrottlePercent > 0)
                        {
                            if (FilteredMotiveForceN != 0)
                                data = this.FilteredMotiveForceN / MaxForceN * MaxCurrentA;
                            else
                                data = this.LocomotiveAxle.DriveForceN / MaxForceN * MaxCurrentA;
                            data = Math.Abs(data);
                        }
                        if (DynamicBrakePercent > 0 && MaxDynamicBrakeForceN > 0)
                        {
                            data = DynamicBrakeForceN / MaxDynamicBrakeForceN * DynamicBrakeMaxCurrentA;
                            data = -Math.Abs(data); // Ensure that dynamic force is seen as a "-ve force", changes colour on the load meter
                        }
                        if (direction == 1)
                            data = -data;
                        break;
                    }
                case CabViewControlType.Traction_Braking:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CabViewGaugeControl && ((CabViewGaugeControl)cvc).Orientation == 0)
                            direction = ((CabViewGaugeControl)cvc).Direction;
                        data = 0.0f;
                        if (FilteredMotiveForceN != 0)
                            data = this.FilteredMotiveForceN;
                        else
                            data = this.LocomotiveAxle.DriveForceN;
                        if (DynamicBrakePercent > 0)
                        {
                            data = DynamicBrakeForceN;
                        }
                        data = Math.Abs(data);
                        switch (cvc.ControlUnit)
                        {
                            case CabViewControlUnit.Amps:
                                if (MaxCurrentA == 0)
                                    MaxCurrentA = (float)cvc.ScaleRangeMax;
                                if (DynamicBrakeMaxCurrentA == 0)
                                    DynamicBrakeMaxCurrentA = (float)cvc.ScaleRangeMin;
                                if (ThrottlePercent > 0)
                                {
                                    data = (data / MaxForceN) * MaxCurrentA;
                                }
                                if (DynamicBrakePercent > 0)
                                {
                                    data = (DynamicBrakeForceN / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                                }
                                data = Math.Abs(data);
                                break;

                            case CabViewControlUnit.Newtons:
                                break;

                            case CabViewControlUnit.Kilo_Newtons:
                                data = data / 1000.0f;
                                break;

                            case CabViewControlUnit.Kilo_Lbs:
                                data = (float)Dynamics.Force.ToLbf(data) / 1000f;
                                break;
                        }
                        if (direction == 1 && !(cvc is CabViewGaugeControl))
                            data = -data;
                        break;
                    }
                case CabViewControlType.Orts_Signed_Traction_Braking:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CabViewGaugeControl cvgc && cvgc.Orientation == 0)
                            direction = cvgc.Direction;
                        data = 0.0f;
                        if (FilteredMotiveForceN != 0)
                            data = Math.Abs(this.FilteredMotiveForceN);
                        else
                            data = Math.Abs(this.LocomotiveAxle.DriveForceN);
                        if (DynamicBrakePercent > 0)
                        {
                            data = -Math.Abs(DynamicBrakeForceN);
                        }
                        switch (cvc.ControlUnit)
                        {
                            case CabViewControlUnit.Amps:
                                if (MaxCurrentA == 0)
                                    MaxCurrentA = (float)cvc.ScaleRangeMax;
                                if (DynamicBrakeMaxCurrentA == 0)
                                    DynamicBrakeMaxCurrentA = (float)cvc.ScaleRangeMin;
                                if (ThrottlePercent >= 0 && DynamicBrakePercent == -1)
                                {
                                    data = (data / MaxForceN) * MaxCurrentA;
                                }
                                if (ThrottlePercent == 0 && DynamicBrakePercent >= 0)
                                {
                                    data = (data / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                                }
                                break;

                            case CabViewControlUnit.Newtons:
                                break;

                            case CabViewControlUnit.Kilo_Newtons:
                                data = data / 1000.0f;
                                break;

                            case CabViewControlUnit.Kilo_Lbs:
                                data = (float)Dynamics.Force.ToLbf(data) / 1000f;
                                break;
                        }
                        //                       if (direction == 1 && !(cvc is CVCGauge))
                        //                           data = -data;
                        break;
                    }
                // this considers both the dynamic as well as the train braking
                case CabViewControlType.Orts_Signed_Traction_Total_Braking:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CabViewGaugeControl cvcGauge && cvcGauge.Orientation == 0)
                            direction = cvcGauge.Direction;
                        data = 0.0f;
                        if (Math.Abs(SpeedMpS) == 0.0f)
                            data = 0.0f;
                        else if (Math.Abs(FilteredMotiveForceN) - Math.Abs(BrakeForceN + DynamicBrakeForceN) > 0)
                            data = Math.Abs(this.FilteredMotiveForceN);
                        else if (Math.Abs(FilteredMotiveForceN) - Math.Abs(BrakeForceN + DynamicBrakeForceN) < 0)
                            data = -Math.Abs(BrakeForceN + DynamicBrakeForceN);
                        switch (cvc.ControlUnit)
                        {
                            case CabViewControlUnit.Newtons:
                                break;

                            case CabViewControlUnit.Kilo_Newtons:
                                data = data / 1000.0f;
                                break;

                            case CabViewControlUnit.Kilo_Lbs:
                                data = (float)Dynamics.Force.ToLbf(data) / 1000f;
                                break;
                        }
                        break;
                    }
                case CabViewControlType.Dynamic_Brake_Force:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CabViewGaugeControl && ((CabViewGaugeControl)cvc).Orientation == 0)
                            direction = ((CabViewGaugeControl)cvc).Direction;
                        data = 0.0f;
                        data = DynamicBrakeForceN;
                        if (data > 0 && SpeedMpS > 0 || data < 0 && SpeedMpS < 0)
                        {
                            data = 0;
                            break;
                        }
                        data = Math.Abs(data);
                        switch (cvc.ControlUnit)
                        {
                            case CabViewControlUnit.Amps:
                                if (MaxCurrentA == 0)
                                    MaxCurrentA = (float)cvc.ScaleRangeMax;
                                if (DynamicBrakeMaxCurrentA == 0)
                                    DynamicBrakeMaxCurrentA = (float)cvc.ScaleRangeMin;
                                if (ThrottlePercent > 0)
                                {
                                    data = 0;
                                }
                                if (DynamicBrakePercent > 0)
                                {
                                    data = (DynamicBrakeForceN / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                                }
                                data = Math.Abs(data);
                                break;

                            case CabViewControlUnit.Newtons:
                                break;

                            case CabViewControlUnit.Kilo_Newtons:
                                data = data / 1000.0f;
                                break;

                            case CabViewControlUnit.Kilo_Lbs:
                                data = (float)Dynamics.Force.ToLbf(data) / 1000f;
                                break;
                        }
                        if (direction == 1 && !(cvc is CabViewGaugeControl))
                            data = -data;
                        break;
                    }
                case CabViewControlType.Main_Res:
                    {
                        data = ConvertFromPSI(cvc, MainResPressurePSI);
                        break;
                    }
                case CabViewControlType.Main_Res_Pipe:
                    {
                        data = ConvertFromPSI(cvc, this.BrakeSystem.BrakeLine2PressurePSI);
                        break;
                    }
                case CabViewControlType.Brake_Pipe:
                    {
                        data = ConvertFromPSI(cvc, this.BrakeSystem.BrakeLine1PressurePSI);
                        break;
                    }
                case CabViewControlType.Eq_Res:
                    {
                        data = ConvertFromPSI(cvc, (float)this.Train.BrakeSystem.EqualReservoirPressurePSIorInHg);
                        break;
                    }
                case CabViewControlType.Brake_Cyl:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.GetCylPressurePSI());
                        break;
                    }
                case CabViewControlType.Vacuum_Reservoir_Pressure:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.VacResPressurePSI);
                        break;
                    }
                case CabViewControlType.Orts_Eot_Brake_Pipe:
                    {
                        data = ConvertFromPSI(cvc, this.Train.Cars.Last().BrakeSystem.BrakeLine1PressurePSI);
                        break;
                    }
                case CabViewControlType.Rpm:
                    {

                        if (EngineType == EngineType.Control)
                        {
                            FindControlActiveLocomotive();

                            if (ControlActiveLocomotive != null)
                            {
                                var activeloco = ControlActiveLocomotive as MSTSDieselLocomotive;
                                if (activeloco.DieselEngines[0] != null)
                                    data = activeloco.DieselEngines[0].RealRPM;
                            }

                        }
                        else
                        {
                            var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                            if (mstsDieselLocomotive.DieselEngines[0] != null)
                                data = mstsDieselLocomotive.DieselEngines[0].RealRPM;
                        }
                        break;
                    }

                case CabViewControlType.Rpm2:
                    {

                        FindControlActiveLocomotive();

                        if (ControlActiveLocomotive != null)
                        {
                            var activeloco = ControlActiveLocomotive as MSTSDieselLocomotive;
                            var mstsDieselLocomotive = this as MSTSDieselLocomotive;

                            if (EngineType == EngineType.Control && activeloco.DieselEngines.NumOfActiveEngines > 1)
                            {

                                if (activeloco.DieselEngines[1] != null)
                                    data = activeloco.DieselEngines[1].RealRPM;
                            }
                            else if (EngineType == EngineType.Diesel && mstsDieselLocomotive.DieselEngines.NumOfActiveEngines > 1)
                            {
                                if (mstsDieselLocomotive.DieselEngines[1] != null)
                                    data = mstsDieselLocomotive.DieselEngines[1].RealRPM;
                            }
                        }
                        break;
                    }
                case CabViewControlType.Orts_Diesel_Temperature:
                    {

                        if (EngineType == EngineType.Control)
                        {
                            FindControlActiveLocomotive();

                            if (ControlActiveLocomotive != null)
                            {
                                var activeloco = ControlActiveLocomotive as MSTSDieselLocomotive;
                                if (activeloco.DieselEngines[0] != null)
                                    data = activeloco.DieselEngines[0].DieselTemperatureDeg;
                            }

                        }
                        else
                        {
                            var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                            if (mstsDieselLocomotive.DieselEngines[0] != null)
                                data = mstsDieselLocomotive.DieselEngines[0].DieselTemperatureDeg;
                        }
                        break;
                    }
                case CabViewControlType.Orts_Oil_Pressure:
                    {
                        if (EngineType == EngineType.Control)
                        {
                            FindControlActiveLocomotive();

                            if (ControlActiveLocomotive != null)
                            {
                                var activeloco = ControlActiveLocomotive as MSTSDieselLocomotive;
                                if (activeloco.DieselEngines[0] != null)
                                    data = activeloco.DieselEngines[0].DieselOilPressurePSI;
                            }

                        }
                        else
                        {
                            var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                            if (mstsDieselLocomotive.DieselEngines[0] != null)
                                data = mstsDieselLocomotive.DieselEngines[0].DieselOilPressurePSI;
                        }
                        break;
                    }
                case CabViewControlType.Throttle:
                    if (CruiseControl != null && CruiseControl.SkipThrottleDisplay)
                        break;
                    data = GetThrottleHandleValue(Train.TrainType == TrainType.AiPlayerHosting ? ThrottlePercent / 100f : LocalThrottlePercent / 100f);
                    break;
                case CabViewControlType.Throttle_Display:
                case CabViewControlType.Cph_Display:
                    {
                        if (CruiseControl != null && CruiseControl.SkipThrottleDisplay)
                            break;
                        data = Train.TrainType == TrainType.AiPlayerHosting ? ThrottlePercent / 100f : LocalThrottlePercent / 100f;
                        break;
                    }
                case CabViewControlType.Engine_Brake:
                    {
                        data = (EngineBrakeController == null) ? 0.0f : EngineBrakeController.CurrentValue;
                        break;
                    }
                case CabViewControlType.Train_Brake:
                    {
                        if (CruiseControl != null && CruiseControl.UsingTrainBrake)
                            break;
                        data = (TrainBrakeController == null) ? 0.0f : TrainBrakeController.CurrentValue;
                        break;
                    }
                case CabViewControlType.Orts_Bailoff:
                    {
                        data = BailOff ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Orts_QuickRelease:
                    {
                        data = (TrainBrakeController == null || !TrainBrakeController.QuickReleaseButtonPressed) ? 0 : 1;
                        break;
                    }
                case CabViewControlType.Orts_Overcharge:
                    {
                        data = (TrainBrakeController == null || !TrainBrakeController.OverchargeButtonPressed) ? 0 : 1;
                        break;
                    }
                case CabViewControlType.Friction_Braking:
                    {
                        data = (BrakeSystem == null) ? 0.0f : BrakeSystem.GetCylPressurePSI();
                        break;
                    }
                case CabViewControlType.Dynamic_Brake:
                case CabViewControlType.Dynamic_Brake_Display:
                    //case CABViewControlTypes.CP_HANDLE:
                    {
                        data = DynamicBrakePercent / 100f;
                        break;
                    }
                case CabViewControlType.Wipers:
                    {
                        data = Wiper ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Vacuum_Exhauster:
                    {
                        if (FastVacuumExhausterFitted)
                        {
                            data = VacuumExhausterPressed ? 1 : 0;
                        }
                        else
                        {
                            data = 0;
                        }
                        break;
                    }

                case CabViewControlType.Horn:
                    {
                        data = Horn ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Bell:
                    {
                        data = Bell ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Reset:
                    {
                        if (TrainControlSystem.AlerterButtonPressed)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }

                case CabViewControlType.Alerter_Display:
                    {
                        if (simulator.Settings.Alerter)
                        {
                            if (TrainControlSystem.VigilanceEmergency)
                                data = 2;
                            else if (TrainControlSystem.VigilanceAlarm)
                                data = 1;
                            else
                                data = 0;
                        }
                        break;
                    }
                case CabViewControlType.OverSpeed:
                    {
                        data = TrainControlSystem.OverspeedWarning ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Penalty_App:
                    {
                        data = TrainControlSystem.PenaltyApplication ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Emergency_Brake:
                    {
                        data = EmergencyButtonPressed ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Doors_Display:
                    {
                        data = Train.DoorState(DoorSide.Both) != DoorState.Closed ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Sanders:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                // MultStateDisplay entry in CVF file had Type SANDING. W/O the below entry and another entry at line 3625
                // the independant sanding light found in some cabs would not work.
                case CabViewControlType.Sanding:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Clock:
                    {
                        data = 0;
                        break;
                    }

                case CabViewControlType.Front_HLight:
                    {
                        data = (int)Headlight;
                        break;
                    }
                case CabViewControlType.WheelSlip:
                    {
                        if (EngineType == EngineType.Control)
                        {
                            FindControlActiveLocomotive();

                            if (ControlActiveLocomotive != null)
                            {
                                var activeloco = ControlActiveLocomotive as MSTSDieselLocomotive;
                                if (activeloco.DieselEngines[0] != null)
                                {
                                    if (activeloco.AdvancedAdhesionModel && Train.TrainType != TrainType.AiPlayerHosting)
                                        data = activeloco.WheelSlipWarning ? 1 : 0;
                                    else
                                        data = activeloco.WheelSlip ? 1 : 0;

                                }
                            }

                        }
                        else
                        {
                            if (AdvancedAdhesionModel && Train.TrainType != TrainType.AiPlayerHosting)
                                data = WheelSlipWarning ? 1 : 0;
                            else
                                data = base.WheelSlip ? 1 : 0;
                        }
                        break;
                    }

                case CabViewControlType.Direction:
                case CabViewControlType.Direction_Display:
                    {
                        if (Direction == MidpointDirection.Forward)
                            data = 2;
                        else if (Direction == MidpointDirection.Reverse)
                            data = 0;
                        else
                            data = 1;
                        break;
                    }
                case CabViewControlType.Aspect_Display:
                    {
                        switch (TrainControlSystem.CabSignalAspect)
                        {
                            case TrackMonitorSignalAspect.Stop:
                                {
                                    data = 0;
                                    break;
                                }
                            case TrackMonitorSignalAspect.StopAndProceed:
                                {
                                    data = 1;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Restricted:
                                {
                                    data = 2;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach1:
                                {
                                    data = 3;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach2:
                                {
                                    data = 4;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach3:
                                {
                                    data = 5;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Clear1:
                                {
                                    data = 6;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Clear2:
                                {
                                    data = 7;
                                    break;
                                }
                            default:
                                {
                                    data = 7;
                                    break;
                                }
                        }
                        break;
                    }
                case CabViewControlType.SpeedLimit:
                    {
                        // Displays current allowable speed
                        bool metric = cvc.ControlUnit == CabViewControlUnit.Km_Per_Hour;
                        data = (float)Speed.MeterPerSecond.FromMpS(TrainControlSystem.CurrentSpeedLimitMpS, metric);
                        break;
                    }
                case CabViewControlType.SpeedLim_Display:
                    {
                        // Displays allowable speed shown on next signal
                        bool metric = cvc.ControlUnit == CabViewControlUnit.Km_Per_Hour;
                        data = (float)Speed.MeterPerSecond.FromMpS(TrainControlSystem.NextSpeedLimitMpS, metric);
                        break;
                    }
                case CabViewControlType.Gears_Display:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive dieselLocomotive && dieselLocomotive.DieselEngines.GearBox is GearBox gearBox)
                        {
                            data = gearBox.GearIndication;
                        }
                        break;
                    }
                case CabViewControlType.Cab_Radio:
                    {
                        data = CabRadioOn ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Orts_Player_Diesel_Engine:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = (dieselLoco.DieselEngines[0].State == DieselEngineState.Running ||
                                dieselLoco.DieselEngines[0].State == DieselEngineState.Starting) ? 1 : 0;
                        }
                        break;
                    }
                case CabViewControlType.Orts_Helpers_Diesel_Engines:
                    {
                        foreach (var car in Train.Cars)
                        {
                            var dieselLoco = car as MSTSDieselLocomotive;
                            if (dieselLoco != null && dieselLoco.RemoteControlGroup != RemoteControlGroup.Unconnected)
                            {
                                if (car == simulator.PlayerLocomotive && dieselLoco.DieselEngines.Count > 1)
                                {
                                    data = (dieselLoco.DieselEngines[1].State == DieselEngineState.Running ||
                                        dieselLoco.DieselEngines[1].State == DieselEngineState.Starting) ? 1 : 0;
                                    break;
                                }
                                else if (car != simulator.PlayerLocomotive)
                                {
                                    data = (dieselLoco.DieselEngines[0].State == DieselEngineState.Running ||
                                        dieselLoco.DieselEngines[0].State == DieselEngineState.Starting) ? 1 : 0;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                case CabViewControlType.Orts_Player_Diesel_Engine_State:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = (int)dieselLoco.DieselEngines[0].State;
                        }
                        break;
                    }
                case CabViewControlType.Orts_Player_Diesel_Engine_Starter:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = dieselLoco.DieselEngines[0].State == DieselEngineState.Starting ? 1 : 0;
                        }
                        break;
                    }
                case CabViewControlType.Orts_Player_Diesel_Engine_Stopper:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = dieselLoco.DieselEngines[0].State == DieselEngineState.Stopping ? 1 : 0;
                        }
                        break;
                    }
                case CabViewControlType.Orts_CabLight:
                    data = CabLightOn ? 1 : 0;
                    break;
                case CabViewControlType.Orts_LeftDoor:
                case CabViewControlType.Orts_RightDoor:
                    {
                        bool right = (cvc.ControlType.CabViewControlType == CabViewControlType.Orts_RightDoor) ^ Flipped ^ GetCabFlipped();
                        var state = Train.DoorState(right ? DoorSide.Right : DoorSide.Left);
                        data = state >= DoorState.Opening ? 1 : 0;
                    }
                    break;
                case CabViewControlType.Orts_Mirros:
                    data = MirrorOpen ? 1 : 0;
                    break;
                case CabViewControlType.Orts_2DExternalWipers:
                    data = Wiper ? 1 : 0;
                    break;
                case CabViewControlType.Orts_HourDial:
                    float hour = (float)(simulator.ClockTime / 3600) % 12;
                    if (hour < 0)
                        hour += 12;
                    data = hour;
                    break;
                case CabViewControlType.Orts_MinuteDial:
                    float minute = (float)(simulator.ClockTime / 60) % 60;
                    if (minute < 0)
                        minute += 60;
                    data = minute;
                    break;
                case CabViewControlType.Orts_SecondDial:
                    int seconds = (int)simulator.ClockTime % 60;
                    if (seconds < 0)
                        seconds += 60;
                    data = seconds;
                    break;
                case CabViewControlType.Orts_Generic_Item1:
                    {
                        data = GenericItem1 ? 1 : 0;
                        break;
                    }
                case CabViewControlType.Orts_Generic_Item2:
                    {
                        data = GenericItem2 ? 1 : 0;
                        break;
                    }

                case CabViewControlType.Orts_TCS:
                    TrainControlSystem.CabDisplayControls.TryGetValue(cvc.ControlType.Id - 1, out data);
                    break;

                case CabViewControlType.Orts_Battery_Switch_Command_Switch:
                    data = LocomotivePowerSupply.BatterySwitch.CommandSwitch ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Battery_Switch_Command_Button_Close:
                    data = LocomotivePowerSupply.BatterySwitch.CommandButtonOn ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Battery_Switch_Command_Button_Open:
                    data = LocomotivePowerSupply.BatterySwitch.CommandButtonOff ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Battery_Switch_On:
                    data = LocomotivePowerSupply.BatterySwitch.On ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Master_Key:
                    data = LocomotivePowerSupply.MasterKey.CommandSwitch ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Current_Cab_In_Use:
                    data = LocomotivePowerSupply.MasterKey.On ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Other_Cab_In_Use:
                    data = LocomotivePowerSupply.MasterKey.OtherCabInUse ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Service_Retention_Button:
                    data = LocomotivePowerSupply.ServiceRetentionButton ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Service_Retention_Cancellation_Button:
                    data = LocomotivePowerSupply.ServiceRetentionCancellationButton ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Electric_Train_Supply_Command_Switch:
                    data = LocomotivePowerSupply.ElectricTrainSupplySwitch.CommandSwitch ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Electric_Train_Supply_On:
                    data = LocomotivePowerSupply.ElectricTrainSupplyOn ? 1 : 0;
                    break;

                case CabViewControlType.Orts_Odometer:
                    switch (cvc.ControlUnit)
                    {
                        case CabViewControlUnit.Kilometres:
                            data = (float)Size.Length.ToKM(OdometerM);
                            break;
                        case CabViewControlUnit.Miles:
                            data = (float)Size.Length.ToMi(OdometerM);
                            break;
                        case CabViewControlUnit.Feet:
                            data = (float)Size.Length.ToFt(OdometerM);
                            break;
                        case CabViewControlUnit.Yards:
                            data = (float)Size.Length.ToYd(OdometerM);
                            break;
                        case CabViewControlUnit.Metres:
                        default:
                            data = OdometerM;
                            break;
                    }
                    break;
                case CabViewControlType.Orts_Odometer_Direction:
                    data = odometerCountingUp ? 1 : 0;
                    break;
                case CabViewControlType.Orts_Odometer_Reset:
                    data = OdometerResetButtonPressed ? 1 : 0;
                    break;
                case CabViewControlType.Orts_Multi_Position_Controller:
                    if (MultiPositionControllers != null)
                    {
                        foreach (MultiPositionController controller in MultiPositionControllers)
                            if (controller.ControllerId == cvc.ControlId)
                            {
                                data = controller.GetDataOf(cvc);
                                break;
                            }
                    }
                    break;
                default:
                    {
                        if (CruiseControl != null)
                            data = CruiseControl.GetDataOf(cvc);

                        if (Train?.EndOfTrainDevice != null && data == 0)
                            data = Train.EndOfTrainDevice.GetDataOf(cvc);
                        break;
                    }
            }
            return data;
        }

        protected static float ConvertFromPSI(CabViewControl cvc, float data)
        {
            if (cvc.ControlUnit == CabViewControlUnit.Bar)
                data = (float)Pressure.Atmospheric.FromPSI(data);
            else if (cvc.ControlUnit == CabViewControlUnit.KiloPascals)
                data = (float)Pressure.Standard.FromPSI(data);
            else if (cvc.ControlUnit == CabViewControlUnit.Kgs_Per_Square_Cm)
                data *= 70.307e-3f;
            else if (cvc.ControlUnit == CabViewControlUnit.Inches_Of_Mercury)
                data = (float)Pressure.Vacuum.FromPressure(data);
            return data;
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual void RefillImmediately()
        {
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual MSTSNotchController GetRefillController(PickupType type)
        {
            return null;
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual void SetStepSize(PickupObject matchPickup)
        {
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public override float GetFilledFraction(PickupType pickupType)
        {
            return 0f;
        }

        public override void SwitchToPlayerControl()
        {
            base.SwitchToPlayerControl();
            return;
        }

        public override void SwitchToAutopilotControl()
        {
            base.SwitchToAutopilotControl();
            return;
        }

        private protected override void UpdateCarStatus()
        {
            base.UpdateCarStatus();
            carInfo["Engine Type"] = EngineType.GetLocalizedDescription();
            carInfo["Throttle"] = $"{ThrottlePercent:0}";
            // For Locomotive HUD display shows "forward" motive power (& force) as a positive value, braking power (& force) will be shown as negative values.
            carInfo["Power"] = FormatStrings.FormatPower(MotiveForceN * SpeedMpS, simulator.MetricUnits, false, false);
            carInfo["Force"] = FormatStrings.FormatForce(MotiveForceN * (Flipped ? -1 : 1), simulator.MetricUnits);
            carInfo.FormattingOptions["Force"] = base.WheelSlip ? FormatOption.RegularOrangeRed : WheelSlipWarning ? FormatOption.RegularYellow : null;

            // Only show steam heating HUD if fitted to locomotive and the train, has passenger cars attached, and is the lead locomotive
            if (IsSteamHeatFitted && Train.PassengerCarsNumber > 0 && IsLeadLocomotive() && Train.CarSteamHeatOn)
            {
                carInfo[".steamheat0"] = null;
                carInfo["Steam Heat Pressure Front"] = FormatStrings.FormatPressure(CurrentSteamHeatPressurePSI, Pressure.Unit.PSI, MainPressureUnit, true);
                carInfo["Steam Heat Temperature"] = FormatStrings.FormatTemperature(Temperature.Celsius.FromF(SteamHeatPressureToTemperaturePSItoF[CurrentSteamHeatPressurePSI]), simulator.MetricUnits);
                carInfo["Steam Heat Usage"] = $"{FormatStrings.FormatMass(Frequency.Periodic.ToHours(Mass.Kilogram.FromLb(CalculatedCarHeaterSteamUsageLBpS)), simulator.MetricUnits)}/{FormatStrings.h}";
                carInfo["Steam Heat Water Level"] = FormatStrings.FormatFuelVolume(CurrentLocomotiveSteamHeatBoilerWaterCapacityL, simulator.MetricUnits, Simulator.Instance.Settings.MeasurementUnit == MeasurementUnit.UK);
                carInfo["Steam Heat Pressure Rear"] = FormatStrings.FormatPressure(Train.LastCar.carSteamHeatMainPipeSteamPressurePSI, Pressure.Unit.PSI, MainPressureUnit, true);
                carInfo["Steam Heat Temperature Rear"] = FormatStrings.FormatTemperature(Train.LastCar.CarInsideTempC, simulator.MetricUnits);
                carInfo["Outside Temperature"] = FormatStrings.FormatTemperature(CarOutsideTempC, simulator.MetricUnits);
                carInfo["Steam Heat Flow Rate"] = $"{Train.LastCar.carNetHeatFlowRateW:N0}";
                carInfo[".steamheat1"] = null;
            }
        }

        private protected class LocomotiveBrakeInformation : DetailInfoBase
        {
            private readonly MSTSLocomotive locomotive;

            public LocomotiveBrakeInformation(MSTSLocomotive locomotive) : base(true)
            {
                this.locomotive = locomotive;
            }

            public override void Update(GameTime gameTime)
            {
                if (UpdateNeeded)
                {
                    this["Car"] = locomotive.CarID;
                    if (locomotive.BrakeSystem is VacuumSinglePipe) // If vacuum brakes are used
                    {
                        if (locomotive.VacuumBrakeEQFitted)
                        {
                            this["Main reservoir"] = FormatStrings.FormatPressure(Pressure.Vacuum.FromPressure(locomotive.VacuumMainResVacuumPSIAorInHg), Pressure.Unit.InHg, Pressure.Unit.InHg, true);
                            this["Exhauster"] = locomotive.VacuumExhausterIsOn ? "on" : "off";
                        }
                        else if (locomotive.VacuumPumpFitted)
                        {
                            if (locomotive.SmallEjectorControllerFitted) // Display if vacuum pump, large ejector and small ejector fitted
                            {
                                this["Large Ejector"] = locomotive.LargeSteamEjectorIsOn ? "on" : "off";
                                this["Small Ejector"] = locomotive.SmallSteamEjectorIsOn ? "on" : "off";
                                this["Pressure"] = FormatStrings.FormatPressure(locomotive.SteamEjectorSmallPressurePSI, Pressure.Unit.PSI, locomotive.BrakeSystemPressureUnits[BrakeSystemComponent.MainReservoir], true);
                                this["Vacuum Pump"] = locomotive.VacuumPumpOperating ? "on" : "off";
                            }
                            else // Display if vacuum pump, and large ejector only fitted
                            {
                                this["Large Ejector"] = locomotive.LargeSteamEjectorIsOn ? "on" : "off";
                                this["Vacuum Pump"] = locomotive.VacuumPumpOperating ? "on" : "off";
                            }
                        }
                        else // Display if large ejector and small ejector only fitted
                        {
                            this["Large Ejector"] = locomotive.LargeSteamEjectorIsOn ? "on" : "off";
                            this["Small Ejector"] = locomotive.SmallSteamEjectorIsOn ? "on" : "off";
                            this["Pressure"] = FormatStrings.FormatPressure(locomotive.SteamEjectorSmallPressurePSI, Pressure.Unit.PSI, locomotive.BrakeSystemPressureUnits[BrakeSystemComponent.MainReservoir], true);
                        }

                        // Lines to show brake system volumes
                        this["Train Pipe Vol"] = FormatStrings.FormatVolume(locomotive.Train.BrakeSystem.TotalTrainBrakePipeVolume, Simulator.Instance.MetricUnits);
                        this["Brake Cylinder Vol"] = FormatStrings.FormatVolume(locomotive.Train.BrakeSystem.TotalTrainBrakeCylinderVolume, Simulator.Instance.MetricUnits);
                        this["Air Vol"] = FormatStrings.FormatVolume(locomotive.Train.BrakeSystem.TotalCurrentTrainBrakeSystemVolume, Simulator.Instance.MetricUnits);
                    }
                    else
                    {
                        this["Main reservoir"] = locomotive.EngineType == EngineType.Control ? "None" : FormatStrings.FormatPressure(locomotive.MainResPressurePSI, Pressure.Unit.PSI, locomotive.BrakeSystemPressureUnits[BrakeSystemComponent.MainReservoir], true);
                        this["Compressor"] = locomotive.EngineType == EngineType.Control ? "None" : locomotive.CompressorIsOn ? "on" : "off";
                    }
                }
            }
        }

        private protected class LocomotiveForceInformation : DetailInfoBase
        {
            private readonly MSTSLocomotive locomotive;
            private static readonly bool metricUnits = Simulator.Instance.MetricUnits;

            public LocomotiveForceInformation(MSTSLocomotive locomotive) : base(true)
            {
                this.locomotive = locomotive;
                this["Adhesion model"] = null;
            }

            public override void Update(GameTime gameTime)
            {
                if (UpdateNeeded)
                {
                    this["Car"] = locomotive.CarID;
                    this["Loco Adhesion"] = $"{locomotive.LocomotiveCoefficientFrictionHUD * 100:F0}%";
                    this["Wagon Adhesion"] = $"{locomotive.WagonCoefficientFrictionHUD * 100:F0}%";
                    if (locomotive.AdvancedAdhesionModel)
                    {
                        this["Adhesion model"] = "Advanced Adhesion model";
                        this["Wheel ang. pos."] = $"{(int)(locomotive.LocomotiveAxle.AxlePositionRad * 180 / Math.PI + 180)}";
                        if (locomotive.EngineType == EngineType.Steam && (locomotive is MSTSSteamLocomotive steamEngine &&
                            (steamEngine.SteamEngineType == SteamEngineType.Compound || steamEngine.SteamEngineType == SteamEngineType.Simple || steamEngine.SteamEngineType == SteamEngineType.Unknown))) // For display of steam locomotive adhesion info
                        {
                            this["Tangential Force"] = FormatStrings.FormatForce(Dynamics.Force.FromLbf(locomotive.SteamTangentialWheelForce), metricUnits);
                            this["Static Force"] = FormatStrings.FormatForce(Dynamics.Force.FromLbf(locomotive.SteamStaticWheelForce), metricUnits);
                            this["Wheel Speed"] = $"{FormatStrings.FormatSpeedDisplay(locomotive.WheelSpeedSlipMpS, metricUnits)} ({FormatStrings.FormatSpeedDisplay(locomotive.LocomotiveAxle.SlipSpeedMpS, metricUnits)})";
                        }
                        else  // Advanced adhesion non steam locomotives
                        {
                            this["Wheel slip"] = $"{locomotive.LocomotiveAxle.SlipSpeedPercent:F0}% ({locomotive.LocomotiveAxle.SlipDerivationPercentpS:F0}%/{FormatStrings.s})";
                            this["Conditions"] = $"{locomotive.adhesionConditions * 100.0f:F0}%";
                            this["Axle drive force"] = $"{FormatStrings.FormatForce(locomotive.LocomotiveAxle.DriveForceN, metricUnits)} ({FormatStrings.FormatPower(locomotive.LocomotiveAxle.DriveForceN * locomotive.AbsTractionSpeedMpS, metricUnits, false, false)})";
                            this["Axle brake force"] = FormatStrings.FormatForce(locomotive.LocomotiveAxle.BrakeRetardForceN, metricUnits);
                            this["Number of substeps"] = $"{locomotive.LocomotiveAxle.NumOfSubstepsPS:F0}";
                            this["Stability correction"] = $"{locomotive.LocomotiveAxle.AdhesionK:F0}";
                            this["Axle out force"] = $"{FormatStrings.FormatForce(locomotive.LocomotiveAxle.AxleForceN, metricUnits)} ({FormatStrings.FormatPower(locomotive.LocomotiveAxle.AxleForceN * locomotive.AbsTractionSpeedMpS, metricUnits, false, false)})";
                            this["Comp Axle out force"] = $"{FormatStrings.FormatForce(locomotive.LocomotiveAxle.CompensatedAxleForceN, metricUnits)} ({FormatStrings.FormatPower(locomotive.LocomotiveAxle.CompensatedAxleForceN * locomotive.AbsTractionSpeedMpS, metricUnits, false, false)})";
                            this["Wheel Speed"] = $"{FormatStrings.FormatSpeedDisplay(locomotive.AbsWheelSpeedMpS, metricUnits)} ({FormatStrings.FormatSpeedDisplay(locomotive.LocomotiveAxle.SlipSpeedMpS, metricUnits)})";
                        }
                    }
                    else
                    {
                        this["Adhesion model"] = "Simple Adhesion model";
                        this["Axle out force"] = $"{FormatStrings.FormatForce(locomotive.LocomotiveAxle.AxleForceN, metricUnits)} ({FormatStrings.FormatPower(locomotive.LocomotiveAxle.AxleForceN * locomotive.AbsTractionSpeedMpS, metricUnits, false, false)})";
                    }
                    this[".Wind"] = null;
                    this["Wind Speed"] = FormatStrings.FormatSpeedDisplay(locomotive.Train.PhysicsWindSpeedMpS, metricUnits);
                    this["Wind Direction"] = $"{locomotive.Train.PhysicsWindDirectionDeg:0} deg";
                    this["Train Direction"] = $"{locomotive.Train.PhysicsTrainLocoDirectionDeg:0} deg";
                    this["Resultant Wind:"] = $"{locomotive.Train.ResultantWindComponentDeg:0} deg";
                    this["Resultant Speed"] = FormatStrings.FormatSpeedDisplay(locomotive.Train.WindResultantSpeedMpS, metricUnits);
                    base.Update(gameTime);
                }
            }
        }
    } // End Class MSTSLocomotive

    public class CabView
    {
        public CabViewFile CVFFile { get; }
        public ReadOnlyCollection<ViewPoint> ViewPointList { get; }
        public ExtendedCVF ExtendedCVF { get; }
        public CabViewType CabViewType { get; internal set; }

        public CabView(CabViewFile cvfFile, IList<ViewPoint> viewPointList, ExtendedCVF extendedCVF, CabViewType cabViewType)
        {
            CVFFile = cvfFile;
            ViewPointList = new ReadOnlyCollection<ViewPoint>(viewPointList);
            ExtendedCVF = extendedCVF;
            CabViewType = cabViewType;
        }
    }

    public class CabView3D : CabView
    {
        public string ShapeFilePath { get; }

        public CabView3D(CabViewFile cvfFile, IList<PassengerViewPoint> cabViewpoints, ExtendedCVF extendedCVF, CabViewType cabViewType, string shapeFilePath)
            : base(cvfFile, cabViewpoints.Cast<ViewPoint>().ToList(), extendedCVF, cabViewType)
        {
            ShapeFilePath = shapeFilePath;
        }
    }

    /// <summary>
    /// Extended CVF data, currently used for CAB light
    /// By GeorgeS
    /// </summary>
    //[OrtsPhysicsFile("lit", "ORTSExtendedCVF")]
    public class ExtendedCVF
    {
        // migrated and refactored from OrtsPhysicsFileAttribute and OrtsPhysicsAttribute
        private const string token = "ORTSExtendedCVF";
        private const string extension = "lit";

        /// <summary>
        /// Translate to current screen resolution
        /// </summary>
        /// <param name="displaySize">Current screen resolution</param>
        /// <returns>Translated vectors</returns>
        public static Vector4 TranslatedPosition(Vector4 Position, Point displaySize)
        {
            return new Vector4(Position.X / 640 * displaySize.X,
                Position.Y / 480 * displaySize.Y,
                Position.Z / 640 * displaySize.X,
                Position.W);
        }

        internal virtual void Initialize(string wagFilePath)
        {
            string fileName = Path.ChangeExtension(wagFilePath, extension);
            if (File.Exists(fileName))
            {
                using (STFReader stf = new STFReader(fileName, false))
                {

                    stf.MustMatch(token);
                    stf.MustMatch("(");
                    stf.ParseBlock(new STFReader.TokenProcessor[] {
                            new STFReader.TokenProcessor("light1position", () =>
                            {
                                Vector4 l1 = Light1Position;
                                stf.ReadVector4Block(STFReader.Units.Any, ref l1);
                                Light1Position = l1;
                            }),
                            new STFReader.TokenProcessor("light1colorargb", () =>
                            {
                                Vector4 v4 = new Vector4(-1);
                                stf.ReadVector4Block(STFReader.Units.Any, ref v4);
                                Color c = new Color();
                                if (v4.W == -1)
                                {
                                    c.A = 255;
                                    c.R = v4.X == -1 ? c.R : (byte)v4.X;
                                    c.G = v4.Y == -1 ? c.G : (byte)v4.Y;
                                    c.B = v4.Z == -1 ? c.B : (byte)v4.Z;
                                }
                                else
                                {
                                    c.A = v4.X == -1 ? c.A : (byte)v4.X;
                                    c.R = v4.Y == -1 ? c.R : (byte)v4.Y;
                                    c.G = v4.Z == -1 ? c.G : (byte)v4.Z;
                                    c.B = v4.W == -1 ? c.B : (byte)v4.W;
                                }
                                Light1Color = c;
                            }),
                            new STFReader.TokenProcessor("light2position", () =>
                            {
                                Vector4 l2 = Light1Position;
                                stf.ReadVector4Block(STFReader.Units.Any, ref l2);
                                Light2Position = l2;
                            }),
                            new STFReader.TokenProcessor("light2colorargb", () =>
                            {
                                Vector4 v4 = new Vector4(-1);
                                stf.ReadVector4Block(STFReader.Units.Any, ref v4);
                                Color c = new Color();
                                if (v4.W == -1)
                                {
                                    c.A = 255;
                                    c.R = v4.X == -1 ? c.R : (byte)v4.X;
                                    c.G = v4.Y == -1 ? c.G : (byte)v4.Y;
                                    c.B = v4.Z == -1 ? c.B : (byte)v4.Z;
                                }
                                else
                                {
                                    c.A = v4.X == -1 ? c.A : (byte)v4.X;
                                    c.R = v4.Y == -1 ? c.R : (byte)v4.Y;
                                    c.G = v4.Z == -1 ? c.G : (byte)v4.Z;
                                    c.B = v4.W == -1 ? c.B : (byte)v4.W;
                                }
                                Light2Color = c;
                            }),
                        });
                }
            }
        }

        /// <summary>
        /// Used by the shader
        /// </summary>
        public static Vector3 TranslatedColor(Color Color)
        {
            return new Vector3((float)Color.R / 255, (float)Color.G / 255, (float)Color.B / 255);
        }

        //[OrtsPhysics("First light Position", "Light1Position", "The position and aspect of the first cab light", "320 360 155 2")]
        /// <summary>
        /// The position and aspect of the first cab light
        /// </summary>
        public Vector4 Light1Position { get; private set; } = new Vector4(320, 360, 155, 2);

        //[OrtsPhysics("First light ARGB", "Light1ColorARGB", "The color of the first cab light", "255 216 178 255")]
        /// <summary>
        /// The color of the first cab light
        /// </summary>
        public Color Light1Color { get; private set; } = new Color(255, 216, 178, 255);

        //[OrtsPhysics("Second light Position", "Light2Position", "The position and aspect of the first cab light", "0 0 0 0")]
        /// <summary>
        /// The position and aspect of the first cab light
        /// </summary>
        public Vector4 Light2Position { get; private set; }

        //[OrtsPhysics("Second light ARGB", "Light2ColorARGB", "The color of the second cab light", "0 0 0")]
        /// <summary>
        /// The color of the second cab light
        /// </summary>
        public Color Light2Color { get; private set; }


    } // End Class ExtendedCVF 
}
